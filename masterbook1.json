{"cells": [{"cell_type": "markdown", "metadata": {}, "source": ["## Multi-Line Statements and Strings"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Certain physical newlines are ignored in order to form a complete logical line of code."]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Implicit Examples"]}, {"cell_type": "code", "execution_count": 1, "metadata": {"collapsed": true}, "outputs": [], "source": ["a = [1, \n", "    2, \n", "    3]"]}, {"cell_type": "code", "execution_count": 2, "metadata": {}, "outputs": [{"data": {"text/plain": ["[1, 2, 3]"]}, "execution_count": 2, "metadata": {}, "output_type": "execute_result"}], "source": ["a"]}, {"cell_type": "markdown", "metadata": {}, "source": ["You may also add comments to the end of each physical line:"]}, {"cell_type": "code", "execution_count": 6, "metadata": {"collapsed": true}, "outputs": [], "source": ["a = [1, #first element\n", "    2, #second element\n", "    3, #third element\n", "    ]"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"data": {"text/plain": ["[1, 2, 3]"]}, "execution_count": 4, "metadata": {}, "output_type": "execute_result"}], "source": ["a"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Note if you do use comments, you must close off the collection on a new line.\n", "\n", "i.e. the following will not work since the closing ] is actually part of the comment:"]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"ename": "SyntaxError", "evalue": "unexpected EOF while parsing (<ipython-input-7-ca1d73612a61>, line 2)", "output_type": "error", "traceback": ["\u001b[1;36m  File \u001b[1;32m\"<ipython-input-7-ca1d73612a61>\"\u001b[1;36m, line \u001b[1;32m2\u001b[0m\n\u001b[1;33m    2 #second element]\u001b[0m\n\u001b[1;37m                      ^\u001b[0m\n\u001b[1;31mSyntaxError\u001b[0m\u001b[1;31m:\u001b[0m unexpected EOF while parsing\n"]}], "source": ["a = [1, # first element\n", "    2 #second element]"]}, {"cell_type": "markdown", "metadata": {}, "source": ["This works the same way for tuples, sets, and dictionaries."]}, {"cell_type": "code", "execution_count": 8, "metadata": {"collapsed": true}, "outputs": [], "source": ["a = (1, # first element\n", "    2, #second element\n", "    3, #third element\n", "    )"]}, {"cell_type": "code", "execution_count": 9, "metadata": {}, "outputs": [{"data": {"text/plain": ["(1, 2, 3)"]}, "execution_count": 9, "metadata": {}, "output_type": "execute_result"}], "source": ["a"]}, {"cell_type": "code", "execution_count": 10, "metadata": {"collapsed": true}, "outputs": [], "source": ["a = {1, # first element\n", "    2, #second element\n", "    }"]}, {"cell_type": "code", "execution_count": 11, "metadata": {}, "outputs": [{"data": {"text/plain": ["{1, 2}"]}, "execution_count": 11, "metadata": {}, "output_type": "execute_result"}], "source": ["a"]}, {"cell_type": "code", "execution_count": 15, "metadata": {"collapsed": true}, "outputs": [], "source": ["a = {'key1': 'value1', #comment,\n", "    'key2': #comment\n", "    'value2' #comment\n", "    }"]}, {"cell_type": "code", "execution_count": 13, "metadata": {}, "outputs": [{"data": {"text/plain": ["{'key1': 'value1', 'key2': 'value2'}"]}, "execution_count": 13, "metadata": {}, "output_type": "execute_result"}], "source": ["a"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can also break up function arguments and parameters:"]}, {"cell_type": "code", "execution_count": 18, "metadata": {"collapsed": true}, "outputs": [], "source": ["def my_func(a, #some comment\n", "           b, c):\n", "    print(a, b, c)"]}, {"cell_type": "code", "execution_count": 19, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["10 20 30\n"]}], "source": ["my_func(10, #comment\n", "       20, #comment\n", "       30)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Explicit Examples"]}, {"cell_type": "markdown", "metadata": {}, "source": ["You can use the ``\\`` character to explicitly create multi-line statements."]}, {"cell_type": "code", "execution_count": 23, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["yes!!\n"]}], "source": ["a = 10\n", "b = 20\n", "c = 30\n", "if a > 5 \\\n", "    and b > 10 \\\n", "    and c > 20:\n", "    print('yes!!')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The identation in continued-lines does not matter:"]}, {"cell_type": "code", "execution_count": 22, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["yes!!\n"]}], "source": ["a = 10\n", "b = 20\n", "c = 30\n", "if a > 5 \\\n", "    and b > 10 \\\n", "        and c > 20:\n", "    print('yes!!')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Multi-Line Strings"]}, {"cell_type": "markdown", "metadata": {}, "source": ["You can create multi-line strings by using triple delimiters (single or double quotes)"]}, {"cell_type": "code", "execution_count": 26, "metadata": {"collapsed": true}, "outputs": [], "source": ["a = '''this is\n", "a multi-line string'''"]}, {"cell_type": "code", "execution_count": 27, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["this is\n", "a multi-line string\n"]}], "source": ["print(a)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Note how the newline character we typed in the multi-line string was preserved. Any character you type is preserved. You can also mix in escaped characters line any normal string."]}, {"cell_type": "code", "execution_count": 34, "metadata": {"collapsed": true}, "outputs": [], "source": ["a = \"\"\"some items:\\n\n", "    1. item 1\n", "    2. item 2\"\"\""]}, {"cell_type": "code", "execution_count": 35, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["some items:\n", "\n", "    1. item 1\n", "    2. item 2\n"]}], "source": ["print(a)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Be careful if you indent your multi-line strings - the extra spaces are preserved!"]}, {"cell_type": "code", "execution_count": 41, "metadata": {"collapsed": true}, "outputs": [], "source": ["def my_func():\n", "    a = '''a multi-line string\n", "    that is actually indented in the second line'''\n", "    return a"]}, {"cell_type": "code", "execution_count": 42, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["a multi-line string\n", "    that is actually indented in the second line\n"]}], "source": ["print(my_func())"]}, {"cell_type": "code", "execution_count": 45, "metadata": {"collapsed": true}, "outputs": [], "source": ["def my_func():\n", "    a = '''a multi-line string\n", "that is not indented in the second line'''\n", "    return a"]}, {"cell_type": "code", "execution_count": 46, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["a multi-line string\n", "that is not indented in the second line\n"]}], "source": ["print(my_func())"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Note that these multi-line strings are **not** comments - they are real strings and, unlike comments, are part of your compiled code. They are however sometimes used to create comments, such as ``docstrings``, that we will cover later in this course."]}, {"cell_type": "markdown", "metadata": {}, "source": ["In general, use ``#`` to comment your code, and use multi-line strings only when actually needed (like for docstrings)."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Also, there are no multi-line comments in Python. You simply have to use a ``#`` on every line."]}, {"cell_type": "code", "execution_count": 47, "metadata": {"collapsed": true}, "outputs": [], "source": ["# this is\n", "#    a multi-line\n", "#    comment"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The following works, but the above formatting is preferrable."]}, {"cell_type": "code", "execution_count": 55, "metadata": {"collapsed": true}, "outputs": [], "source": ["# this is\n", "    # a multi-line\n", "    # comment"]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Conditionals"]}, {"cell_type": "markdown", "metadata": {}, "source": ["A conditional is a construct that allows you to branch your code based on conditions being met (or not)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["This is achieved using **if**, **elif** and **else** or the **ternary operator** (aka conditional expression)"]}, {"cell_type": "code", "execution_count": 2, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["a < 3\n"]}], "source": ["a = 2\n", "if a < 3:\n", "    print('a < 3')\n", "else:\n", "    print('a >= 3')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["**if** statements can be nested:"]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["a >= 10\n"]}], "source": ["a = 15\n", "\n", "if a < 5:\n", "    print('a < 5')\n", "else:\n", "    if a < 10:\n", "        print('5 <= a < 10')\n", "    else:\n", "        print('a >= 10')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But the **elif** statement provides far better readability:"]}, {"cell_type": "code", "execution_count": 8, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["a >= 10\n"]}], "source": ["a = 15\n", "if a < 5:\n", "    print('a < 5')\n", "elif a < 10:\n", "    print('5 <= a < 10')\n", "else:\n", "    print('a >= 10')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["In Python, **elif** is the closest you'll find to the switch/case statement available in some other languages."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Python also provides a conditional expression (ternary operator):\n", "\n", "X if (condition) else Y\n", "\n", "returns (and evaluates) X if (condition) is True, otherwise returns (and evaluates) Y"]}, {"cell_type": "code", "execution_count": 1, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["a < 10\n"]}], "source": ["a = 5\n", "res = 'a < 10' if a < 10 else 'a >= 10'\n", "print(res)"]}, {"cell_type": "code", "execution_count": 13, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["a >= 10\n"]}], "source": ["a = 15\n", "res = 'a < 10' if a < 10 else 'a >= 10'\n", "print(res)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Note that **X** and **Y** can be any expression, not just literal values:"]}, {"cell_type": "code", "execution_count": 15, "metadata": {"collapsed": true}, "outputs": [], "source": ["def say_hello():\n", "    print('Hello!')\n", "    \n", "def say_goodbye():\n", "    print('Goodbye!')"]}, {"cell_type": "code", "execution_count": 16, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Hello!\n"]}], "source": ["a = 5\n", "say_hello() if a < 10 else say_goodbye()"]}, {"cell_type": "code", "execution_count": 17, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Goodbye!\n"]}], "source": ["a = 15\n", "say_hello() if a < 10 else say_goodbye()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Functions"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Python has many built-in functions and methods we can use"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Some are available by default:"]}, {"cell_type": "code", "execution_count": 1, "metadata": {}, "outputs": [{"data": {"text/plain": ["3"]}, "execution_count": 1, "metadata": {}, "output_type": "execute_result"}], "source": ["s = [1, 2, 3]\n", "len(s)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["While some need to be imported:"]}, {"cell_type": "code", "execution_count": 2, "metadata": {"collapsed": true}, "outputs": [], "source": ["from math import sqrt"]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [{"data": {"text/plain": ["2.0"]}, "execution_count": 3, "metadata": {}, "output_type": "execute_result"}], "source": ["sqrt(4)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Entire modules can be imported:"]}, {"cell_type": "code", "execution_count": 4, "metadata": {"collapsed": true}, "outputs": [], "source": ["import math"]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"data": {"text/plain": ["2.718281828459045"]}, "execution_count": 5, "metadata": {}, "output_type": "execute_result"}], "source": ["math.exp(1)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can define our own functions:"]}, {"cell_type": "code", "execution_count": 8, "metadata": {"collapsed": true}, "outputs": [], "source": ["def func_1():\n", "    print('running func1')"]}, {"cell_type": "code", "execution_count": 9, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["running func1\n"]}], "source": ["func_1()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Note that to \"call\" or \"invoke\" a function we need to use the **()**.\n", "\n", "Simply using the function name without the **()** refers to the function, but does not call it:"]}, {"cell_type": "code", "execution_count": 11, "metadata": {}, "outputs": [{"data": {"text/plain": ["<function __main__.func_1>"]}, "execution_count": 11, "metadata": {}, "output_type": "execute_result"}], "source": ["func_1"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can also define functions that take parameters:"]}, {"cell_type": "code", "execution_count": 12, "metadata": {"collapsed": true}, "outputs": [], "source": ["def func_2(a, b):\n", "    return a * b"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Note that **a** and **b** can be any type (this is an example of polymorphism - which we will look into more detail later in this course). \n", "\n", "But the function will fail to run if **a** and **b** are types that are not \"compatible\" with the ***** operator:"]}, {"cell_type": "code", "execution_count": 13, "metadata": {}, "outputs": [{"data": {"text/plain": ["6"]}, "execution_count": 13, "metadata": {}, "output_type": "execute_result"}], "source": ["func_2(3, 2)"]}, {"cell_type": "code", "execution_count": 14, "metadata": {}, "outputs": [{"data": {"text/plain": ["'aaa'"]}, "execution_count": 14, "metadata": {}, "output_type": "execute_result"}], "source": ["func_2('a', 3)"]}, {"cell_type": "code", "execution_count": 15, "metadata": {}, "outputs": [{"data": {"text/plain": ["[1, 2, 3, 1, 2, 3]"]}, "execution_count": 15, "metadata": {}, "output_type": "execute_result"}], "source": ["func_2([1, 2, 3], 2)"]}, {"cell_type": "code", "execution_count": 16, "metadata": {}, "outputs": [{"ename": "TypeError", "evalue": "can't multiply sequence by non-int of type 'str'", "output_type": "error", "traceback": ["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[1;31mTypeError\u001b[0m                                 Traceback (most recent call last)", "\u001b[1;32m<ipython-input-16-4e1c1906827b>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[1;32m----> 1\u001b[1;33m \u001b[0mfunc_2\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34m'a'\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;34m'b'\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m", "\u001b[1;32m<ipython-input-12-abd6021cc10d>\u001b[0m in \u001b[0;36mfunc_2\u001b[1;34m(a, b)\u001b[0m\n\u001b[0;32m      1\u001b[0m \u001b[1;32mdef\u001b[0m \u001b[0mfunc_2\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0ma\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mb\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m----> 2\u001b[1;33m     \u001b[1;32mreturn\u001b[0m \u001b[0ma\u001b[0m \u001b[1;33m*\u001b[0m \u001b[0mb\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m", "\u001b[1;31mTypeError\u001b[0m: can't multiply sequence by non-int of type 'str'"]}], "source": ["func_2('a', 'b')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["It is possible to use **type annotations**:"]}, {"cell_type": "code", "execution_count": 17, "metadata": {"collapsed": true}, "outputs": [], "source": ["def func_3(a: int, b:int):\n", "    return a * b"]}, {"cell_type": "code", "execution_count": 18, "metadata": {}, "outputs": [{"data": {"text/plain": ["6"]}, "execution_count": 18, "metadata": {}, "output_type": "execute_result"}], "source": ["func_3(2, 3)"]}, {"cell_type": "code", "execution_count": 19, "metadata": {}, "outputs": [{"data": {"text/plain": ["'aa'"]}, "execution_count": 19, "metadata": {}, "output_type": "execute_result"}], "source": ["func_3('a', 2)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But as you can see, these do not enforce a data type! They are simply metadata that can be used by external libraries, and many IDE's."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Functions are objects, just like integers are objects, and they can be assigned to variables just as an integer can:"]}, {"cell_type": "code", "execution_count": 20, "metadata": {"collapsed": true}, "outputs": [], "source": ["my_func = func_3"]}, {"cell_type": "code", "execution_count": 21, "metadata": {}, "outputs": [{"data": {"text/plain": ["'aa'"]}, "execution_count": 21, "metadata": {}, "output_type": "execute_result"}], "source": ["my_func('a', 2)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Functions **must** always return something. If you do not specify a return value, Python will automatically return the **None** object:"]}, {"cell_type": "code", "execution_count": 22, "metadata": {"collapsed": true}, "outputs": [], "source": ["def func_4():\n", "    # does something but does not return a value\n", "    a = 2"]}, {"cell_type": "code", "execution_count": 23, "metadata": {"collapsed": true}, "outputs": [], "source": ["res = func_4()"]}, {"cell_type": "code", "execution_count": 24, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["None\n"]}], "source": ["print(res)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The **def** keyword is an executable piece of code that creates the function (an instance of the **function** class) and essentially assigns it to a variable name (the function **name**). \n", "\n", "Note that the function is defined when **def** is reached, but the code inside it is not evaluated until the function is called.\n", "\n", "This is why we can define functions that call other functions defined later - as long as we don't call them before all the necessary functions are defined."]}, {"cell_type": "markdown", "metadata": {}, "source": ["For example, the following will work:"]}, {"cell_type": "code", "execution_count": 31, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Hello\n"]}], "source": ["def fn_1():\n", "    fn_2()\n", "    \n", "def fn_2():\n", "    print('Hello')\n", "    \n", "fn_1()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But this will not work:"]}, {"cell_type": "code", "execution_count": 32, "metadata": {}, "outputs": [{"ename": "NameError", "evalue": "name 'fn_4' is not defined", "output_type": "error", "traceback": ["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[1;31mNameError\u001b[0m                                 Traceback (most recent call last)", "\u001b[1;32m<ipython-input-32-6d843cb5e628>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[0;32m      2\u001b[0m     \u001b[0mfn_4\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m      3\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m----> 4\u001b[1;33m \u001b[0mfn_3\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m      5\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m      6\u001b[0m \u001b[1;32mdef\u001b[0m \u001b[0mfn_4\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n", "\u001b[1;32m<ipython-input-32-6d843cb5e628>\u001b[0m in \u001b[0;36mfn_3\u001b[1;34m()\u001b[0m\n\u001b[0;32m      1\u001b[0m \u001b[1;32mdef\u001b[0m \u001b[0mfn_3\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m----> 2\u001b[1;33m     \u001b[0mfn_4\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m      3\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m      4\u001b[0m \u001b[0mfn_3\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m      5\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n", "\u001b[1;31mNameError\u001b[0m: name 'fn_4' is not defined"]}], "source": ["def fn_3():\n", "    fn_4()\n", "\n", "fn_3()\n", "\n", "def fn_4():\n", "    print('Hello')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We also have the **lambda** keyword, that also creates a new function, but does not assign it to any specific name - instead it just returns the function object - which we can, if we wish, assign to a variable ourselves:"]}, {"cell_type": "code", "execution_count": 28, "metadata": {"collapsed": true}, "outputs": [], "source": ["func_5 = lambda x: x**2"]}, {"cell_type": "code", "execution_count": 29, "metadata": {}, "outputs": [{"data": {"text/plain": ["<function __main__.<lambda>>"]}, "execution_count": 29, "metadata": {}, "output_type": "execute_result"}], "source": ["func_5"]}, {"cell_type": "code", "execution_count": 30, "metadata": {}, "outputs": [{"data": {"text/plain": ["4"]}, "execution_count": 30, "metadata": {}, "output_type": "execute_result"}], "source": ["func_5(2)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We'll examine lambdas in more detail later in this course."]}, {"cell_type": "markdown", "metadata": {}, "source": ["### While Loops"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The **while** loop is a way to repeatg a block of code as long as a specified condition is met."]}, {"cell_type": "markdown", "metadata": {}, "source": ["``while <exp is true>:\n", "    code block``"]}, {"cell_type": "code", "execution_count": 2, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["0\n", "1\n", "2\n", "3\n", "4\n"]}], "source": ["i = 0\n", "while i < 5:\n", "    print(i)\n", "    i += 1"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Note that there is no guarantee that a **while** loop will execute at all, not even once, because the condition is tested **before** the loop runs."]}, {"cell_type": "code", "execution_count": 3, "metadata": {"collapsed": true}, "outputs": [], "source": ["i = 5\n", "while i < 5:\n", "    print(i)\n", "    i += 1"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Some languages have a concept of a while loop that is guaranteed to execute at least once:\n", "\n", "``do\n", "    code block\n", "while <exp is true>\n", "``"]}, {"cell_type": "markdown", "metadata": {}, "source": ["There is no such thing in Python, but it's easy enough to write code that works that way.\n", "\n", "We create an infinite loop and test the condition inside the loop and break out of the loop when the condition becomes false:"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["5\n"]}], "source": [" i = 5\n", "\n", "while True:\n", "    print(i)\n", "    if i >= 5:\n", "        break\n"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see the loop executed once (and will always execute at least once, no matter the starting value of i.)\n", "\n", "This is a standard pattern and can be useful in a variety of scenarios.\n", "\n", "A simple example might be getting repetitive user input until the user performs and action or provides some specific value."]}, {"cell_type": "raw", "metadata": {}, "source": ["For example, suppose we want to use the console to let users enter their name. We just want to make sure their name is at least 2 characters long, contains printable characters only, and only contains alphabetic characters:"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We might try it this way:"]}, {"cell_type": "code", "execution_count": 17, "metadata": {"scrolled": true}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Please enter your name:a123\n", "Please enter your name:a\n", "Please enter your name:fred\n", "Hello, fred\n"]}], "source": ["min_length = 2\n", "\n", "name = input('Please enter your name:')\n", "\n", "while not(len(name) >= min_length  and name.isprintable() and name.isalpha()):\n", "    name = input('Please enter your name:')\n", "\n", "print('Hello, {0}'.format(name))\n"]}, {"cell_type": "markdown", "metadata": {}, "source": ["This works just fine, but notice that we had to write the code to elicit user input **twice** in our code. This is not good practice, and we can easily clean this up as follows:"]}, {"cell_type": "code", "execution_count": 18, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Please enter your name:a\n", "Please enter your name:123\n", "Please enter your name:fred\n", "Hello, fred\n"]}], "source": ["min_length = 2\n", "\n", "while True:\n", "    name = input('Please enter your name:')\n", "    if len(name) >= min_length  and name.isprintable() and name.isalpha():\n", "        break\n", "\n", "print('Hello, {0}'.format(name))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We saw how the **break** statement exits the **while** loop and execution resumes on the line immediately after the while code block.\n", "\n", "Sometimes, we just want to cut the current iteration short, but continue looping, without exiting the loop itself.\n", "\n", "This is done using the **continue** statement:"]}, {"cell_type": "code", "execution_count": 21, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["2\n", "4\n", "6\n", "8\n", "10\n"]}], "source": ["a = 0\n", "while a < 10:\n", "    a += 1\n", "    if a % 2:\n", "        continue\n", "    print(a)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Note that there are much better ways of doing this! We'll cover that in later videos (comprehensions, generators, etc)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The **while** loop also can be used with an **else** clause!!"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The **else** is executed if the while loop terminated without hitting a **break** statement (we say the loop terminated **normally**)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Suppose we want to test if some value is present in some list, and if not we want to append it to the list (again there are better ways of doing this):"]}, {"cell_type": "markdown", "metadata": {}, "source": ["First, here's how we might do it without the benefit of the **else** clause:"]}, {"cell_type": "code", "execution_count": 26, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["[1, 2, 3, 10]\n"]}], "source": ["l = [1, 2, 3]\n", "val = 10\n", "\n", "found = False\n", "idx = 0\n", "while idx < len(l):\n", "    if l[idx] == val:\n", "        found = True\n", "        break\n", "    idx += 1\n", "    \n", "if not found:\n", "    l.append(val)\n", "print(l)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Using the **else** clause is easier:"]}, {"cell_type": "code", "execution_count": 28, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["[1, 2, 3, 10]\n"]}], "source": ["l = [1, 2, 3]\n", "val = 10\n", "\n", "idx = 0\n", "while idx < len(l):\n", "    if l[idx] == val:\n", "        break\n", "    idx += 1\n", "else:\n", "    l.append(val)\n", "\n", "print(l)"]}, {"cell_type": "code", "execution_count": 30, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["[1, 2, 3]\n"]}], "source": ["l = [1, 2, 3]\n", "val = 3\n", "\n", "idx = 0\n", "while idx < len(l):\n", "    if l[idx] == val:\n", "        break\n", "    idx += 1\n", "else:\n", "    l.append(val)\n", "\n", "print(l)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Loop Break and Continue inside a Try...Except...Finally"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Recall that in a ``try`` statement, the ``finally`` clause always runs:"]}, {"cell_type": "code", "execution_count": 33, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["this always executes\n"]}], "source": ["a = 10\n", "b = 1\n", "try:\n", "    a / b\n", "except ZeroDivisionError:\n", "    print('division by 0')\n", "finally:\n", "    print('this always executes')"]}, {"cell_type": "code", "execution_count": 34, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["division by 0\n", "this always executes\n"]}], "source": ["a = 10\n", "b = 0\n", "try:\n", "    a / b\n", "except ZeroDivisionError:\n", "    print('division by 0')\n", "finally:\n", "    print('this always executes')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["So, what happens when using a ``try`` statement within a ``while`` loop, and a ``continue`` or ``break`` statement is encountered?"]}, {"cell_type": "code", "execution_count": 47, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["-------------\n", "1, 1 - always executes\n", "1, 1 - main loop\n", "-------------\n", "2, 0 - division by 0\n", "2, 0 - always executes\n", "-------------\n", "3, -1 - always executes\n", "3, -1 - main loop\n"]}], "source": ["a = 0\n", "b = 2\n", "\n", "while a < 3:\n", "    print('-------------')\n", "    a += 1\n", "    b -= 1\n", "    try:\n", "        res = a / b\n", "    except ZeroDivisionError:\n", "        print('{0}, {1} - division by 0'.format(a, b))\n", "        res = 0\n", "        continue\n", "    finally:\n", "        print('{0}, {1} - always executes'.format(a, b))\n", "        \n", "    print('{0}, {1} - main loop'.format(a, b))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see in the above result, the ``finally`` code still executed, even though the current iteration was cut short with the ``continue`` statement. "]}, {"cell_type": "markdown", "metadata": {}, "source": ["This works the same with a ``break`` statement:"]}, {"cell_type": "code", "execution_count": 50, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["-------------\n", "1, 1 - always executes\n", "1, 1 - main loop\n", "-------------\n", "2, 0 - division by 0\n", "2, 0 - always executes\n"]}], "source": ["a = 0\n", "b = 2\n", "\n", "while a < 3:\n", "    print('-------------')\n", "    a += 1\n", "    b -= 1\n", "    try:\n", "        res = a / b\n", "    except ZeroDivisionError:\n", "        print('{0}, {1} - division by 0'.format(a, b))\n", "        res = 0\n", "        break\n", "    finally:\n", "        print('{0}, {1} - always executes'.format(a, b))\n", "        \n", "    print('{0}, {1} - main loop'.format(a, b))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can even combine all this with the ``else`` clause:"]}, {"cell_type": "code", "execution_count": 54, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["-------------\n", "1, 1 - always executes\n", "1, 1 - main loop\n", "-------------\n", "2, 0 - division by 0\n", "2, 0 - always executes\n"]}], "source": ["a = 0\n", "b = 2\n", "\n", "while a < 3:\n", "    print('-------------')\n", "    a += 1\n", "    b -= 1\n", "    try:\n", "        res = a / b\n", "    except ZeroDivisionError:\n", "        print('{0}, {1} - division by 0'.format(a, b))\n", "        res = 0\n", "        break\n", "    finally:\n", "        print('{0}, {1} - always executes'.format(a, b))\n", "        \n", "    print('{0}, {1} - main loop'.format(a, b))\n", "else:\n", "    print('\\n\\nno errors were encountered!')"]}, {"cell_type": "code", "execution_count": 55, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["-------------\n", "1, 4 - always executes\n", "1, 4 - main loop\n", "-------------\n", "2, 3 - always executes\n", "2, 3 - main loop\n", "-------------\n", "3, 2 - always executes\n", "3, 2 - main loop\n", "\n", "\n", "no errors were encountered!\n"]}], "source": ["a = 0\n", "b = 5\n", "\n", "while a < 3:\n", "    print('-------------')\n", "    a += 1\n", "    b -= 1\n", "    try:\n", "        res = a / b\n", "    except ZeroDivisionError:\n", "        print('{0}, {1} - division by 0'.format(a, b))\n", "        res = 0\n", "        break\n", "    finally:\n", "        print('{0}, {1} - always executes'.format(a, b))\n", "        \n", "    print('{0}, {1} - main loop'.format(a, b))\n", "else:\n", "    print('\\n\\nno errors were encountered!')"]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": []}, {"cell_type": "markdown", "metadata": {}, "source": ["### The For Loop"]}, {"cell_type": "markdown", "metadata": {}, "source": ["In Python, an **iterable** is an **object** capable of returning values one at a time.\n", "\n", "Many objects in Python are iterable: lists, strings, file objects and many more."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Note: Our definition of an iterable did not state it was a collection of values - we only said it is an object that can return values one at a time - that's a subtle difference that we'll examine when we look into iterators and generators."]}, {"cell_type": "markdown", "metadata": {}, "source": ["The **for** keyword can be used to iterate an iterable."]}, {"cell_type": "markdown", "metadata": {}, "source": ["If you come with a background in another programming language, you have probably seen **for** loops defined this way:\n", "\n", "``for (int i=0; i < 5; i++) {\n", "    //code block\n", "}``"]}, {"cell_type": "markdown", "metadata": {}, "source": ["This form of the **for** loop is simply a _repetition_, very similar to a **while** loop - in fact it is equivalent to what we could write in Python as follows:"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["0\n", "1\n", "2\n", "3\n", "4\n"]}], "source": ["i = 0\n", "while i < 5:\n", "    #code block\n", "    print(i)\n", "    i += 1\n", "i = None"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But that's **NOT** what the **for** statement does in Python - the **for** statement is a way to **iterate** over iterables, and has nothing to do with the **for** loop we just saw. The closest equivalent we have in Python is the **while** loop written as above."]}, {"cell_type": "markdown", "metadata": {}, "source": ["To use the **for** loop in Python, we **require** an iterable object to work with."]}, {"cell_type": "markdown", "metadata": {}, "source": ["A simple iterable object is generated via the ``range()`` function"]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["0\n", "1\n", "2\n", "3\n", "4\n"]}], "source": ["for i in range(5):\n", "    print(i)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Many objects are iterable in Python:"]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1\n", "2\n", "3\n"]}], "source": ["for x in [1, 2, 3]:\n", "    print(x)"]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["h\n", "e\n", "l\n", "l\n", "o\n"]}], "source": ["for x in 'hello':\n", "    print(x)"]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["a\n", "b\n", "c\n"]}], "source": ["for x in ('a', 'b', 'c'):\n", "    print(x)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["When we iterate over an iterable, each iteration returns the \"next\" value (or object) in the iterable:"]}, {"cell_type": "code", "execution_count": 8, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["(1, 2)\n", "(3, 4)\n", "(5, 6)\n"]}], "source": ["for x in [(1, 2), (3, 4), (5, 6)]:\n", "    print(x)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can even assign the individual tuple values to specific named variables:"]}, {"cell_type": "code", "execution_count": 9, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1 2\n", "3 4\n", "5 6\n"]}], "source": ["for i, j in [(1, 2), (3, 4), (5, 6)]:\n", "    print(i, j)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We will cover iterables in a lot more detail later in this course."]}, {"cell_type": "markdown", "metadata": {}, "source": ["The **break** and **continue** statements work just as well in **for** loops as they do in **while** loops:"]}, {"cell_type": "code", "execution_count": 10, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["0\n", "1\n", "2\n", "4\n"]}], "source": ["for i in range(5):\n", "    if i == 3:\n", "        continue\n", "    print(i)"]}, {"cell_type": "code", "execution_count": 11, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["0\n", "1\n", "2\n"]}], "source": ["for i in range(5):\n", "    if i == 3:\n", "        break\n", "    print(i)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The **for** loop, like the **while** loop, also supports an **else** clause which is executed if and only if the loop terminates normally (i.e. did not exit because of a **break** statement)"]}, {"cell_type": "code", "execution_count": 17, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1\n", "2\n", "3\n", "4\n", "No multiples of 7 encountered\n"]}], "source": ["for i in range(1, 5):\n", "    print(i)\n", "    if i % 7 == 0:\n", "        print('multiple of 7 found')\n", "        break\n", "else:\n", "    print('No multiples of 7 encountered')"]}, {"cell_type": "code", "execution_count": 18, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1\n", "2\n", "3\n", "4\n", "5\n", "6\n", "7\n", "multiple of 7 found\n"]}], "source": ["for i in range(1, 8):\n", "    print(i)\n", "    if i % 7 == 0:\n", "        print('multiple of 7 found')\n", "        break\n", "else:\n", "    print('No multiples of 7 encountered')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Similarly to the **while** loop, **break** and **continue** work just the same in the context of a **try** statement's **finally** clause."]}, {"cell_type": "code", "execution_count": 14, "metadata": {"scrolled": true}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["--------------------\n", "always runs\n", "0\n", "--------------------\n", "always runs\n", "1\n", "--------------------\n", "always runs\n", "2\n", "--------------------\n", "divided by 0\n", "always runs\n", "--------------------\n", "always runs\n", "4\n"]}], "source": ["for i in range(5):\n", "    print('--------------------')\n", "    try:\n", "        10 / (i - 3)\n", "    except ZeroDivisionError:\n", "        print('divided by 0')\n", "        continue\n", "    finally:\n", "        print('always runs')\n", "    print(i)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["There are a number of standard techniques to iterate over iterables:"]}, {"cell_type": "code", "execution_count": 24, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["h\n", "e\n", "l\n", "l\n", "o\n"]}], "source": ["s = 'hello'\n", "for c in s:\n", "    print(c)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But sometimes, for indexable iterable types (e.g. sequences), we want to also know the index of the item in the loop:"]}, {"cell_type": "code", "execution_count": 23, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["0 h\n", "1 e\n", "2 l\n", "3 l\n", "4 o\n"]}], "source": ["s = 'hello'\n", "i = 0\n", "for c in s:\n", "    print(i, c)\n", "    i += 1"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Slightly better approach might be:"]}, {"cell_type": "code", "execution_count": 27, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["0 h\n", "1 e\n", "2 l\n", "3 l\n", "4 o\n"]}], "source": ["s = 'hello'\n", "\n", "for i in range(len(s)):\n", "    print(i, s[i])\n"]}, {"cell_type": "markdown", "metadata": {}, "source": ["or even better:"]}, {"cell_type": "code", "execution_count": 28, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["0 h\n", "1 e\n", "2 l\n", "3 l\n", "4 o\n"]}], "source": ["s = 'hello'\n", "\n", "for i, c in enumerate(s):\n", "    print(i, c)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We'll come back to all these iteration techniques in a lot more detail throughout this course."]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Custom Classes"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We'll cover classes in a lot of detail in this course, but for now you should have at least some understanding of classes in Python and how to create them."]}, {"cell_type": "markdown", "metadata": {}, "source": ["To create a custom class we use the `class` keyword, and we can initialize class attributes in the special method `__init__`."]}, {"cell_type": "code", "execution_count": 1, "metadata": {"collapsed": true}, "outputs": [], "source": ["class Rectangle:\n", "    def __init__(self, width, height):\n", "        self.width = width\n", "        self.height = height"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We create **instances** of the `Rectangle` class by calling it with arguments that are passed to the `__init__` method as the second and third arguments. The first argument (`self`) is automatically filled in by Python and contains the object being created.\n", "\n", "Note that using `self` is just a convention (although a good one, and you shgoudl use it to make your code more understandable by others), you could really call it whatever (valid) name you choose.\n", "\n", "But just because you can does not mean you should!"]}, {"cell_type": "code", "execution_count": 2, "metadata": {"collapsed": true}, "outputs": [], "source": ["r1 = Rectangle(10, 20)\n", "r2 = Rectangle(3, 5)"]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [{"data": {"text/plain": ["10"]}, "execution_count": 3, "metadata": {}, "output_type": "execute_result"}], "source": ["r1.width"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"data": {"text/plain": ["5"]}, "execution_count": 4, "metadata": {}, "output_type": "execute_result"}], "source": ["r2.height"]}, {"cell_type": "markdown", "metadata": {}, "source": ["`width` and `height` are attributes of the `Rectangle` class. But since they are just values (not callables), we call them **properties**.\n", "\n", "Attributes that are callables are called **methods**."]}, {"cell_type": "markdown", "metadata": {}, "source": ["You'll note that we were able to retrieve the `width` and `height` attributes (properties) using a dot notation, where we specify the object we are interested in, then a dot, then the attribute we are interested in."]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can add callable attributes to our class (methods), that will also be referenced using the dot notation.\n", "\n", "Again, we will create instance methods, which means the method will require the first argument to be the object being used when the method is called."]}, {"cell_type": "code", "execution_count": 5, "metadata": {"collapsed": true}, "outputs": [], "source": ["class Rectangle:\n", "    def __init__(self, width, height):\n", "        self.width = width\n", "        self.height = height\n", "        \n", "    def area(self):\n", "        return self.width * self.height\n", "    \n", "    def perimeter(the_referenced_object):\n", "        return 2 * (the_referenced_object.width + the_referenced_object.height)"]}, {"cell_type": "code", "execution_count": 6, "metadata": {"collapsed": true}, "outputs": [], "source": ["r1 = Rectangle(10, 20)"]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"data": {"text/plain": ["200"]}, "execution_count": 7, "metadata": {}, "output_type": "execute_result"}], "source": ["r1.area()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["When we ran the above line of code, our object was `r1`, so when `area` was called, Python in fact called the method `area` in the Rectangle class automatically passing `r1` to the `self` parameter."]}, {"cell_type": "markdown", "metadata": {}, "source": ["This is why we can use a name other than self, such as in the perimeter method:"]}, {"cell_type": "code", "execution_count": 8, "metadata": {}, "outputs": [{"data": {"text/plain": ["60"]}, "execution_count": 8, "metadata": {}, "output_type": "execute_result"}], "source": ["r1.perimeter()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Again, I'm just illustrating a point, don't actually do that!"]}, {"cell_type": "code", "execution_count": 9, "metadata": {"collapsed": true}, "outputs": [], "source": ["class Rectangle:\n", "    def __init__(self, width, height):\n", "        self.width = width\n", "        self.height = height\n", "        \n", "    def area(self):\n", "        return self.width * self.height\n", "    \n", "    def perimeter(self):\n", "        return 2 * (self.width + self.height)"]}, {"cell_type": "code", "execution_count": 10, "metadata": {"collapsed": true}, "outputs": [], "source": ["r1 = Rectangle(10, 20)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Python defines a bunch of **special** methods that we can use to give our classes functionality that resembles functionality of built-in and standard library objects.\n", "\n", "Many people refer to them as *magic* methods, but there's nothing magical about them - unlike magic, they are well documented and understood!!\n", "\n", "These **special** methods provide us an easy way to overload operators in Python."]}, {"cell_type": "markdown", "metadata": {}, "source": ["For example, we can obtain the string representation of an integer using the built-in `str` function:"]}, {"cell_type": "code", "execution_count": 11, "metadata": {}, "outputs": [{"data": {"text/plain": ["'10'"]}, "execution_count": 11, "metadata": {}, "output_type": "execute_result"}], "source": ["str(10)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["What happens if we try this with our Rectangle object?"]}, {"cell_type": "code", "execution_count": 12, "metadata": {}, "outputs": [{"data": {"text/plain": ["'<__main__.Rectangle object at 0x000002375E7006A0>'"]}, "execution_count": 12, "metadata": {}, "output_type": "execute_result"}], "source": ["str(r1)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Not exactly what we might have expected. On the other hand, how is Python supposed to know how to display our rectangle as a string?\n", "\n", "We could write a method in the class such as:"]}, {"cell_type": "code", "execution_count": 13, "metadata": {"collapsed": true}, "outputs": [], "source": ["class Rectangle:\n", "    def __init__(self, width, height):\n", "        self.width = width\n", "        self.height = height\n", "        \n", "    def area(self):\n", "        return self.width * self.height\n", "    \n", "    def perimeter(self):\n", "        return 2 * (self.width + self.height)\n", "    \n", "    def to_str(self):\n", "        return 'Rectangle (width={0}, height={1})'.format(self.width, self.height)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["So now we could get a string from our object as follows:"]}, {"cell_type": "code", "execution_count": 14, "metadata": {}, "outputs": [{"data": {"text/plain": ["'Rectangle (width=10, height=20)'"]}, "execution_count": 14, "metadata": {}, "output_type": "execute_result"}], "source": ["r1 = Rectangle(10, 20)\n", "r1.to_str()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But of course, using the built-in `str` function still does not work:"]}, {"cell_type": "code", "execution_count": 15, "metadata": {}, "outputs": [{"data": {"text/plain": ["'<__main__.Rectangle object at 0x000002375E708DA0>'"]}, "execution_count": 15, "metadata": {}, "output_type": "execute_result"}], "source": ["str(r1)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Does this mean we are out of luck, and anyone who writes a class in Python will need to provide some method to do this, and probably come up with their own name for the method too, maybe `to_str`, `make_string`, `stringify`, and who knows what else."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Fortunately, this is where these special methods come in. When we call `str(r1)`, Python will first look to see if our class (`Rectangle`) has a special method called `__str__`.\n", "\n", "If the `__str__` method is present, then Python will call it and return that value.\n", "\n", "There's actually another one called `__repr__` which is related, but we'll just focus on `__str__` for now."]}, {"cell_type": "code", "execution_count": 16, "metadata": {"collapsed": true}, "outputs": [], "source": ["class Rectangle:\n", "    def __init__(self, width, height):\n", "        self.width = width\n", "        self.height = height\n", "        \n", "    def area(self):\n", "        return self.width * self.height\n", "    \n", "    def perimeter(self):\n", "        return 2 * (self.width + self.height)\n", "    \n", "    def __str__(self):\n", "        return 'Rectangle (width={0}, height={1})'.format(self.width, self.height)"]}, {"cell_type": "code", "execution_count": 17, "metadata": {"collapsed": true}, "outputs": [], "source": ["r1 = Rectangle(10, 20)"]}, {"cell_type": "code", "execution_count": 18, "metadata": {}, "outputs": [{"data": {"text/plain": ["'Rectangle (width=10, height=20)'"]}, "execution_count": 18, "metadata": {}, "output_type": "execute_result"}], "source": ["str(r1)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["However, in Jupyter (and interactive console if you are using that), look what happens here:"]}, {"cell_type": "code", "execution_count": 19, "metadata": {}, "outputs": [{"data": {"text/plain": ["<__main__.Rectangle at 0x2375e716ef0>"]}, "execution_count": 19, "metadata": {}, "output_type": "execute_result"}], "source": ["r1"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see we still get that default. That's because here Python is not converting `r1` to a string, but instead looking for a string *representation* of the object. It is looking for the `__repr__` method (which we'll come back to later)."]}, {"cell_type": "code", "execution_count": 20, "metadata": {"collapsed": true}, "outputs": [], "source": ["class Rectangle:\n", "    def __init__(self, width, height):\n", "        self.width = width\n", "        self.height = height\n", "        \n", "    def area(self):\n", "        return self.width * self.height\n", "    \n", "    def perimeter(self):\n", "        return 2 * (self.width + self.height)\n", "    \n", "    def __str__(self):\n", "        return 'Rectangle (width={0}, height={1})'.format(self.width, self.height)\n", "    \n", "    def __repr__(self):\n", "        return 'Rectangle({0}, {1})'.format(self.width, self.height)"]}, {"cell_type": "code", "execution_count": 21, "metadata": {"collapsed": true}, "outputs": [], "source": ["r1 = Rectangle(10, 20)"]}, {"cell_type": "code", "execution_count": 22, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Rectangle (width=10, height=20)\n"]}], "source": ["print(r1)  # uses __str__"]}, {"cell_type": "code", "execution_count": 23, "metadata": {}, "outputs": [{"data": {"text/plain": ["Rectangle(10, 20)"]}, "execution_count": 23, "metadata": {}, "output_type": "execute_result"}], "source": ["r1  # uses __repr__"]}, {"cell_type": "markdown", "metadata": {}, "source": ["How about the comparison operators, such as `==` or `<`?"]}, {"cell_type": "code", "execution_count": 24, "metadata": {"collapsed": true}, "outputs": [], "source": ["r1 = Rectangle(10, 20)\n", "r2 = Rectangle(10, 20)"]}, {"cell_type": "code", "execution_count": 25, "metadata": {}, "outputs": [{"data": {"text/plain": ["False"]}, "execution_count": 25, "metadata": {}, "output_type": "execute_result"}], "source": ["r1 == r2"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see, Python does not consider `r1` and `r2` as equal (using the `==` operator). Again, how is Python supposed to know that two Rectangle objects with the same height and width should be considered equal?"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We just need to tell Python how to do it, using the special method `__eq__`."]}, {"cell_type": "code", "execution_count": 40, "metadata": {"collapsed": true}, "outputs": [], "source": ["class Rectangle:\n", "    def __init__(self, width, height):\n", "        self.width = width\n", "        self.height = height\n", "        \n", "    def area(self):\n", "        return self.width * self.height\n", "    \n", "    def perimeter(self):\n", "        return 2 * (self.width + self.height)\n", "    \n", "    def __str__(self):\n", "        return 'Rectangle (width={0}, height={1})'.format(self.width, self.height)\n", "    \n", "    def __repr__(self):\n", "        return 'Rectangle({0}, {1})'.format(self.width, self.height)\n", "    \n", "    def __eq__(self, other):\n", "        print('self={0}, other={1}'.format(self, other))\n", "        if isinstance(other, Rectangle):\n", "            return (self.width, self.height) == (other.width, other.height)\n", "        else:\n", "            return False"]}, {"cell_type": "code", "execution_count": 41, "metadata": {"collapsed": true}, "outputs": [], "source": ["r1 = Rectangle(10, 20)\n", "r2 = Rectangle(10, 20)"]}, {"cell_type": "code", "execution_count": 42, "metadata": {}, "outputs": [{"data": {"text/plain": ["False"]}, "execution_count": 42, "metadata": {}, "output_type": "execute_result"}], "source": ["r1 is r2"]}, {"cell_type": "code", "execution_count": 43, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["self=Rectangle (width=10, height=20), other=Rectangle (width=10, height=20)\n"]}, {"data": {"text/plain": ["True"]}, "execution_count": 43, "metadata": {}, "output_type": "execute_result"}], "source": ["r1 == r2"]}, {"cell_type": "code", "execution_count": 44, "metadata": {"collapsed": true}, "outputs": [], "source": ["r3 = Rectangle(2, 3)"]}, {"cell_type": "code", "execution_count": 45, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["self=Rectangle (width=10, height=20), other=Rectangle (width=2, height=3)\n"]}, {"data": {"text/plain": ["False"]}, "execution_count": 45, "metadata": {}, "output_type": "execute_result"}], "source": ["r1 == r3"]}, {"cell_type": "markdown", "metadata": {}, "source": ["And if we try to compare our Rectangle to a different type:"]}, {"cell_type": "code", "execution_count": 46, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["self=Rectangle (width=10, height=20), other=100\n"]}, {"data": {"text/plain": ["False"]}, "execution_count": 46, "metadata": {}, "output_type": "execute_result"}], "source": ["r1 == 100"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's remove that print statement - I only put that in so you could see what the arguments were, in practice you should avoid side effects."]}, {"cell_type": "code", "execution_count": 47, "metadata": {"collapsed": true}, "outputs": [], "source": ["class Rectangle:\n", "    def __init__(self, width, height):\n", "        self.width = width\n", "        self.height = height\n", "        \n", "    def area(self):\n", "        return self.width * self.height\n", "    \n", "    def perimeter(self):\n", "        return 2 * (self.width + self.height)\n", "    \n", "    def __str__(self):\n", "        return 'Rectangle (width={0}, height={1})'.format(self.width, self.height)\n", "    \n", "    def __repr__(self):\n", "        return 'Rectangle({0}, {1})'.format(self.width, self.height)\n", "    \n", "    def __eq__(self, other):\n", "        if isinstance(other, Rectangle):\n", "            return (self.width, self.height) == (other.width, other.height)\n", "        else:\n", "            return False"]}, {"cell_type": "markdown", "metadata": {}, "source": ["What about `<`, `>`, `<=`, etc.?\n", "\n", "Again, Python has special methods we can use to provide that functionality.\n", "\n", "These are methods such as `__lt__`, `__gt__`, `__le__`, etc."]}, {"cell_type": "code", "execution_count": 48, "metadata": {"collapsed": true}, "outputs": [], "source": ["class Rectangle:\n", "    def __init__(self, width, height):\n", "        self.width = width\n", "        self.height = height\n", "        \n", "    def area(self):\n", "        return self.width * self.height\n", "    \n", "    def perimeter(self):\n", "        return 2 * (self.width + self.height)\n", "    \n", "    def __str__(self):\n", "        return 'Rectangle (width={0}, height={1})'.format(self.width, self.height)\n", "    \n", "    def __repr__(self):\n", "        return 'Rectangle({0}, {1})'.format(self.width, self.height)\n", "    \n", "    def __eq__(self, other):\n", "        if isinstance(other, Rectangle):\n", "            return (self.width, self.height) == (other.width, other.height)\n", "        else:\n", "            return False\n", "    \n", "    def __lt__(self, other):\n", "        if isinstance(other, Rectangle):\n", "            return self.area() < other.area()\n", "        else:\n", "            return NotImplemented"]}, {"cell_type": "code", "execution_count": 49, "metadata": {"collapsed": true}, "outputs": [], "source": ["r1 = Rectangle(100, 200)\n", "r2 = Rectangle(10, 20)"]}, {"cell_type": "code", "execution_count": 50, "metadata": {}, "outputs": [{"data": {"text/plain": ["False"]}, "execution_count": 50, "metadata": {}, "output_type": "execute_result"}], "source": ["r1 < r2"]}, {"cell_type": "code", "execution_count": 51, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 51, "metadata": {}, "output_type": "execute_result"}], "source": ["r2 < r1"]}, {"cell_type": "markdown", "metadata": {}, "source": ["What about `>`?"]}, {"cell_type": "code", "execution_count": 52, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 52, "metadata": {}, "output_type": "execute_result"}], "source": ["r1 > r2"]}, {"cell_type": "markdown", "metadata": {}, "source": ["How did that work? We did not define a `__gt__` method.\n", "\n", "Well, Python cleverly decided that since `r1 > r2` was not implemented, it would give \n", "\n", "`r2 < r1` \n", "\n", "a try. And since, `__lt__` **is** defined, it worked!"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Of course, `<=` is not going to magically work!"]}, {"cell_type": "code", "execution_count": 53, "metadata": {}, "outputs": [{"ename": "TypeError", "evalue": "'<=' not supported between instances of 'Rectangle' and 'Rectangle'", "output_type": "error", "traceback": ["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[1;31mTypeError\u001b[0m                                 Traceback (most recent call last)", "\u001b[1;32m<ipython-input-53-beabec6419b6>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[1;32m----> 1\u001b[1;33m \u001b[0mr1\u001b[0m \u001b[1;33m<=\u001b[0m \u001b[0mr2\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m", "\u001b[1;31mTypeError\u001b[0m: '<=' not supported between instances of 'Rectangle' and 'Rectangle'"]}], "source": ["r1 <= r2"]}, {"cell_type": "markdown", "metadata": {}, "source": ["If you come from a Java background, you are probably thinking that using \"bare\" properties (direct access), such as `height` and `width` is a terrible design idea.\n", "\n", "It is for Java, but not for Python.\n", "\n", "Although you can use bare properties in Java, if you ever need to intercept the getting or setting of a property, you will need to write a method (such as `getWidth` and `setWidth`. The problem is that if you used a bare `width` property for example, a lot of your code might be using `obj.width` (as we have been doing here). The instant you make the `width` private and instead implement getters and setters, you break your code.\n", "Hence one of the reasons why in Java we just write getters and setters for properties from the beginning.\n", "\n", "With Python this is not the case - we can change any bare property into getters and setters without breaking the code that uses that bare property.\n", "\n", "I'll show you a quick example here, but we'll come back to this topic in much more detail later."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's take our Rectangle class once again. I'll use a simplified version to keep the code short."]}, {"cell_type": "code", "execution_count": 54, "metadata": {"collapsed": true}, "outputs": [], "source": ["class Rectangle:\n", "    def __init__(self, width, height):\n", "        self.width = width\n", "        self.height = height\n", "    \n", "    def __repr__(self):\n", "        return 'Rectangle({0}, {1})'.format(self.width, self.height)"]}, {"cell_type": "code", "execution_count": 55, "metadata": {"collapsed": true}, "outputs": [], "source": ["r1 = Rectangle(10, 20)"]}, {"cell_type": "code", "execution_count": 56, "metadata": {}, "outputs": [{"data": {"text/plain": ["10"]}, "execution_count": 56, "metadata": {}, "output_type": "execute_result"}], "source": ["r1.width"]}, {"cell_type": "code", "execution_count": 57, "metadata": {"collapsed": true}, "outputs": [], "source": ["r1.width = 100"]}, {"cell_type": "code", "execution_count": 58, "metadata": {}, "outputs": [{"data": {"text/plain": ["Rectangle(100, 20)"]}, "execution_count": 58, "metadata": {}, "output_type": "execute_result"}], "source": ["r1"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you saw we can *get* and *set* the `width` property directly.\n", "\n", "But let's say after this code has been released for a while and users of our class have been using it (and specifically setting and getting the `width` and `height` attribute a lot), but now we want to make sure users cannot set a non-positive value (i.e. <= 0) for width (or height, but we'll focus on width as an example)."]}, {"cell_type": "markdown", "metadata": {}, "source": ["In a language like Java, we would implement `getWidth` and `setWidth` and make `width` private - which would break any code directly accessing the `width` property."]}, {"cell_type": "markdown", "metadata": {}, "source": ["In Python we can use some special **decorators** (more on those later) to encapsulate our property getters and setters:"]}, {"cell_type": "code", "execution_count": 59, "metadata": {"collapsed": true}, "outputs": [], "source": ["class Rectangle:\n", "    def __init__(self, width, height):\n", "        self._width = width\n", "        self._height = height\n", "    \n", "    def __repr__(self):\n", "        return 'Rectangle({0}, {1})'.format(self.width, self.height)\n", "    \n", "    @property\n", "    def width(self):\n", "        return self._width\n", "    \n", "    @width.setter\n", "    def width(self, width):\n", "        if width <= 0:\n", "            raise ValueError('Width must be positive.')\n", "        self._width = width\n", "    \n", "    @property\n", "    def height(self):\n", "        return self._height\n", "    \n", "    @height.setter\n", "    def height(self, height):\n", "        if height <= 0:\n", "            raise ValueError('Height must be positive.')\n", "        self._height = height"]}, {"cell_type": "code", "execution_count": 60, "metadata": {"collapsed": true}, "outputs": [], "source": ["r1 = Rectangle(10, 20)"]}, {"cell_type": "code", "execution_count": 61, "metadata": {}, "outputs": [{"data": {"text/plain": ["10"]}, "execution_count": 61, "metadata": {}, "output_type": "execute_result"}], "source": ["r1.width"]}, {"cell_type": "code", "execution_count": 62, "metadata": {"collapsed": true}, "outputs": [], "source": ["r1.width = 100"]}, {"cell_type": "code", "execution_count": 63, "metadata": {}, "outputs": [{"data": {"text/plain": ["Rectangle(100, 20)"]}, "execution_count": 63, "metadata": {}, "output_type": "execute_result"}], "source": ["r1"]}, {"cell_type": "code", "execution_count": 64, "metadata": {}, "outputs": [{"ename": "ValueError", "evalue": "Width must be positive.", "output_type": "error", "traceback": ["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[1;31mValueError\u001b[0m                                Traceback (most recent call last)", "\u001b[1;32m<ipython-input-64-5813452c3f38>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[1;32m----> 1\u001b[1;33m \u001b[0mr1\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mwidth\u001b[0m \u001b[1;33m=\u001b[0m \u001b[1;33m-\u001b[0m\u001b[1;36m10\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m", "\u001b[1;32m<ipython-input-59-f23b29795658>\u001b[0m in \u001b[0;36mwidth\u001b[1;34m(self, width)\u001b[0m\n\u001b[0;32m     14\u001b[0m     \u001b[1;32mdef\u001b[0m \u001b[0mwidth\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mself\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mwidth\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m     15\u001b[0m         \u001b[1;32mif\u001b[0m \u001b[0mwidth\u001b[0m \u001b[1;33m<=\u001b[0m \u001b[1;36m0\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m---> 16\u001b[1;33m             \u001b[1;32mraise\u001b[0m \u001b[0mValueError\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34m'Width must be positive.'\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m     17\u001b[0m         \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0m_width\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mwidth\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m     18\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n", "\u001b[1;31mValueError\u001b[0m: Width must be positive."]}], "source": ["r1.width = -10"]}, {"cell_type": "markdown", "metadata": {}, "source": ["There are more things we should do to properly implement all this, in particular we should also be checking the positive and negative values during the `__init__` phase. We do so by using the accessor methods for height and width:"]}, {"cell_type": "code", "execution_count": 65, "metadata": {"collapsed": true}, "outputs": [], "source": ["class Rectangle:\n", "    def __init__(self, width, height):\n", "        self._width = None\n", "        self._height = None\n", "        # now we call our accessor methods to set the width and height\n", "        self.width = width\n", "        self.height = height\n", "    \n", "    def __repr__(self):\n", "        return 'Rectangle({0}, {1})'.format(self.width, self.height)\n", "    \n", "    @property\n", "    def width(self):\n", "        return self._width\n", "    \n", "    @width.setter\n", "    def width(self, width):\n", "        if width <= 0:\n", "            raise ValueError('Width must be positive.')\n", "        self._width = width\n", "    \n", "    @property\n", "    def height(self):\n", "        return self._height\n", "    \n", "    @height.setter\n", "    def height(self, height):\n", "        if height <= 0:\n", "            raise ValueError('Height must be positive.')\n", "        self._height = height"]}, {"cell_type": "code", "execution_count": 66, "metadata": {}, "outputs": [{"ename": "ValueError", "evalue": "Width must be positive.", "output_type": "error", "traceback": ["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[1;31mValueError\u001b[0m                                Traceback (most recent call last)", "\u001b[1;32m<ipython-input-66-b60d030826a5>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[1;32m----> 1\u001b[1;33m \u001b[0mr1\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mRectangle\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;36m0\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;36m10\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m", "\u001b[1;32m<ipython-input-65-4c1b43452381>\u001b[0m in \u001b[0;36m__init__\u001b[1;34m(self, width, height)\u001b[0m\n\u001b[0;32m      4\u001b[0m         \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0m_height\u001b[0m \u001b[1;33m=\u001b[0m \u001b[1;32mNone\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m      5\u001b[0m         \u001b[1;31m# now we call our accessor methods to set the width and height\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m----> 6\u001b[1;33m         \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mwidth\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mwidth\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m      7\u001b[0m         \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mheight\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mheight\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m      8\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n", "\u001b[1;32m<ipython-input-65-4c1b43452381>\u001b[0m in \u001b[0;36mwidth\u001b[1;34m(self, width)\u001b[0m\n\u001b[0;32m     17\u001b[0m     \u001b[1;32mdef\u001b[0m \u001b[0mwidth\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mself\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mwidth\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m     18\u001b[0m         \u001b[1;32mif\u001b[0m \u001b[0mwidth\u001b[0m \u001b[1;33m<=\u001b[0m \u001b[1;36m0\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m---> 19\u001b[1;33m             \u001b[1;32mraise\u001b[0m \u001b[0mValueError\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34m'Width must be positive.'\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m     20\u001b[0m         \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0m_width\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mwidth\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m     21\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n", "\u001b[1;31mValueError\u001b[0m: Width must be positive."]}], "source": ["r1 = Rectangle(0, 10)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["There more we should be doing, like checking that the width and height being passed in are numeric types, and so on. Especially during the `__init__` phase - we would rather raise an exception when the object is being created rather than delay things and raise an exception when the user calls some method like `area` - that way the exception will be on the line that creates the object - makes debugging much easier!"]}, {"cell_type": "markdown", "metadata": {}, "source": ["There are many more of these special methods, and we'll look in detail at them later in this course."]}, {"cell_type": "markdown", "metadata": {}, "source": ["## Variables are Memory References"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can find the memory address that a variable *references*, by using the `id()` function.\n", "\n", "The `id()` function returns the memory address of its argument as a base-10 integer.\n", "\n", "We can use the function `hex()` to convert the base-10 number to base-16."]}, {"cell_type": "code", "execution_count": 1, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["my_var = 10\n", "memory address of my_var (decimal): 1968827120\n", "memory address of my_var (hex): 0x7559eaf0\n"]}], "source": ["my_var = 10\n", "print('my_var = {0}'.format(my_var))\n", "print('memory address of my_var (decimal): {0}'.format(id(my_var)))\n", "print('memory address of my_var (hex): {0}'.format(hex(id(my_var))))"]}, {"cell_type": "code", "execution_count": 2, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["greeting = Hello\n", "memory address of my_var (decimal): 1688681719264\n", "memory address of my_var (hex): 0x1892d4625e0\n"]}], "source": ["greeting = 'Hello'\n", "print('greeting = {0}'.format(greeting))\n", "print('memory address of my_var (decimal): {0}'.format(id(greeting)))\n", "print('memory address of my_var (hex): {0}'.format(hex(id(greeting))))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Note how the memory address of `my_var` is **different** from that of `greeting`.\n", "\n", "Strictly speaking, `my_var` is not \"equal\" to 10. \n", "\n", "Instead `my_var` is a **reference** to an (*integer*) object (*containing the value 10*) located at the memory address `id(my_var)`\n", "\n", "Similarly for the variable `greeting`."]}, {"cell_type": "markdown", "metadata": {}, "source": ["## Reference Counting"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Method that returns the reference count for a given variable's memory address:"]}, {"cell_type": "code", "execution_count": 1, "metadata": {"collapsed": true}, "outputs": [], "source": ["import ctypes\n", "\n", "def ref_count(address):\n", "    return ctypes.c_long.from_address(address).value"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's make a variable, and check it's reference count:"]}, {"cell_type": "code", "execution_count": 2, "metadata": {}, "outputs": [{"data": {"text/plain": ["1"]}, "execution_count": 2, "metadata": {}, "output_type": "execute_result"}], "source": ["my_var = [1, 2, 3, 4]\n", "ref_count(id(my_var))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["There is another built-in function we can use to obtain the reference count:"]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [{"data": {"text/plain": ["2"]}, "execution_count": 3, "metadata": {}, "output_type": "execute_result"}], "source": ["import sys\n", "sys.getrefcount(my_var)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But why is this returning 2, instead of the expected 1 we obtained with the previous function?\n", "\n", "Answer: The *sys.getrefcount()* function takes **my_var** as an argument, this means it receives (and stores) a reference to **my_var**'s memory address **also** - hence the count is off by 1. So we will use *from_address()* instead."]}, {"cell_type": "markdown", "metadata": {}, "source": ["We make another reference to the **same** reference as `my_var`:"]}, {"cell_type": "code", "execution_count": 4, "metadata": {"collapsed": true}, "outputs": [], "source": ["other_var = my_var"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's look at the memory address of those two variables and the reference counts:"]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["0x1e43f368388 0x1e43f368388\n", "2\n"]}], "source": ["print(hex(id(my_var)), hex(id(other_var)))\n", "print(ref_count(id(my_var)))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Force one reference to go away:"]}, {"cell_type": "code", "execution_count": 6, "metadata": {"collapsed": true}, "outputs": [], "source": ["other_var = None"]}, {"cell_type": "markdown", "metadata": {}, "source": ["And we look at the reference count again:"]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1\n"]}], "source": ["print(ref_count(id(my_var)))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We see that the reference count has gone back to 1."]}, {"cell_type": "markdown", "metadata": {}, "source": ["You'll probably never need to do anything like this in Python. Memory management is completely transparent - this is just to illustrate some of what is going behind the scenes as it helps to understand upcoming concepts."]}, {"cell_type": "markdown", "metadata": {"collapsed": true}, "source": ["## Garbage Collection"]}, {"cell_type": "code", "execution_count": 1, "metadata": {"collapsed": true}, "outputs": [], "source": ["import ctypes\n", "import gc"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We use the same function that we used in the lesson on reference counting to calculate the number of references to a specified object (using its memory address to avoid creating an extra reference)"]}, {"cell_type": "code", "execution_count": 2, "metadata": {"collapsed": true}, "outputs": [], "source": ["def ref_count(address):\n", "    return ctypes.c_long.from_address(address).value"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We create a function that will search the objects in the GC for a specified id and tell us if the object was found or not:"]}, {"cell_type": "code", "execution_count": 3, "metadata": {"collapsed": true}, "outputs": [], "source": ["def object_by_id(object_id):\n", "    for obj in gc.get_objects():\n", "        if id(obj) == object_id:\n", "            return \"Object exists\"\n", "    return \"Not found\""]}, {"cell_type": "markdown", "metadata": {}, "source": ["Next we define two classes that we will use to create a circular reference\n", "\n", "Class A's constructor will create an instance of class B and pass itself to class B's constructor that will then store that reference in some instance variable."]}, {"cell_type": "code", "execution_count": 4, "metadata": {"collapsed": true}, "outputs": [], "source": ["class A:\n", "    def __init__(self):\n", "        self.b = B(self)\n", "        print('A: self: {0}, b:{1}'.format(hex(id(self)), hex(id(self.b))))"]}, {"cell_type": "code", "execution_count": 5, "metadata": {"collapsed": true}, "outputs": [], "source": ["class B:\n", "    def __init__(self, a):\n", "        self.a = a\n", "        print('B: self: {0}, a: {1}'.format(hex(id(self)), hex(id(self.a))))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We turn off the GC so we can see how reference counts are affected when the GC does not run and when it does (by running it manually)."]}, {"cell_type": "code", "execution_count": 6, "metadata": {"collapsed": true}, "outputs": [], "source": ["gc.disable()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now we create an instance of A, which will, in turn, create an instance of B which will store a reference to the calling A instance."]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["B: self: 0x1fc1eae44e0, a: 0x1fc1eae4908\n", "A: self: 0x1fc1eae4908, b:0x1fc1eae44e0\n"]}], "source": ["my_var = A()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As we can see A and B's constructors ran, and we also see from the memory addresses that we have a circular reference.\n", "\n", "In fact `my_var` is also a reference to the same A instance:"]}, {"cell_type": "code", "execution_count": 8, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["0x1fc1eae4908\n"]}], "source": ["print(hex(id(my_var)))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Another way to see this:"]}, {"cell_type": "code", "execution_count": 9, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["a: \t0x1fc1eae4908\n", "a.b: \t0x1fc1eae44e0\n", "b.a: \t0x1fc1eae4908\n"]}], "source": ["print('a: \\t{0}'.format(hex(id(my_var))))\n", "print('a.b: \\t{0}'.format(hex(id(my_var.b))))\n", "print('b.a: \\t{0}'.format(hex(id(my_var.b.a))))"]}, {"cell_type": "code", "execution_count": 10, "metadata": {"collapsed": true}, "outputs": [], "source": ["a_id = id(my_var)\n", "b_id = id(my_var.b)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can see how many references we have for `a` and `b`:"]}, {"cell_type": "code", "execution_count": 11, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["refcount(a) = 2\n", "refcount(b) = 1\n", "a: Object exists\n", "b: Object exists\n"]}], "source": ["print('refcount(a) = {0}'.format(ref_count(a_id)))\n", "print('refcount(b) = {0}'.format(ref_count(b_id)))\n", "print('a: {0}'.format(object_by_id(a_id)))\n", "print('b: {0}'.format(object_by_id(b_id)))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As we can see the A instance has two references (one from `my_var`, the other from the instance variable `b` in the B instance)\n", "\n", "The B instance has one reference (from the A instance variable `a`)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now, let's remove the reference to the A instance that is being held by `my_var`:"]}, {"cell_type": "code", "execution_count": 12, "metadata": {"collapsed": true}, "outputs": [], "source": ["my_var= None"]}, {"cell_type": "code", "execution_count": 13, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["refcount(a) = 1\n", "refcount(b) = 1\n", "a: Object exists\n", "b: Object exists\n"]}], "source": ["print('refcount(a) = {0}'.format(ref_count(a_id)))\n", "print('refcount(b) = {0}'.format(ref_count(b_id)))\n", "print('a: {0}'.format(object_by_id(a_id)))\n", "print('b: {0}'.format(object_by_id(b_id)))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As we can see, the reference counts are now both equal to 1 (a pure circular reference), and reference counting alone did not destroy the A and B instances - they're still around. If no garbage collection is performed this would result in a memory leak."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's run the GC manually and re-check whether the objects still exist:"]}, {"cell_type": "code", "execution_count": 14, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["refcount(a) = 0\n", "refcount(b) = 0\n", "a: Not found\n", "b: Not found\n"]}], "source": ["gc.collect()\n", "print('refcount(a) = {0}'.format(ref_count(a_id)))\n", "print('refcount(b) = {0}'.format(ref_count(b_id)))\n", "print('a: {0}'.format(object_by_id(a_id)))\n", "print('b: {0}'.format(object_by_id(b_id)))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Dynamic Typing"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Python is dynamically typed.\n", "\n", "This means that the type of a variable is simply the type of the object the variable name points to (references). The variable itself has no associated type."]}, {"cell_type": "code", "execution_count": 1, "metadata": {"collapsed": true}, "outputs": [], "source": ["a = \"hello\""]}, {"cell_type": "code", "execution_count": 2, "metadata": {}, "outputs": [{"data": {"text/plain": ["str"]}, "execution_count": 2, "metadata": {}, "output_type": "execute_result"}], "source": ["type(a)"]}, {"cell_type": "code", "execution_count": 3, "metadata": {"collapsed": true}, "outputs": [], "source": ["a = 10"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"data": {"text/plain": ["int"]}, "execution_count": 4, "metadata": {}, "output_type": "execute_result"}], "source": ["type(a)"]}, {"cell_type": "code", "execution_count": 5, "metadata": {"collapsed": true}, "outputs": [], "source": ["a = lambda x: x**2"]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [{"data": {"text/plain": ["4"]}, "execution_count": 6, "metadata": {}, "output_type": "execute_result"}], "source": ["a(2)"]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"data": {"text/plain": ["function"]}, "execution_count": 7, "metadata": {}, "output_type": "execute_result"}], "source": ["type(a)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see from the above examples, the type of the variable ``a`` changed over time - in fact it was simply the type of the object ``a`` was referencing at that time. No type was ever attached to the variable name itself."]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": []}, {"cell_type": "markdown", "metadata": {}, "source": ["## Variable Re-Assignment"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Notice how the memory address of **a** is different every time."]}, {"cell_type": "code", "execution_count": 1, "metadata": {}, "outputs": [{"data": {"text/plain": ["'0x7559eaf0'"]}, "execution_count": 1, "metadata": {}, "output_type": "execute_result"}], "source": ["a = 10\n", "hex(id(a))"]}, {"cell_type": "code", "execution_count": 2, "metadata": {}, "outputs": [{"data": {"text/plain": ["'0x7559eb90'"]}, "execution_count": 2, "metadata": {}, "output_type": "execute_result"}], "source": ["a = 15\n", "hex(id(a))"]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [{"data": {"text/plain": ["'0x7559ea50'"]}, "execution_count": 3, "metadata": {}, "output_type": "execute_result"}], "source": ["a = 5\n", "hex(id(a))"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"data": {"text/plain": ["'0x7559ea70'"]}, "execution_count": 4, "metadata": {}, "output_type": "execute_result"}], "source": ["a = a + 1\n", "hex(id(a))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["However, look at this:"]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["0x7559eaf0\n", "0x7559eaf0\n"]}], "source": ["a = 10\n", "b = 10\n", "print(hex(id(a)))\n", "print(hex(id(b)))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The memory addresses of both **a** and **b** are the same!! \n", "\n", "We'll revisit this in a bit to explain what is going on."]}, {"cell_type": "markdown", "metadata": {}, "source": ["## Object Mutability"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Certain Python built-in object types (aka data types) are **mutable**.\n", "\n", "That is, the internal contents (state) of the object in memory can be modified."]}, {"cell_type": "code", "execution_count": 1, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["[1, 2, 3]\n", "0x1cf6ab5b208\n"]}], "source": ["my_list = [1, 2, 3]\n", "print(my_list)\n", "print(hex(id(my_list)))"]}, {"cell_type": "code", "execution_count": 2, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["[1, 2, 3, 4]\n", "0x1cf6ab5b208\n"]}], "source": ["my_list.append(4)\n", "print(my_list)\n", "print(hex(id(my_list)))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see, the memory address of *my_list* has **not** changed.\n", "\n", "But, the **contents** of *my_list* has changed from *[1, 2, 3]* to *[1, 2, 3, 4]*."]}, {"cell_type": "markdown", "metadata": {}, "source": ["On the other hand, consider this:"]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["[1, 2, 3]\n", "0x1cf6abd55c8\n"]}], "source": ["my_list_1 = [1, 2, 3]\n", "print(my_list_1)\n", "print(hex(id(my_list_1)))"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["[1, 2, 3, 4]\n", "0x1cf6ab56888\n"]}], "source": ["my_list_1 = my_list_1 + [4]\n", "print(my_list_1)\n", "print(hex(id(my_list_1)))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Notice here that the memory address of *my_list_1* **did** change."]}, {"cell_type": "markdown", "metadata": {}, "source": ["This is because concatenating two lists objects *my_list_1* and *[4]* did not modify the contents of *my_list_1* - instead it created a new list object and re-assigned *my_list_1* to reference this new object."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Similarly with **dictionary** objects that are also **mutable** types."]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["{'key1': 'value 1'}\n", "0x1cf6abdcdc8\n"]}], "source": ["my_dict = dict(key1='value 1')\n", "print(my_dict)\n", "print(hex(id(my_dict)))"]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["{'key1': 'modified value 1'}\n", "0x1cf6abdcdc8\n"]}], "source": ["my_dict['key1'] = 'modified value 1'\n", "print(my_dict)\n", "print(hex(id(my_dict)))"]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["{'key1': 'modified value 1', 'key2': 'value 2'}\n", "0x1cf6abdcdc8\n"]}], "source": ["my_dict['key2'] = 'value 2'\n", "print(my_dict)\n", "print(hex(id(my_dict)))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Once again we see that while we are modifying the **contents** of the dictionary, the memory address of *my_dict* has not changed."]}, {"cell_type": "markdown", "metadata": {}, "source": ["\n", "Now consider the immutable sequence type: **tuple**"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The tuple is immutable, so elements cannot be added, removed or replaced."]}, {"cell_type": "code", "execution_count": 8, "metadata": {"collapsed": true}, "outputs": [], "source": ["t = (1, 2, 3)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["This tuple will **never** change at all. It has three elements, the integers 1, 2, and 3. This will remain the case as long as **t**'s reference is not changed."]}, {"cell_type": "markdown", "metadata": {}, "source": ["But, consider the following tuple:"]}, {"cell_type": "code", "execution_count": 9, "metadata": {"collapsed": true}, "outputs": [], "source": ["a = [1, 2]\n", "b = [3, 4]\n", "t = (a, b)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now, **t** is still immutable, i.e. it contains a reference to the object **a** and the object **b**. **That** will never change as long as **t**'s reference is not re-assigned.\n", "\n", "**However**, the elements **a** and **b** are, themselves, mutable."]}, {"cell_type": "code", "execution_count": 10, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["([1, 2, 3], [3, 4, 5])\n"]}], "source": ["a.append(3)\n", "b.append(5)\n", "print(t)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Observe that the contents of **a** and **b** **did** change!\n", "\n", "So immutability can be a little more subtle than just thinking something can never change. \n", "\n", "The tuple **t** did **not** change - it contains two elements, that are the references **a** and **b**. And that will not change. But, because the referenced elements are mutable themselves, it appears as though the tuple has changed.\n", "\n", "It hasn't though - that distinction is subtle but important to understand!"]}, {"cell_type": "markdown", "metadata": {}, "source": ["## Function Arguments and  Mutability"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Consider a function that receives a *string* argument, and changes the argument in some way:"]}, {"cell_type": "code", "execution_count": 1, "metadata": {"collapsed": true}, "outputs": [], "source": ["def process(s):\n", "    print('initial s # = {0}'.format(hex(id(s))))\n", "    s = s + ' world'\n", "    print('s after change # = {0}'.format(hex(id(s))))"]}, {"cell_type": "code", "execution_count": 2, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["my_var # = 0x1e7e96fc420\n"]}], "source": ["my_var = 'hello'\n", "print('my_var # = {0}'.format(hex(id(my_var))))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Note that when *s* is received, it is referencing the same object as *my_var*.\n", "\n", "After we \"modify\" *s*, *s* is pointing to a new memory address:"]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["initial s # = 0x1e7e96fc420\n", "s after change # = 0x1e7e97153b0\n"]}], "source": ["process(my_var)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["And our own variable *my_var* is still pointing to the original memory address:"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["my_var # = 0x1e7e96fc420\n"]}], "source": ["print('my_var # = {0}'.format(hex(id(my_var))))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's see how this works with mutable objects:"]}, {"cell_type": "code", "execution_count": 5, "metadata": {"collapsed": true}, "outputs": [], "source": ["def modify_list(items):\n", "    print('initial items # = {0}'.format(hex(id(items))))\n", "    if len(items) > 0:\n", "        items[0] = items[0] ** 2\n", "    items.pop()\n", "    items.append(5)\n", "    print('final items # = {0}'.format(hex(id(items))))"]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["my_list # = 0x1e7e972d308\n"]}], "source": ["my_list = [2, 3, 4]\n", "print('my_list # = {0}'.format(hex(id(my_list))))"]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["initial items # = 0x1e7e972d308\n", "final items # = 0x1e7e972d308\n"]}], "source": ["modify_list(my_list)"]}, {"cell_type": "code", "execution_count": 8, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["[4, 3, 5]\n", "my_list # = 0x1e7e972d308\n"]}], "source": ["print(my_list)\n", "print('my_list # = {0}'.format(hex(id(my_list))))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see, throughout all the code, the memory address referenced by *my_list* and *items* is always the **same** (shared) reference - we are simply modifying the contents (**internal state**) of the object at that memory address."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now, even with immutable container objects we have to be careful, e.g. a tuple containing a list (the tuple is immutable, but the list element inside the tuple **is** mutable)"]}, {"cell_type": "code", "execution_count": 9, "metadata": {"collapsed": true}, "outputs": [], "source": ["def modify_tuple(t):\n", "    print('initial t # = {0}'.format(hex(id(t))))\n", "    t[0].append(100)\n", "    print('final t # = {0}'.format(hex(id(t))))"]}, {"cell_type": "code", "execution_count": 10, "metadata": {"collapsed": true}, "outputs": [], "source": ["my_tuple = ([1, 2], 'a')"]}, {"cell_type": "code", "execution_count": 11, "metadata": {}, "outputs": [{"data": {"text/plain": ["'0x1e7e9614288'"]}, "execution_count": 11, "metadata": {}, "output_type": "execute_result"}], "source": ["hex(id(my_tuple))"]}, {"cell_type": "code", "execution_count": 12, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["initial t # = 0x1e7e9614288\n", "final t # = 0x1e7e9614288\n"]}], "source": ["modify_tuple(my_tuple)"]}, {"cell_type": "code", "execution_count": 13, "metadata": {}, "outputs": [{"data": {"text/plain": ["([1, 2, 100], 'a')"]}, "execution_count": 13, "metadata": {}, "output_type": "execute_result"}], "source": ["my_tuple"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see, the first element of the tuple was mutated."]}, {"cell_type": "markdown", "metadata": {}, "source": ["## Shared References and Mutability"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The following sets up a shared reference between the variables my_var_1 and my_var_2"]}, {"cell_type": "code", "execution_count": 1, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["hello\n", "hello\n"]}], "source": ["my_var_1 = 'hello'\n", "my_var_2 = my_var_1\n", "print(my_var_1)\n", "print(my_var_2)"]}, {"cell_type": "code", "execution_count": 2, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["0x24c9144ca08\n", "0x24c9144ca08\n"]}], "source": ["print(hex(id(my_var_1)))\n", "print(hex(id(my_var_2)))"]}, {"cell_type": "code", "execution_count": 3, "metadata": {"collapsed": true}, "outputs": [], "source": ["my_var_2 = my_var_2 + ' world!'"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["0x24c9144ca08\n", "0x24c9144fab0\n"]}], "source": ["print(hex(id(my_var_1)))\n", "print(hex(id(my_var_2)))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Be careful if the variable type is mutable!\n", "\n", "Here we create a list (*my_list_1*) and create a variable (*my_list_2*) referencing the same list object:"]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["[1, 2, 3]\n", "[1, 2, 3]\n"]}], "source": ["my_list_1 = [1, 2, 3]\n", "my_list_2 = my_list_1\n", "print(my_list_1)\n", "print(my_list_2)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As we can see they have the same memory address (shared reference):"]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["0x24c9144fc48\n", "0x24c9144fc48\n"]}], "source": ["print(hex(id(my_list_1)))\n", "print(hex(id(my_list_2)))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now we modify the list referenced by *my_list_2*:"]}, {"cell_type": "code", "execution_count": 7, "metadata": {"collapsed": true}, "outputs": [], "source": ["my_list_2.append(4)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["*my_list_2* has been modified:"]}, {"cell_type": "code", "execution_count": 8, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["[1, 2, 3, 4]\n"]}], "source": ["print(my_list_2)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["And since my_list_1 references the same list object, it has also changed:"]}, {"cell_type": "code", "execution_count": 9, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["[1, 2, 3, 4]\n"]}], "source": ["print(my_list_1)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see, both variables still share the same reference:"]}, {"cell_type": "code", "execution_count": 10, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["0x24c9144fc48\n", "0x24c9144fc48\n"]}], "source": ["print(hex(id(my_list_1)))\n", "print(hex(id(my_list_2)))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Behind the scenes with Python's memory manager\n", "----"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Recall from a few lectures back:"]}, {"cell_type": "code", "execution_count": 11, "metadata": {"collapsed": true}, "outputs": [], "source": ["a = 10\n", "b = 10"]}, {"cell_type": "code", "execution_count": 12, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["0x7559eaf0\n", "0x7559eaf0\n"]}], "source": ["print(hex(id(a)))\n", "print(hex(id(b)))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Same memory address!!\n", "\n", "This is safe for Python to do because integer objects are **immutable**. \n", "\n", "So, even though *a* and *b* initially shared the same memory address, we can never modify *a*'s value by \"modifying\" *b*'s value. \n", "\n", "The only way to change *b*'s value is to change it's reference, which will never affect *a*."]}, {"cell_type": "code", "execution_count": 13, "metadata": {"collapsed": true}, "outputs": [], "source": ["b = 15"]}, {"cell_type": "code", "execution_count": 14, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["0x7559eaf0\n", "0x7559eb90\n"]}], "source": ["print(hex(id(a)))\n", "print(hex(id(b)))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["However, for mutable objects, Python's memory manager does not do this, since that would **not** be safe."]}, {"cell_type": "code", "execution_count": 15, "metadata": {"collapsed": true}, "outputs": [], "source": ["my_list_1 = [1, 2, 3]\n", "my_list_2 = [1, 2 , 3]"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see, although the two variables were assigned identical \"contents\", the memory addresses are not the same:"]}, {"cell_type": "code", "execution_count": 16, "metadata": {"scrolled": true}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["0x24c9146c5c8\n", "0x24c913c6848\n"]}], "source": ["print(hex(id(my_list_1)))\n", "print(hex(id(my_list_2)))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["## Variable Equality"]}, {"cell_type": "markdown", "metadata": {}, "source": ["From the previous lecture we know that **a** and **b** will have a **shared** reference:"]}, {"cell_type": "code", "execution_count": 1, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["0x7559eaf0\n", "0x7559eaf0\n"]}], "source": ["a = 10\n", "b = 10\n", "\n", "print(hex(id(a)))\n", "print(hex(id(b)))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["When we use the **is** operator, we are comparing the memory address **references**:"]}, {"cell_type": "code", "execution_count": 2, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["a is b:  True\n"]}], "source": ["print(\"a is b: \", a is b)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But if we use the **==** operator, we are comparing the **contents**:"]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["a == b: True\n"]}], "source": ["print(\"a == b:\", a == b)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The following however, do not have a shared reference:"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["0x27006f17288\n", "0x27006e968c8\n"]}], "source": ["a = [1, 2, 3]\n", "b = [1, 2, 3]\n", "\n", "print(hex(id(a)))\n", "print(hex(id(b)))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Although they are not the same objects, they do contain the same \"values\":"]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["a is b:  False\n", "a == b True\n"]}], "source": ["print(\"a is b: \", a is b)\n", "print(\"a == b\", a == b)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Python will attempt to compare values as best as possible, for example:"]}, {"cell_type": "code", "execution_count": 6, "metadata": {"collapsed": true}, "outputs": [], "source": ["a = 10\n", "b = 10.0"]}, {"cell_type": "markdown", "metadata": {}, "source": ["These are **not** the same reference, since one object is an **int** and the other is a **float**"]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["<class 'int'>\n", "<class 'float'>\n"]}], "source": ["print(type(a))\n", "print(type(b))"]}, {"cell_type": "code", "execution_count": 8, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["0x7559eaf0\n", "0x270064b1870\n"]}], "source": ["print(hex(id(a)))\n", "print(hex(id(b)))"]}, {"cell_type": "code", "execution_count": 9, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["a is b: False\n", "a == b: True\n"]}], "source": ["print('a is b:', a is b)\n", "print('a == b:', a == b)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["So, even though *a* is an integer 10, and *b* is a float 10.0, the values will still compare as equal."]}, {"cell_type": "markdown", "metadata": {}, "source": ["In fact, this will also have the same behavior:"]}, {"cell_type": "code", "execution_count": 10, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["<class 'complex'>\n"]}], "source": ["c = 10 + 0j\n", "print(type(c))"]}, {"cell_type": "code", "execution_count": 11, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["a is c: False\n", "a == c: True\n"]}], "source": ["print('a is c:', a is c)\n", "print('a == c:', a == c)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["### The None Object\n", "----"]}, {"cell_type": "markdown", "metadata": {}, "source": ["**None** is a built-in \"variable\" of type *NoneType*.\n", "\n", "Basically the keyword **None** is a reference to an object instance of *NoneType*.\n", "\n", "NoneType objects are immutable! Python's memory manager will therefore use shared references to the None object."]}, {"cell_type": "code", "execution_count": 12, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["None\n"]}], "source": ["print(None)"]}, {"cell_type": "code", "execution_count": 13, "metadata": {}, "outputs": [{"data": {"text/plain": ["'0x75576bc0'"]}, "execution_count": 13, "metadata": {}, "output_type": "execute_result"}], "source": ["hex(id(None))"]}, {"cell_type": "code", "execution_count": 14, "metadata": {}, "outputs": [{"data": {"text/plain": ["NoneType"]}, "execution_count": 14, "metadata": {}, "output_type": "execute_result"}], "source": ["type(None)"]}, {"cell_type": "code", "execution_count": 15, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["<class 'NoneType'>\n", "0x75576bc0\n"]}], "source": ["a = None\n", "print(type(a))\n", "print(hex(id(a)))"]}, {"cell_type": "code", "execution_count": 16, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 16, "metadata": {}, "output_type": "execute_result"}], "source": ["a is None"]}, {"cell_type": "code", "execution_count": 17, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 17, "metadata": {}, "output_type": "execute_result"}], "source": ["a == None"]}, {"cell_type": "code", "execution_count": 18, "metadata": {}, "outputs": [{"data": {"text/plain": ["'0x75576bc0'"]}, "execution_count": 18, "metadata": {}, "output_type": "execute_result"}], "source": ["b = None\n", "hex(id(b))"]}, {"cell_type": "code", "execution_count": 19, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 19, "metadata": {}, "output_type": "execute_result"}], "source": ["a is b"]}, {"cell_type": "code", "execution_count": 20, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 20, "metadata": {}, "output_type": "execute_result"}], "source": ["a == b"]}, {"cell_type": "code", "execution_count": 21, "metadata": {"collapsed": true}, "outputs": [], "source": ["l = []"]}, {"cell_type": "code", "execution_count": 22, "metadata": {}, "outputs": [{"data": {"text/plain": ["list"]}, "execution_count": 22, "metadata": {}, "output_type": "execute_result"}], "source": ["type(l)"]}, {"cell_type": "code", "execution_count": 23, "metadata": {}, "outputs": [{"data": {"text/plain": ["False"]}, "execution_count": 23, "metadata": {}, "output_type": "execute_result"}], "source": ["l is None"]}, {"cell_type": "code", "execution_count": 24, "metadata": {}, "outputs": [{"data": {"text/plain": ["False"]}, "execution_count": 24, "metadata": {}, "output_type": "execute_result"}], "source": ["l == None"]}, {"cell_type": "markdown", "metadata": {}, "source": ["## Everything is an Object"]}, {"cell_type": "code", "execution_count": 1, "metadata": {"collapsed": true}, "outputs": [], "source": ["a = 10"]}, {"cell_type": "markdown", "metadata": {}, "source": ["**a** is an object of type **int**, i.e. **a** is an instance of the **int** class."]}, {"cell_type": "code", "execution_count": 2, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["<class 'int'>\n"]}], "source": ["print(type(a))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["If **int** is a class, we should be able to declare it using standard class instatiation:"]}, {"cell_type": "code", "execution_count": 3, "metadata": {"collapsed": true}, "outputs": [], "source": ["b = int(10)"]}, {"cell_type": "code", "execution_count": 4, "metadata": {"scrolled": true}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["10\n", "<class 'int'>\n"]}], "source": ["print(b)\n", "print(type(b))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can even request the class documentation:"]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Help on class int in module builtins:\n", "\n", "class int(object)\n", " |  int(x=0) -> integer\n", " |  int(x, base=10) -> integer\n", " |  \n", " |  Convert a number or string to an integer, or return 0 if no arguments\n", " |  are given.  If x is a number, return x.__int__().  For floating point\n", " |  numbers, this truncates towards zero.\n", " |  \n", " |  If x is not a number or if base is given, then x must be a string,\n", " |  bytes, or bytearray instance representing an integer literal in the\n", " |  given base.  The literal can be preceded by '+' or '-' and be surrounded\n", " |  by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\n", " |  Base 0 means to interpret the base from the string as an integer literal.\n", " |  >>> int('0b100', base=0)\n", " |  4\n", " |  \n", " |  Methods defined here:\n", " |  \n", " |  __abs__(self, /)\n", " |      abs(self)\n", " |  \n", " |  __add__(self, value, /)\n", " |      Return self+value.\n", " |  \n", " |  __and__(self, value, /)\n", " |      Return self&value.\n", " |  \n", " |  __bool__(self, /)\n", " |      self != 0\n", " |  \n", " |  __ceil__(...)\n", " |      Ceiling of an Integral returns itself.\n", " |  \n", " |  __divmod__(self, value, /)\n", " |      Return divmod(self, value).\n", " |  \n", " |  __eq__(self, value, /)\n", " |      Return self==value.\n", " |  \n", " |  __float__(self, /)\n", " |      float(self)\n", " |  \n", " |  __floor__(...)\n", " |      Flooring an Integral returns itself.\n", " |  \n", " |  __floordiv__(self, value, /)\n", " |      Return self//value.\n", " |  \n", " |  __format__(...)\n", " |      default object formatter\n", " |  \n", " |  __ge__(self, value, /)\n", " |      Return self>=value.\n", " |  \n", " |  __getattribute__(self, name, /)\n", " |      Return getattr(self, name).\n", " |  \n", " |  __getnewargs__(...)\n", " |  \n", " |  __gt__(self, value, /)\n", " |      Return self>value.\n", " |  \n", " |  __hash__(self, /)\n", " |      Return hash(self).\n", " |  \n", " |  __index__(self, /)\n", " |      Return self converted to an integer, if self is suitable for use as an index into a list.\n", " |  \n", " |  __int__(self, /)\n", " |      int(self)\n", " |  \n", " |  __invert__(self, /)\n", " |      ~self\n", " |  \n", " |  __le__(self, value, /)\n", " |      Return self<=value.\n", " |  \n", " |  __lshift__(self, value, /)\n", " |      Return self<<value.\n", " |  \n", " |  __lt__(self, value, /)\n", " |      Return self<value.\n", " |  \n", " |  __mod__(self, value, /)\n", " |      Return self%value.\n", " |  \n", " |  __mul__(self, value, /)\n", " |      Return self*value.\n", " |  \n", " |  __ne__(self, value, /)\n", " |      Return self!=value.\n", " |  \n", " |  __neg__(self, /)\n", " |      -self\n", " |  \n", " |  __new__(*args, **kwargs) from builtins.type\n", " |      Create and return a new object.  See help(type) for accurate signature.\n", " |  \n", " |  __or__(self, value, /)\n", " |      Return self|value.\n", " |  \n", " |  __pos__(self, /)\n", " |      +self\n", " |  \n", " |  __pow__(self, value, mod=None, /)\n", " |      Return pow(self, value, mod).\n", " |  \n", " |  __radd__(self, value, /)\n", " |      Return value+self.\n", " |  \n", " |  __rand__(self, value, /)\n", " |      Return value&self.\n", " |  \n", " |  __rdivmod__(self, value, /)\n", " |      Return divmod(value, self).\n", " |  \n", " |  __repr__(self, /)\n", " |      Return repr(self).\n", " |  \n", " |  __rfloordiv__(self, value, /)\n", " |      Return value//self.\n", " |  \n", " |  __rlshift__(self, value, /)\n", " |      Return value<<self.\n", " |  \n", " |  __rmod__(self, value, /)\n", " |      Return value%self.\n", " |  \n", " |  __rmul__(self, value, /)\n", " |      Return value*self.\n", " |  \n", " |  __ror__(self, value, /)\n", " |      Return value|self.\n", " |  \n", " |  __round__(...)\n", " |      Rounding an Integral returns itself.\n", " |      Rounding with an ndigits argument also returns an integer.\n", " |  \n", " |  __rpow__(self, value, mod=None, /)\n", " |      Return pow(value, self, mod).\n", " |  \n", " |  __rrshift__(self, value, /)\n", " |      Return value>>self.\n", " |  \n", " |  __rshift__(self, value, /)\n", " |      Return self>>value.\n", " |  \n", " |  __rsub__(self, value, /)\n", " |      Return value-self.\n", " |  \n", " |  __rtruediv__(self, value, /)\n", " |      Return value/self.\n", " |  \n", " |  __rxor__(self, value, /)\n", " |      Return value^self.\n", " |  \n", " |  __sizeof__(...)\n", " |      Returns size in memory, in bytes\n", " |  \n", " |  __str__(self, /)\n", " |      Return str(self).\n", " |  \n", " |  __sub__(self, value, /)\n", " |      Return self-value.\n", " |  \n", " |  __truediv__(self, value, /)\n", " |      Return self/value.\n", " |  \n", " |  __trunc__(...)\n", " |      Truncating an Integral returns itself.\n", " |  \n", " |  __xor__(self, value, /)\n", " |      Return self^value.\n", " |  \n", " |  bit_length(...)\n", " |      int.bit_length() -> int\n", " |      \n", " |      Number of bits necessary to represent self in binary.\n", " |      >>> bin(37)\n", " |      '0b100101'\n", " |      >>> (37).bit_length()\n", " |      6\n", " |  \n", " |  conjugate(...)\n", " |      Returns self, the complex conjugate of any int.\n", " |  \n", " |  from_bytes(...) from builtins.type\n", " |      int.from_bytes(bytes, byteorder, *, signed=False) -> int\n", " |      \n", " |      Return the integer represented by the given array of bytes.\n", " |      \n", " |      The bytes argument must be a bytes-like object (e.g. bytes or bytearray).\n", " |      \n", " |      The byteorder argument determines the byte order used to represent the\n", " |      integer.  If byteorder is 'big', the most significant byte is at the\n", " |      beginning of the byte array.  If byteorder is 'little', the most\n", " |      significant byte is at the end of the byte array.  To request the native\n", " |      byte order of the host system, use `sys.byteorder' as the byte order value.\n", " |      \n", " |      The signed keyword-only argument indicates whether two's complement is\n", " |      used to represent the integer.\n", " |  \n", " |  to_bytes(...)\n", " |      int.to_bytes(length, byteorder, *, signed=False) -> bytes\n", " |      \n", " |      Return an array of bytes representing an integer.\n", " |      \n", " |      The integer is represented using length bytes.  An OverflowError is\n", " |      raised if the integer is not representable with the given number of\n", " |      bytes.\n", " |      \n", " |      The byteorder argument determines the byte order used to represent the\n", " |      integer.  If byteorder is 'big', the most significant byte is at the\n", " |      beginning of the byte array.  If byteorder is 'little', the most\n", " |      significant byte is at the end of the byte array.  To request the native\n", " |      byte order of the host system, use `sys.byteorder' as the byte order value.\n", " |      \n", " |      The signed keyword-only argument determines whether two's complement is\n", " |      used to represent the integer.  If signed is False and a negative integer\n", " |      is given, an OverflowError is raised.\n", " |  \n", " |  ----------------------------------------------------------------------\n", " |  Data descriptors defined here:\n", " |  \n", " |  denominator\n", " |      the denominator of a rational number in lowest terms\n", " |  \n", " |  imag\n", " |      the imaginary part of a complex number\n", " |  \n", " |  numerator\n", " |      the numerator of a rational number in lowest terms\n", " |  \n", " |  real\n", " |      the real part of a complex number\n", "\n"]}], "source": ["help(int)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As we see from the docs, we can even create an **int** using an overloaded constructor:"]}, {"cell_type": "code", "execution_count": 6, "metadata": {"collapsed": true}, "outputs": [], "source": ["b = int('10', base=2)"]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["2\n", "<class 'int'>\n"]}], "source": ["print(b)\n", "print(type(b))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Functions are Objects too\n", "---"]}, {"cell_type": "code", "execution_count": 8, "metadata": {"collapsed": true}, "outputs": [], "source": ["def square(a):\n", "    return a ** 2"]}, {"cell_type": "code", "execution_count": 9, "metadata": {}, "outputs": [{"data": {"text/plain": ["function"]}, "execution_count": 9, "metadata": {}, "output_type": "execute_result"}], "source": ["type(square)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["In fact, we can even assign them to a variable:"]}, {"cell_type": "code", "execution_count": 10, "metadata": {"collapsed": true}, "outputs": [], "source": ["f = square"]}, {"cell_type": "code", "execution_count": 11, "metadata": {}, "outputs": [{"data": {"text/plain": ["function"]}, "execution_count": 11, "metadata": {}, "output_type": "execute_result"}], "source": ["type(f)"]}, {"cell_type": "code", "execution_count": 12, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 12, "metadata": {}, "output_type": "execute_result"}], "source": ["f is square"]}, {"cell_type": "code", "execution_count": 13, "metadata": {}, "outputs": [{"data": {"text/plain": ["4"]}, "execution_count": 13, "metadata": {}, "output_type": "execute_result"}], "source": ["f(2)"]}, {"cell_type": "code", "execution_count": 14, "metadata": {}, "outputs": [{"data": {"text/plain": ["int"]}, "execution_count": 14, "metadata": {}, "output_type": "execute_result"}], "source": ["type(f(2))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["A function can return a function"]}, {"cell_type": "code", "execution_count": 15, "metadata": {"collapsed": true}, "outputs": [], "source": ["def cube(a):\n", "    return a ** 3"]}, {"cell_type": "code", "execution_count": 16, "metadata": {"collapsed": true}, "outputs": [], "source": ["def select_function(fn_id):\n", "    if fn_id == 1:\n", "        return square\n", "    else:\n", "        return cube"]}, {"cell_type": "code", "execution_count": 17, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["0x21257457b70\n", "0x21257457b70\n", "0x21255fab8c8\n", "<class 'function'>\n", "f is square:  True\n", "f is cube:  False\n", "<function square at 0x0000021257457B70>\n", "4\n"]}], "source": ["f = select_function(1)\n", "print(hex(id(f)))\n", "print(hex(id(square)))\n", "print(hex(id(cube)))\n", "print(type(f))\n", "print('f is square: ', f is square)\n", "print('f is cube: ', f is cube)\n", "print(f)\n", "print(f(2))"]}, {"cell_type": "code", "execution_count": 18, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["0x21255fab8c8\n", "0x21257457b70\n", "0x21255fab8c8\n", "<class 'function'>\n", "f is square:  False\n", "f is cube:  True\n", "<function cube at 0x0000021255FAB8C8>\n", "8\n"]}], "source": ["f = select_function(2)\n", "print(hex(id(f)))\n", "print(hex(id(square)))\n", "print(hex(id(cube)))\n", "print(type(f))\n", "print('f is square: ', f is square)\n", "print('f is cube: ', f is cube)\n", "print(f)\n", "print(f(2))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We could even call it this way:"]}, {"cell_type": "code", "execution_count": 19, "metadata": {}, "outputs": [{"data": {"text/plain": ["25"]}, "execution_count": 19, "metadata": {}, "output_type": "execute_result"}], "source": ["select_function(1)(5)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["A Function can be passed as an argument to another function\n", "\n", "(This example is pretty useless, but it illustrates the point effectively)"]}, {"cell_type": "code", "execution_count": 20, "metadata": {"collapsed": true}, "outputs": [], "source": ["def exec_function(fn, n):\n", "    return fn(n)"]}, {"cell_type": "code", "execution_count": 21, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["8\n"]}], "source": ["result = exec_function(cube, 2)\n", "print(result)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We will come back to functions as arguments **many** more times throughout this course!"]}, {"cell_type": "markdown", "metadata": {}, "source": ["## Python Optimizations: Interning"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Earlier, we saw shared references being created automatically by Python:"]}, {"cell_type": "code", "execution_count": 1, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1968827120\n", "1968827120\n"]}], "source": ["a = 10\n", "b = 10\n", "print(id(a))\n", "print(id(b))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Note how `a` and `b` reference the same object.\n", "\n", "But consider the following example:"]}, {"cell_type": "code", "execution_count": 2, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1935322088624\n", "1935322089008\n"]}], "source": ["a = 500\n", "b = 500\n", "print(id(a))\n", "print(id(b))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see, the variables `a` and `b` do **not** point to the same object!\n", "\n", "This is because Python pre-caches integer objects in the range [-5, 256]"]}, {"cell_type": "markdown", "metadata": {}, "source": ["So for example:"]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1968834992\n", "1968834992\n"]}], "source": ["a = 256\n", "b = 256\n", "print(id(a))\n", "print(id(b))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["and"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1968826640\n", "1968826640\n"]}], "source": ["a = -5\n", "b = -5\n", "print(id(a))\n", "print(id(b))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["do have the same reference.\n", "\n", "This is called **interning**: Python **interns** the integers in the range [-5, 256]."]}, {"cell_type": "markdown", "metadata": {}, "source": ["The integers in the range [-5, 256] are essentially **singleton** objects."]}, {"cell_type": "code", "execution_count": 5, "metadata": {"collapsed": true}, "outputs": [], "source": ["a = 10\n", "b = int(10)\n", "c = int('10')\n", "d = int('1010', 2)"]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["10 10 10 10\n"]}], "source": ["print(a, b, c, d)"]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 7, "metadata": {}, "output_type": "execute_result"}], "source": ["a is b"]}, {"cell_type": "code", "execution_count": 8, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 8, "metadata": {}, "output_type": "execute_result"}], "source": ["a is c"]}, {"cell_type": "code", "execution_count": 9, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 9, "metadata": {}, "output_type": "execute_result"}], "source": ["a is d"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see, all these variables were created in different ways, but since the integer object with value 10 behaves like a singleton, they all ended up pointing to the **same** object in memory."]}, {"cell_type": "markdown", "metadata": {}, "source": ["## Python Optimizations: String Interning"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Python will automatically intern *certain* strings.\n", "\n", "In particular all the identifiers (variable names, function names, class names, etc) are interned (singleton objects created).\n", "\n", "Python will also intern string literals that look like identifiers.\n", "\n", "For example:"]}, {"cell_type": "code", "execution_count": 1, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1342722069536\n", "1342722069536\n"]}], "source": ["a = 'hello'\n", "b = 'hello'\n", "print(id(a))\n", "print(id(b))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But not the following:"]}, {"cell_type": "code", "execution_count": 2, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1342722047024\n", "1342722170928\n"]}], "source": ["a = 'hello, world!'\n", "b = 'hello, world!'\n", "print(id(a))\n", "print(id(b))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["However, because the following literals resemble identifiers, even though they are quite long, Python will still automatically intern them:"]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1342722047856\n", "1342722047856\n"]}], "source": ["a = 'hello_world'\n", "b = 'hello_world'\n", "print(id(a))\n", "print(id(b))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["And even longer:"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1342721886784\n", "1342721886784\n"]}], "source": ["a = '_this_is_a_long_string_that_could_be_used_as_an_identifier'\n", "b = '_this_is_a_long_string_that_could_be_used_as_an_identifier'\n", "print(id(a))\n", "print(id(b))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Even if the string starts with a digit:"]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1342722046256\n", "1342722046256\n"]}], "source": ["a = '1_hello_world'\n", "b = '1_hello_world'\n", "print(id(a))\n", "print(id(b))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["That was interned (pointer is the same), but look at this one:"]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1342722046832\n", "1342722172592\n"]}], "source": ["a = '1 hello world'\n", "b = '1 hello world'\n", "print(id(a))\n", "print(id(b))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Interning strings (making them singleton objects) means that testing for string equality can be done faster by comparing the memory address:"]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["a==b: True\n", "a is b: True\n"]}], "source": ["a = 'this_is_a_long_string'\n", "b = 'this_is_a_long_string'\n", "print('a==b:', a == b)\n", "print('a is b:', a is b)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### <font color=\"orange\">Note: Remember, using `is` ONLY works if the strings were interned!</font>\n", "\n", "Here's where this technique fails:"]}, {"cell_type": "code", "execution_count": 8, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["a==b: True\n", "a is b: False\n"]}], "source": ["a = 'hello world'\n", "b = 'hello world'\n", "print('a==b:', a==b)\n", "print('a is b:', a is b)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["You *can* force strings to be interned (but only use it if you have a valid performance optimization need):"]}, {"cell_type": "code", "execution_count": 9, "metadata": {"collapsed": true}, "outputs": [], "source": ["import sys"]}, {"cell_type": "code", "execution_count": 10, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1342722172080\n", "1342722172080\n", "1342722174896\n"]}], "source": ["a = sys.intern('hello world')\n", "b = sys.intern('hello world')\n", "c = 'hello world'\n", "print(id(a))\n", "print(id(b))\n", "print(id(c))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Notice how `a` and `b` are pointing to the same object, but `c` is **NOT**.\n", "\n", "So, since both `a` and `b` were interned we can use `is` to test for equality of the two strings:"]}, {"cell_type": "code", "execution_count": 11, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["a==b: True\n", "a is b: True\n"]}], "source": ["print('a==b:', a==b)\n", "print('a is b:', a is b)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["So, does interning really make a big speed difference?\n", "\n", "Yes, but only if you are performing a *lot* of comparisons."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's run some quick and dirty benchmarks:"]}, {"cell_type": "code", "execution_count": 12, "metadata": {"collapsed": true}, "outputs": [], "source": ["def compare_using_equals(n):\n", "    a = 'a long string that is not interned' * 200\n", "    b = 'a long string that is not interned' * 200\n", "    for i in range(n):\n", "        if a == b:\n", "            pass"]}, {"cell_type": "code", "execution_count": 13, "metadata": {"collapsed": true}, "outputs": [], "source": ["def compare_using_interning(n):\n", "    a = sys.intern('a long string that is not interned' * 200)\n", "    b = sys.intern('a long string that is not interned' * 200)\n", "    for i in range(n):\n", "        if a is b:\n", "            pass"]}, {"cell_type": "code", "execution_count": 14, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["equality:  2.965451618090112\n"]}], "source": ["import time\n", "\n", "start = time.perf_counter()\n", "compare_using_equals(10000000)\n", "end = time.perf_counter()\n", "\n", "print('equality: ', end-start)\n"]}, {"cell_type": "code", "execution_count": 15, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["identity:  0.28690104431129626\n"]}], "source": ["start = time.perf_counter()\n", "compare_using_interning(10000000)\n", "end = time.perf_counter()\n", "\n", "print('identity: ', end-start)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see, the performance difference, especially for long strings, and for many comparisons, can be quite radical!"]}, {"cell_type": "markdown", "metadata": {}, "source": ["## Python Peephole Optimizations"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Peephole optimizations refer to a certain class of optimization strategies Python employs during any compilation phases."]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Constant Expressions"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's see how Python reduces constant expressions for optimization purposes:"]}, {"cell_type": "code", "execution_count": 20, "metadata": {"collapsed": true}, "outputs": [], "source": ["def my_func():\n", "    a = 24 * 60\n", "    b = (1, 2) * 5\n", "    c = 'abc' * 3\n", "    d = 'ab' * 11\n", "    e = 'the quick brown fox' * 10\n", "    f = [1, 2] * 5\n"]}, {"cell_type": "code", "execution_count": 21, "metadata": {}, "outputs": [{"data": {"text/plain": ["(None,\n", " 24,\n", " 60,\n", " 1,\n", " 2,\n", " 5,\n", " 'abc',\n", " 3,\n", " 'ab',\n", " 11,\n", " 'the quick brown fox',\n", " 10,\n", " 1440,\n", " (1, 2),\n", " (1, 2, 1, 2, 1, 2, 1, 2, 1, 2),\n", " 'abcabcabc')"]}, "execution_count": 21, "metadata": {}, "output_type": "execute_result"}], "source": ["my_func.__code__.co_consts"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see in the example above, `24 * 60` was pre-calculated and cached as a constant (`1440`).\n", "\n", "Similarly, `(1, 2) * 5` was cached as `(1, 2, 1, 2, 1, 2, 1, 2, 1, 2)` and `'abc' * 3` was cached as `abcabcabc`.\n", "\n", "On the other hand, note how `'the quick brown fox' * 10` was **not** pre-calculated (too long).\n", "\n", "Similarly `[1, 2] * 5` was not pre-calculated either since a list is *mutable*, and hence not a *constant*."]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Membership Tests"]}, {"cell_type": "markdown", "metadata": {}, "source": ["In membership testing, optimizations are applied as can be seen below:"]}, {"cell_type": "code", "execution_count": 69, "metadata": {"collapsed": true}, "outputs": [], "source": ["def my_func():\n", "    if e in [1, 2, 3]:\n", "        pass"]}, {"cell_type": "code", "execution_count": 70, "metadata": {}, "outputs": [{"data": {"text/plain": ["(None, 1, 2, 3, (1, 2, 3))"]}, "execution_count": 70, "metadata": {}, "output_type": "execute_result"}], "source": ["my_func.__code__.co_consts"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see, the mutable list `[1, 2, 3]` was converted to an immutable tuple. \n", "\n", "It is OK to do this here, since we are testing membership of the list **at that point in time**, hence it is safe to convert it to a tuple, which is more efficient than testing membership of a list."]}, {"cell_type": "markdown", "metadata": {}, "source": ["In the same way, set membership will be converted to frozen set membership:"]}, {"cell_type": "code", "execution_count": 22, "metadata": {"collapsed": true}, "outputs": [], "source": ["def my_func():\n", "    if e in {1, 2, 3}:\n", "        pass"]}, {"cell_type": "code", "execution_count": 23, "metadata": {}, "outputs": [{"data": {"text/plain": ["(None, 1, 2, 3, frozenset({1, 2, 3}))"]}, "execution_count": 23, "metadata": {}, "output_type": "execute_result"}], "source": ["my_func.__code__.co_consts"]}, {"cell_type": "markdown", "metadata": {}, "source": ["In general, when you are writing your code, if you can use **set** membership testing, prefer that over a list or tuple - it is quite a bit more efficient.\n", "\n", "Let's do a small quick (and dirty) benchmark of this:"]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']\n", "\n", "('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z')\n", "\n", "{'l', 'p', 'x', 'R', 'j', 'S', 's', 'T', 'W', 'Y', 'Z', 'P', 'g', 'O', 'b', 'u', 'H', 'G', 'v', 'e', 'M', 'n', 'w', 't', 'Q', 'E', 'N', 'X', 'C', 'i', 'A', 'B', 'F', 'V', 'a', 'm', 'r', 'f', 'h', 'U', 'D', 'c', 'y', 'z', 'J', 'd', 'o', 'I', 'L', 'K', 'k', 'q'}\n"]}], "source": ["import string\n", "import time \n", "\n", "char_list = list(string.ascii_letters)\n", "char_tuple = tuple(string.ascii_letters)\n", "char_set = set(string.ascii_letters)\n", "\n", "print(char_list)\n", "print()\n", "print(char_tuple)\n", "print()\n", "print(char_set)"]}, {"cell_type": "code", "execution_count": 6, "metadata": {"collapsed": true}, "outputs": [], "source": ["def membership_test(n, container):\n", "    for i in range(n):\n", "        if 'p' in container:\n", "            pass"]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["list membership:  2.6035404184015434\n"]}], "source": ["start = time.perf_counter()\n", "membership_test(10000000, char_list)\n", "end = time.perf_counter()\n", "print('list membership: ', end-start)"]}, {"cell_type": "code", "execution_count": 8, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["tuple membership:  2.602491734651276\n"]}], "source": ["start = time.perf_counter()\n", "membership_test(10000000, char_tuple)\n", "end = time.perf_counter()\n", "print('tuple membership: ', end-start)"]}, {"cell_type": "code", "execution_count": 9, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["set membership:  0.3743007599607324\n"]}], "source": ["start = time.perf_counter()\n", "membership_test(10000000, char_set)\n", "end = time.perf_counter()\n", "print('set membership: ', end-start)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see, set membership tests run quite a bit faster - which is not surprising since they are basically dictionary-like objects, so hash maps are used for looking up an item to determine membership."]}, {"cell_type": "markdown", "metadata": {}, "source": ["## Integers"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Integers are objects - instances of the ``int`` class."]}, {"cell_type": "code", "execution_count": 1, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["<class 'int'>\n"]}], "source": ["print(type(100))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["They are a variable length data type that can theoretically handle any integer magnitude. This will take up a variable amount of memory that depends on the particular size of the integer."]}, {"cell_type": "code", "execution_count": 2, "metadata": {"collapsed": true}, "outputs": [], "source": ["import sys"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Creating an integer object requires an overhead of 24 bytes:"]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [{"data": {"text/plain": ["24"]}, "execution_count": 3, "metadata": {}, "output_type": "execute_result"}], "source": ["sys.getsizeof(0)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Here we see that to store the number 1 required 4 bytes (32 bits) on top of the 24 byte overhead:"]}, {"cell_type": "code", "execution_count": 4, "metadata": {"scrolled": true}, "outputs": [{"data": {"text/plain": ["28"]}, "execution_count": 4, "metadata": {}, "output_type": "execute_result"}], "source": ["sys.getsizeof(1)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Larger numbers will require more storage space:"]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"data": {"text/plain": ["160"]}, "execution_count": 5, "metadata": {}, "output_type": "execute_result"}], "source": ["sys.getsizeof(2**1000)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Larger integers will also slow down calculations."]}, {"cell_type": "code", "execution_count": 6, "metadata": {"collapsed": true}, "outputs": [], "source": ["import time"]}, {"cell_type": "code", "execution_count": 7, "metadata": {"collapsed": true}, "outputs": [], "source": ["def calc(a):\n", "    for i in range(10000000):\n", "        a * 2"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We start with a small integer value for a (10):"]}, {"cell_type": "code", "execution_count": 8, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["0.3565246949777869\n"]}], "source": ["start = time.perf_counter()\n", "calc(10)\n", "end = time.perf_counter()\n", "print(end - start)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now we set a to something larger (2<sup>100</sup>):"]}, {"cell_type": "code", "execution_count": 9, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["0.6125349575326144\n"]}], "source": ["start = time.perf_counter()\n", "calc(2**100)\n", "end = time.perf_counter()\n", "print(end - start)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Finally we set a to some really large value (2<sup>10,000</sup>):"]}, {"cell_type": "code", "execution_count": 10, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["5.023413039975091\n"]}], "source": ["start = time.perf_counter()\n", "calc(2**10000)\n", "end = time.perf_counter()\n", "print(end - start)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["## Integers - Operations"]}, {"cell_type": "markdown", "metadata": {"collapsed": true}, "source": ["Addition, subtraction, multiplication and exponentiation of integers always result in an integer. (In the case of exponentiation this holds only for positive integer exponents.)"]}, {"cell_type": "code", "execution_count": 1, "metadata": {}, "outputs": [{"data": {"text/plain": ["int"]}, "execution_count": 1, "metadata": {}, "output_type": "execute_result"}], "source": ["type(2 + 3)"]}, {"cell_type": "code", "execution_count": 2, "metadata": {}, "outputs": [{"data": {"text/plain": ["int"]}, "execution_count": 2, "metadata": {}, "output_type": "execute_result"}], "source": ["type(3 - 10)"]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [{"data": {"text/plain": ["int"]}, "execution_count": 3, "metadata": {}, "output_type": "execute_result"}], "source": ["type(3 * 5)"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"data": {"text/plain": ["int"]}, "execution_count": 4, "metadata": {}, "output_type": "execute_result"}], "source": ["type(3 ** 4)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But the standard division operator `/` **always** results in a float value."]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"data": {"text/plain": ["float"]}, "execution_count": 5, "metadata": {}, "output_type": "execute_result"}], "source": ["type(2 / 3)"]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [{"data": {"text/plain": ["float"]}, "execution_count": 6, "metadata": {}, "output_type": "execute_result"}], "source": ["type(10 / 2)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The `math.floor()` method will return the floor of any number."]}, {"cell_type": "code", "execution_count": 7, "metadata": {"collapsed": true}, "outputs": [], "source": ["import math"]}, {"cell_type": "markdown", "metadata": {}, "source": ["For non-negative values (>= 0), the floor of the value is the same as the integer portion of the value (truncation)"]}, {"cell_type": "code", "execution_count": 8, "metadata": {}, "outputs": [{"data": {"text/plain": ["3"]}, "execution_count": 8, "metadata": {}, "output_type": "execute_result"}], "source": ["math.floor(3.15)"]}, {"cell_type": "code", "execution_count": 9, "metadata": {}, "outputs": [{"data": {"text/plain": ["3"]}, "execution_count": 9, "metadata": {}, "output_type": "execute_result"}], "source": ["math.floor(3.9999999)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["However, this is not the case for negative values:"]}, {"cell_type": "code", "execution_count": 10, "metadata": {}, "outputs": [{"data": {"text/plain": ["-4"]}, "execution_count": 10, "metadata": {}, "output_type": "execute_result"}], "source": ["math.floor(-3.15)"]}, {"cell_type": "code", "execution_count": 11, "metadata": {}, "outputs": [{"data": {"text/plain": ["-4"]}, "execution_count": 11, "metadata": {}, "output_type": "execute_result"}], "source": ["math.floor(-3.0000001)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### The Floor Division Operator"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The floor division operator `a//b` is the floor of `a / b`\n", "\n", "i.e. `a // b = math.floor(a / b)`\n", "\n", "This is true whether `a` and `b` are positive or negative."]}, {"cell_type": "code", "execution_count": 12, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["2.0625\n", "2\n", "2\n"]}], "source": ["a = 33\n", "b = 16\n", "print(a/b)\n", "print(a//b)\n", "print(math.floor(a/b))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["For positive numbers, `a//b` is basically the same as truncating (taking the integer portion) of `a / b`."]}, {"cell_type": "markdown", "metadata": {}, "source": ["But this is **not** the case for negative numbers."]}, {"cell_type": "code", "execution_count": 13, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["-33/16 = -2.0625\n", "trunc(-33/16) = -2\n", "-33//16 = -3\n", "floor(-33//16) = -3\n"]}], "source": ["a = -33\n", "b = 16\n", "print('{0}/{1} = {2}'.format(a, b, a/b))\n", "print('trunc({0}/{1}) = {2}'.format(a, b, math.trunc(a/b)))\n", "print('{0}//{1} = {2}'.format(a, b, a//b))\n", "print('floor({0}//{1}) = {2}'.format(a, b, math.floor(a/b)))"]}, {"cell_type": "code", "execution_count": 14, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["33/-16 = -2.0625\n", "trunc(33/-16) = -2\n", "33//-16 = -3\n", "floor(33//-16) = -3\n"]}], "source": ["a = 33\n", "b = -16\n", "print('{0}/{1} = {2}'.format(a, b, a/b))\n", "print('trunc({0}/{1}) = {2}'.format(a, b, math.trunc(a/b)))\n", "print('{0}//{1} = {2}'.format(a, b, a//b))\n", "print('floor({0}//{1}) = {2}'.format(a, b, math.floor(a/b)))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### The Modulo Operator"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The modulo operator and the floor division operator will always satisfy the following equation:\n", "\n", "``a = b * (a // b) + a % b``"]}, {"cell_type": "code", "execution_count": 15, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["13/4 = 3.25\n", "13//4 = 3\n", "13%4 = 1\n", "True\n"]}], "source": ["a = 13\n", "b = 4\n", "print('{0}/{1} = {2}'.format(a, b, a/b))\n", "print('{0}//{1} = {2}'.format(a, b, a//b))\n", "print('{0}%{1} = {2}'.format(a, b, a%b))\n", "print(a == b * (a//b) + a%b)"]}, {"cell_type": "code", "execution_count": 16, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["-13/4 = -3.25\n", "-13//4 = -4\n", "-13%4 = 3\n", "True\n"]}], "source": ["a = -13\n", "b = 4\n", "print('{0}/{1} = {2}'.format(a, b, a/b))\n", "print('{0}//{1} = {2}'.format(a, b, a//b))\n", "print('{0}%{1} = {2}'.format(a, b, a%b))\n", "print(a == b * (a//b) + a%b)"]}, {"cell_type": "code", "execution_count": 17, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["13/-4 = -3.25\n", "13//-4 = -4\n", "13%-4 = -3\n", "True\n"]}], "source": ["a = 13\n", "b = -4\n", "print('{0}/{1} = {2}'.format(a, b, a/b))\n", "print('{0}//{1} = {2}'.format(a, b, a//b))\n", "print('{0}%{1} = {2}'.format(a, b, a%b))\n", "print(a == b * (a//b) + a%b)"]}, {"cell_type": "code", "execution_count": 18, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["-13/-4 = 3.25\n", "-13//-4 = 3\n", "-13%-4 = -1\n", "True\n"]}], "source": ["a = -13\n", "b = -4\n", "print('{0}/{1} = {2}'.format(a, b, a/b))\n", "print('{0}//{1} = {2}'.format(a, b, a//b))\n", "print('{0}%{1} = {2}'.format(a, b, a%b))\n", "print(a == b * (a//b) + a%b)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["## Integers - Constructors and Bases"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Constructors"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The ``int`` class has two constructors"]}, {"cell_type": "code", "execution_count": 15, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Help on class int in module builtins:\n", "\n", "class int(object)\n", " |  int(x=0) -> integer\n", " |  int(x, base=10) -> integer\n", " |  \n", " |  Convert a number or string to an integer, or return 0 if no arguments\n", " |  are given.  If x is a number, return x.__int__().  For floating point\n", " |  numbers, this truncates towards zero.\n", " |  \n", " |  If x is not a number or if base is given, then x must be a string,\n", " |  bytes, or bytearray instance representing an integer literal in the\n", " |  given base.  The literal can be preceded by '+' or '-' and be surrounded\n", " |  by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\n", " |  Base 0 means to interpret the base from the string as an integer literal.\n", " |  >>> int('0b100', base=0)\n", " |  4\n", " |  \n", " |  Methods defined here:\n", " |  \n", " |  __abs__(self, /)\n", " |      abs(self)\n", " |  \n", " |  __add__(self, value, /)\n", " |      Return self+value.\n", " |  \n", " |  __and__(self, value, /)\n", " |      Return self&value.\n", " |  \n", " |  __bool__(self, /)\n", " |      self != 0\n", " |  \n", " |  __ceil__(...)\n", " |      Ceiling of an Integral returns itself.\n", " |  \n", " |  __divmod__(self, value, /)\n", " |      Return divmod(self, value).\n", " |  \n", " |  __eq__(self, value, /)\n", " |      Return self==value.\n", " |  \n", " |  __float__(self, /)\n", " |      float(self)\n", " |  \n", " |  __floor__(...)\n", " |      Flooring an Integral returns itself.\n", " |  \n", " |  __floordiv__(self, value, /)\n", " |      Return self//value.\n", " |  \n", " |  __format__(...)\n", " |      default object formatter\n", " |  \n", " |  __ge__(self, value, /)\n", " |      Return self>=value.\n", " |  \n", " |  __getattribute__(self, name, /)\n", " |      Return getattr(self, name).\n", " |  \n", " |  __getnewargs__(...)\n", " |  \n", " |  __gt__(self, value, /)\n", " |      Return self>value.\n", " |  \n", " |  __hash__(self, /)\n", " |      Return hash(self).\n", " |  \n", " |  __index__(self, /)\n", " |      Return self converted to an integer, if self is suitable for use as an index into a list.\n", " |  \n", " |  __int__(self, /)\n", " |      int(self)\n", " |  \n", " |  __invert__(self, /)\n", " |      ~self\n", " |  \n", " |  __le__(self, value, /)\n", " |      Return self<=value.\n", " |  \n", " |  __lshift__(self, value, /)\n", " |      Return self<<value.\n", " |  \n", " |  __lt__(self, value, /)\n", " |      Return self<value.\n", " |  \n", " |  __mod__(self, value, /)\n", " |      Return self%value.\n", " |  \n", " |  __mul__(self, value, /)\n", " |      Return self*value.\n", " |  \n", " |  __ne__(self, value, /)\n", " |      Return self!=value.\n", " |  \n", " |  __neg__(self, /)\n", " |      -self\n", " |  \n", " |  __new__(*args, **kwargs) from builtins.type\n", " |      Create and return a new object.  See help(type) for accurate signature.\n", " |  \n", " |  __or__(self, value, /)\n", " |      Return self|value.\n", " |  \n", " |  __pos__(self, /)\n", " |      +self\n", " |  \n", " |  __pow__(self, value, mod=None, /)\n", " |      Return pow(self, value, mod).\n", " |  \n", " |  __radd__(self, value, /)\n", " |      Return value+self.\n", " |  \n", " |  __rand__(self, value, /)\n", " |      Return value&self.\n", " |  \n", " |  __rdivmod__(self, value, /)\n", " |      Return divmod(value, self).\n", " |  \n", " |  __repr__(self, /)\n", " |      Return repr(self).\n", " |  \n", " |  __rfloordiv__(self, value, /)\n", " |      Return value//self.\n", " |  \n", " |  __rlshift__(self, value, /)\n", " |      Return value<<self.\n", " |  \n", " |  __rmod__(self, value, /)\n", " |      Return value%self.\n", " |  \n", " |  __rmul__(self, value, /)\n", " |      Return value*self.\n", " |  \n", " |  __ror__(self, value, /)\n", " |      Return value|self.\n", " |  \n", " |  __round__(...)\n", " |      Rounding an Integral returns itself.\n", " |      Rounding with an ndigits argument also returns an integer.\n", " |  \n", " |  __rpow__(self, value, mod=None, /)\n", " |      Return pow(value, self, mod).\n", " |  \n", " |  __rrshift__(self, value, /)\n", " |      Return value>>self.\n", " |  \n", " |  __rshift__(self, value, /)\n", " |      Return self>>value.\n", " |  \n", " |  __rsub__(self, value, /)\n", " |      Return value-self.\n", " |  \n", " |  __rtruediv__(self, value, /)\n", " |      Return value/self.\n", " |  \n", " |  __rxor__(self, value, /)\n", " |      Return value^self.\n", " |  \n", " |  __sizeof__(...)\n", " |      Returns size in memory, in bytes\n", " |  \n", " |  __str__(self, /)\n", " |      Return str(self).\n", " |  \n", " |  __sub__(self, value, /)\n", " |      Return self-value.\n", " |  \n", " |  __truediv__(self, value, /)\n", " |      Return self/value.\n", " |  \n", " |  __trunc__(...)\n", " |      Truncating an Integral returns itself.\n", " |  \n", " |  __xor__(self, value, /)\n", " |      Return self^value.\n", " |  \n", " |  bit_length(...)\n", " |      int.bit_length() -> int\n", " |      \n", " |      Number of bits necessary to represent self in binary.\n", " |      >>> bin(37)\n", " |      '0b100101'\n", " |      >>> (37).bit_length()\n", " |      6\n", " |  \n", " |  conjugate(...)\n", " |      Returns self, the complex conjugate of any int.\n", " |  \n", " |  from_bytes(...) from builtins.type\n", " |      int.from_bytes(bytes, byteorder, *, signed=False) -> int\n", " |      \n", " |      Return the integer represented by the given array of bytes.\n", " |      \n", " |      The bytes argument must be a bytes-like object (e.g. bytes or bytearray).\n", " |      \n", " |      The byteorder argument determines the byte order used to represent the\n", " |      integer.  If byteorder is 'big', the most significant byte is at the\n", " |      beginning of the byte array.  If byteorder is 'little', the most\n", " |      significant byte is at the end of the byte array.  To request the native\n", " |      byte order of the host system, use `sys.byteorder' as the byte order value.\n", " |      \n", " |      The signed keyword-only argument indicates whether two's complement is\n", " |      used to represent the integer.\n", " |  \n", " |  to_bytes(...)\n", " |      int.to_bytes(length, byteorder, *, signed=False) -> bytes\n", " |      \n", " |      Return an array of bytes representing an integer.\n", " |      \n", " |      The integer is represented using length bytes.  An OverflowError is\n", " |      raised if the integer is not representable with the given number of\n", " |      bytes.\n", " |      \n", " |      The byteorder argument determines the byte order used to represent the\n", " |      integer.  If byteorder is 'big', the most significant byte is at the\n", " |      beginning of the byte array.  If byteorder is 'little', the most\n", " |      significant byte is at the end of the byte array.  To request the native\n", " |      byte order of the host system, use `sys.byteorder' as the byte order value.\n", " |      \n", " |      The signed keyword-only argument determines whether two's complement is\n", " |      used to represent the integer.  If signed is False and a negative integer\n", " |      is given, an OverflowError is raised.\n", " |  \n", " |  ----------------------------------------------------------------------\n", " |  Data descriptors defined here:\n", " |  \n", " |  denominator\n", " |      the denominator of a rational number in lowest terms\n", " |  \n", " |  imag\n", " |      the imaginary part of a complex number\n", " |  \n", " |  numerator\n", " |      the numerator of a rational number in lowest terms\n", " |  \n", " |  real\n", " |      the real part of a complex number\n", "\n"]}], "source": ["help(int)"]}, {"cell_type": "code", "execution_count": 16, "metadata": {}, "outputs": [{"data": {"text/plain": ["10"]}, "execution_count": 16, "metadata": {}, "output_type": "execute_result"}], "source": ["int(10)"]}, {"cell_type": "code", "execution_count": 17, "metadata": {}, "outputs": [{"data": {"text/plain": ["10"]}, "execution_count": 17, "metadata": {}, "output_type": "execute_result"}], "source": ["int(10.9)"]}, {"cell_type": "code", "execution_count": 18, "metadata": {}, "outputs": [{"data": {"text/plain": ["-10"]}, "execution_count": 18, "metadata": {}, "output_type": "execute_result"}], "source": ["int(-10.9)"]}, {"cell_type": "code", "execution_count": 19, "metadata": {"collapsed": true}, "outputs": [], "source": ["from fractions import Fraction"]}, {"cell_type": "code", "execution_count": 20, "metadata": {"collapsed": true}, "outputs": [], "source": ["a = Fraction(22, 7)"]}, {"cell_type": "code", "execution_count": 21, "metadata": {}, "outputs": [{"data": {"text/plain": ["Fraction(22, 7)"]}, "execution_count": 21, "metadata": {}, "output_type": "execute_result"}], "source": ["a"]}, {"cell_type": "code", "execution_count": 22, "metadata": {}, "outputs": [{"data": {"text/plain": ["3"]}, "execution_count": 22, "metadata": {}, "output_type": "execute_result"}], "source": ["int(a)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can use the second constructor to generate integers (base 10) from strings in any base."]}, {"cell_type": "code", "execution_count": 23, "metadata": {}, "outputs": [{"data": {"text/plain": ["10"]}, "execution_count": 23, "metadata": {}, "output_type": "execute_result"}], "source": ["int(\"10\")"]}, {"cell_type": "code", "execution_count": 24, "metadata": {}, "outputs": [{"data": {"text/plain": ["5"]}, "execution_count": 24, "metadata": {}, "output_type": "execute_result"}], "source": ["int(\"101\", 2)"]}, {"cell_type": "code", "execution_count": 25, "metadata": {}, "outputs": [{"data": {"text/plain": ["5"]}, "execution_count": 25, "metadata": {}, "output_type": "execute_result"}], "source": ["int(\"101\", base=2)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Python uses ``a-z`` for bases from 11 to 36."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Note that the letters are not case sensitive."]}, {"cell_type": "code", "execution_count": 26, "metadata": {}, "outputs": [{"data": {"text/plain": ["3866"]}, "execution_count": 26, "metadata": {}, "output_type": "execute_result"}], "source": ["int(\"F1A\", base=16)"]}, {"cell_type": "code", "execution_count": 27, "metadata": {}, "outputs": [{"data": {"text/plain": ["3866"]}, "execution_count": 27, "metadata": {}, "output_type": "execute_result"}], "source": ["int(\"f1a\", base=16)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Of course, the string must be a valid number in whatever base you specify."]}, {"cell_type": "code", "execution_count": 28, "metadata": {}, "outputs": [{"ename": "ValueError", "evalue": "invalid literal for int() with base 11: 'B1A'", "output_type": "error", "traceback": ["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[1;31mValueError\u001b[0m                                Traceback (most recent call last)", "\u001b[1;32m<ipython-input-28-d0cf8657e90a>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[1;32m----> 1\u001b[1;33m \u001b[0mint\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34m'B1A'\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mbase\u001b[0m\u001b[1;33m=\u001b[0m\u001b[1;36m11\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m", "\u001b[1;31mValueError\u001b[0m: invalid literal for int() with base 11: 'B1A'"]}], "source": ["int('B1A', base=11)"]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": ["int('B1A', 12)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Base Representations"]}, {"cell_type": "markdown", "metadata": {}, "source": ["##### Built-ins"]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": ["bin(10)"]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": ["oct(10)"]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": ["hex(10)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Note the `0b`, `0o` and `0x` prefixes"]}, {"cell_type": "markdown", "metadata": {}, "source": ["You can use these in your own strings as well, and they correspond to prefixes used in integer literals as well."]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": ["a = int('1010', 2)\n", "b = int('0b1010', 2)\n", "c = 0b1010"]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": ["print(a, b, c)"]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": ["a = int('f1a', 16)\n", "b = int('0xf1a', 16)\n", "c = 0xf1a"]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": ["print(a, b, c)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["For literals, the ``a-z`` characters are not case-sensitive either"]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": ["a = 0xf1a\n", "b = 0xF1a\n", "c = 0xF1A"]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": ["print(a, b, c)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Custom Rebasing"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Python only provides built-in function to rebase to base 2, 8 and 16.\n", "\n", "For other bases, you have to provide your own algorithm (or leverage some 3rd party library of your choice)"]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": ["def from_base10(n, b):\n", "    if b < 2:\n", "        raise ValueError('Base b must be >= 2')\n", "    if n < 0:\n", "        raise ValueError('Number n must be >= 0')\n", "    if n == 0:\n", "        return [0]\n", "    digits = []\n", "    while n > 0:\n", "        # m = n % b\n", "        # n = n // b\n", "        # which is the same as:\n", "        n, m = divmod(n, b)\n", "        digits.insert(0, m)\n", "    return digits"]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": ["from_base10(10, 2)"]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": ["from_base10(255, 16)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Next we may want to encode the digits into strings using different characters for each digit in the base"]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": ["def encode(digits, digit_map):\n", "    # we require that digit_map has at least as many\n", "    # characters as the max number in digits\n", "    if max(digits) >= len(digit_map):\n", "        raise ValueError(\"digit_map is not long enough to encode digits\")\n", "    \n", "    # we'll see this later, but the following would be better:\n", "    encoding = ''.join([digit_map[d] for d in digits])\n", "    return encoding\n", "    "]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now we can encode any list of digits:"]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": ["encode([1, 0, 1], \"FT\")"]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": ["encode([1, 10, 11], '0123456789AB')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["And we can combine both functions into a single one for easier use:"]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": ["def rebase_from10(number, base):\n", "    digit_map = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n", "    if base < 2 or base > 36:\n", "        raise ValueError('Invalid base: 2 <= base <= 36')\n", "    # we store the sign of number and make it positive\n", "    # we'll re-insert the sign at the end\n", "    sign = -1 if number < 0 else 1\n", "    number *= sign\n", "    \n", "    digits = from_base10(number, base)\n", "    encoding = encode(digits, digit_map)\n", "    if sign == -1:\n", "        encoding = '-' + encoding\n", "    return encoding"]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": ["e = rebase_from10(10, 2)\n", "print(e)\n", "print(int(e, 2))"]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": ["e = rebase_from10(-10, 2)\n", "print(e)\n", "print(int(e, 2))"]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": ["rebase_from10(131, 11)"]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": ["rebase_from10(4095, 16)"]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": ["rebase_from10(-4095, 16)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["## Rational Numbers"]}, {"cell_type": "code", "execution_count": 1, "metadata": {"collapsed": true}, "outputs": [], "source": ["from fractions import Fraction"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can get some info on the Fraction class:"]}, {"cell_type": "code", "execution_count": 2, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Help on class Fraction in module fractions:\n", "\n", "class Fraction(numbers.Rational)\n", " |  This class implements rational numbers.\n", " |  \n", " |  In the two-argument form of the constructor, Fraction(8, 6) will\n", " |  produce a rational number equivalent to 4/3. Both arguments must\n", " |  be Rational. The numerator defaults to 0 and the denominator\n", " |  defaults to 1 so that Fraction(3) == 3 and Fraction() == 0.\n", " |  \n", " |  Fractions can also be constructed from:\n", " |  \n", " |    - numeric strings similar to those accepted by the\n", " |      float constructor (for example, '-2.3' or '1e10')\n", " |  \n", " |    - strings of the form '123/456'\n", " |  \n", " |    - float and Decimal instances\n", " |  \n", " |    - other Rational instances (including integers)\n", " |  \n", " |  Method resolution order:\n", " |      Fraction\n", " |      numbers.Rational\n", " |      numbers.Real\n", " |      numbers.Complex\n", " |      numbers.Number\n", " |      builtins.object\n", " |  \n", " |  Methods defined here:\n", " |  \n", " |  __abs__(a)\n", " |      abs(a)\n", " |  \n", " |  __add__(a, b)\n", " |      a + b\n", " |  \n", " |  __bool__(a)\n", " |      a != 0\n", " |  \n", " |  __ceil__(a)\n", " |      Will be math.ceil(a) in 3.0.\n", " |  \n", " |  __copy__(self)\n", " |  \n", " |  __deepcopy__(self, memo)\n", " |  \n", " |  __eq__(a, b)\n", " |      a == b\n", " |  \n", " |  __floor__(a)\n", " |      Will be math.floor(a) in 3.0.\n", " |  \n", " |  __floordiv__(a, b)\n", " |      a // b\n", " |  \n", " |  __ge__(a, b)\n", " |      a >= b\n", " |  \n", " |  __gt__(a, b)\n", " |      a > b\n", " |  \n", " |  __hash__(self)\n", " |      hash(self)\n", " |  \n", " |  __le__(a, b)\n", " |      a <= b\n", " |  \n", " |  __lt__(a, b)\n", " |      a < b\n", " |  \n", " |  __mod__(a, b)\n", " |      a % b\n", " |  \n", " |  __mul__(a, b)\n", " |      a * b\n", " |  \n", " |  __neg__(a)\n", " |      -a\n", " |  \n", " |  __pos__(a)\n", " |      +a: Coerces a subclass instance to Fraction\n", " |  \n", " |  __pow__(a, b)\n", " |      a ** b\n", " |      \n", " |      If b is not an integer, the result will be a float or complex\n", " |      since roots are generally irrational. If b is an integer, the\n", " |      result will be rational.\n", " |  \n", " |  __radd__(b, a)\n", " |      a + b\n", " |  \n", " |  __reduce__(self)\n", " |      helper for pickle\n", " |  \n", " |  __repr__(self)\n", " |      repr(self)\n", " |  \n", " |  __rfloordiv__(b, a)\n", " |      a // b\n", " |  \n", " |  __rmod__(b, a)\n", " |      a % b\n", " |  \n", " |  __rmul__(b, a)\n", " |      a * b\n", " |  \n", " |  __round__(self, ndigits=None)\n", " |      Will be round(self, ndigits) in 3.0.\n", " |      \n", " |      Rounds half toward even.\n", " |  \n", " |  __rpow__(b, a)\n", " |      a ** b\n", " |  \n", " |  __rsub__(b, a)\n", " |      a - b\n", " |  \n", " |  __rtruediv__(b, a)\n", " |      a / b\n", " |  \n", " |  __str__(self)\n", " |      str(self)\n", " |  \n", " |  __sub__(a, b)\n", " |      a - b\n", " |  \n", " |  __truediv__(a, b)\n", " |      a / b\n", " |  \n", " |  __trunc__(a)\n", " |      trunc(a)\n", " |  \n", " |  limit_denominator(self, max_denominator=1000000)\n", " |      Closest Fraction to self with denominator at most max_denominator.\n", " |      \n", " |      >>> Fraction('3.141592653589793').limit_denominator(10)\n", " |      Fraction(22, 7)\n", " |      >>> Fraction('3.141592653589793').limit_denominator(100)\n", " |      Fraction(311, 99)\n", " |      >>> Fraction(4321, 8765).limit_denominator(10000)\n", " |      Fraction(4321, 8765)\n", " |  \n", " |  ----------------------------------------------------------------------\n", " |  Class methods defined here:\n", " |  \n", " |  from_decimal(dec) from abc.ABCMeta\n", " |      Converts a finite Decimal instance to a rational number, exactly.\n", " |  \n", " |  from_float(f) from abc.ABCMeta\n", " |      Converts a finite float to a rational number, exactly.\n", " |      \n", " |      Beware that Fraction.from_float(0.3) != Fraction(3, 10).\n", " |  \n", " |  ----------------------------------------------------------------------\n", " |  Static methods defined here:\n", " |  \n", " |  __new__(cls, numerator=0, denominator=None, *, _normalize=True)\n", " |      Constructs a Rational.\n", " |      \n", " |      Takes a string like '3/2' or '1.5', another Rational instance, a\n", " |      numerator/denominator pair, or a float.\n", " |      \n", " |      Examples\n", " |      --------\n", " |      \n", " |      >>> Fraction(10, -8)\n", " |      Fraction(-5, 4)\n", " |      >>> Fraction(Fraction(1, 7), 5)\n", " |      Fraction(1, 35)\n", " |      >>> Fraction(Fraction(1, 7), Fraction(2, 3))\n", " |      Fraction(3, 14)\n", " |      >>> Fraction('314')\n", " |      Fraction(314, 1)\n", " |      >>> Fraction('-35/4')\n", " |      Fraction(-35, 4)\n", " |      >>> Fraction('3.1415') # conversion from numeric string\n", " |      Fraction(6283, 2000)\n", " |      >>> Fraction('-47e-2') # string may include a decimal exponent\n", " |      Fraction(-47, 100)\n", " |      >>> Fraction(1.47)  # direct construction from float (exact conversion)\n", " |      Fraction(6620291452234629, 4503599627370496)\n", " |      >>> Fraction(2.25)\n", " |      Fraction(9, 4)\n", " |      >>> Fraction(Decimal('1.47'))\n", " |      Fraction(147, 100)\n", " |  \n", " |  ----------------------------------------------------------------------\n", " |  Data descriptors defined here:\n", " |  \n", " |  denominator\n", " |  \n", " |  numerator\n", " |  \n", " |  ----------------------------------------------------------------------\n", " |  Data and other attributes defined here:\n", " |  \n", " |  __abstractmethods__ = frozenset()\n", " |  \n", " |  ----------------------------------------------------------------------\n", " |  Methods inherited from numbers.Rational:\n", " |  \n", " |  __float__(self)\n", " |      float(self) = self.numerator / self.denominator\n", " |      \n", " |      It's important that this conversion use the integer's \"true\"\n", " |      division rather than casting one side to float before dividing\n", " |      so that ratios of huge integers convert without overflowing.\n", " |  \n", " |  ----------------------------------------------------------------------\n", " |  Methods inherited from numbers.Real:\n", " |  \n", " |  __complex__(self)\n", " |      complex(self) == complex(float(self), 0)\n", " |  \n", " |  __divmod__(self, other)\n", " |      divmod(self, other): The pair (self // other, self % other).\n", " |      \n", " |      Sometimes this can be computed faster than the pair of\n", " |      operations.\n", " |  \n", " |  __rdivmod__(self, other)\n", " |      divmod(other, self): The pair (self // other, self % other).\n", " |      \n", " |      Sometimes this can be computed faster than the pair of\n", " |      operations.\n", " |  \n", " |  conjugate(self)\n", " |      Conjugate is a no-op for Reals.\n", " |  \n", " |  ----------------------------------------------------------------------\n", " |  Data descriptors inherited from numbers.Real:\n", " |  \n", " |  imag\n", " |      Real numbers have no imaginary component.\n", " |  \n", " |  real\n", " |      Real numbers are their real component.\n", "\n"]}], "source": ["help(Fraction)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can create Fraction objects in a variety of ways:"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Using integers:"]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [{"data": {"text/plain": ["Fraction(1, 1)"]}, "execution_count": 3, "metadata": {}, "output_type": "execute_result"}], "source": ["Fraction(1)"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"data": {"text/plain": ["Fraction(1, 3)"]}, "execution_count": 4, "metadata": {}, "output_type": "execute_result"}], "source": ["Fraction(1, 3)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Using rational numbers:"]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"data": {"text/plain": ["Fraction(8, 9)"]}, "execution_count": 5, "metadata": {}, "output_type": "execute_result"}], "source": ["x = Fraction(2, 3)\n", "y = Fraction(3, 4)\n", "# 2/3 / 3/4 --> 2/3 * 4/3 --> 8/9\n", "Fraction(x, y)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Using floats:"]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [{"data": {"text/plain": ["Fraction(1, 8)"]}, "execution_count": 6, "metadata": {}, "output_type": "execute_result"}], "source": ["Fraction(0.125)"]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"data": {"text/plain": ["Fraction(1, 2)"]}, "execution_count": 7, "metadata": {}, "output_type": "execute_result"}], "source": ["Fraction(0.5)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Using strings:"]}, {"cell_type": "code", "execution_count": 8, "metadata": {}, "outputs": [{"data": {"text/plain": ["Fraction(21, 2)"]}, "execution_count": 8, "metadata": {}, "output_type": "execute_result"}], "source": ["Fraction('10.5')"]}, {"cell_type": "code", "execution_count": 9, "metadata": {}, "outputs": [{"data": {"text/plain": ["Fraction(22, 7)"]}, "execution_count": 9, "metadata": {}, "output_type": "execute_result"}], "source": ["Fraction('22/7')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Fractions are automatically reduced:"]}, {"cell_type": "code", "execution_count": 10, "metadata": {}, "outputs": [{"data": {"text/plain": ["Fraction(1, 2)"]}, "execution_count": 10, "metadata": {}, "output_type": "execute_result"}], "source": ["Fraction(8, 16)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Negative sign is attached to the numerator:"]}, {"cell_type": "code", "execution_count": 11, "metadata": {}, "outputs": [{"data": {"text/plain": ["Fraction(-1, 4)"]}, "execution_count": 11, "metadata": {}, "output_type": "execute_result"}], "source": ["Fraction(1, -4)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Standard arithmetic operators are supported:"]}, {"cell_type": "code", "execution_count": 12, "metadata": {}, "outputs": [{"data": {"text/plain": ["Fraction(1, 1)"]}, "execution_count": 12, "metadata": {}, "output_type": "execute_result"}], "source": ["Fraction(1, 3) + Fraction(1, 3) + Fraction(1, 3)"]}, {"cell_type": "code", "execution_count": 13, "metadata": {}, "outputs": [{"data": {"text/plain": ["Fraction(1, 8)"]}, "execution_count": 13, "metadata": {}, "output_type": "execute_result"}], "source": ["Fraction(1, 2) * Fraction(1, 4)"]}, {"cell_type": "code", "execution_count": 14, "metadata": {}, "outputs": [{"data": {"text/plain": ["Fraction(3, 2)"]}, "execution_count": 14, "metadata": {}, "output_type": "execute_result"}], "source": ["Fraction(1, 2) / Fraction(1, 3)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can recover the numerator and denominator (integers):"]}, {"cell_type": "code", "execution_count": 15, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["22\n", "7\n"]}], "source": ["x = Fraction(22, 7)\n", "print(x.numerator)\n", "print(x.denominator)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Since floats have **finite** precision, any float can be converted to a rational number:"]}, {"cell_type": "code", "execution_count": 16, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["884279719003555/281474976710656\n", "3.141592653589793\n"]}], "source": ["import math\n", "x = Fraction(math.pi)\n", "print(x)\n", "print(float(x))"]}, {"cell_type": "code", "execution_count": 17, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["6369051672525773/4503599627370496\n"]}], "source": ["x = Fraction(math.sqrt(2))\n", "print(x)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Note that these rational values are approximations to the irrational numbers $\\pi$ and $\\sqrt{2}$"]}, {"cell_type": "markdown", "metadata": {}, "source": ["**Beware!!**"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Float number representations (as we will examine in future lessons) do not always have an exact representation."]}, {"cell_type": "markdown", "metadata": {}, "source": ["The number 0.125 (1/8) **has** an exact representation:"]}, {"cell_type": "code", "execution_count": 18, "metadata": {}, "outputs": [{"data": {"text/plain": ["Fraction(1, 8)"]}, "execution_count": 18, "metadata": {}, "output_type": "execute_result"}], "source": ["Fraction(0.125)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["and so we see the expected equivalent fraction.\n", "\n", "But, 0.3 (3/10) does **not** have an exact representation:"]}, {"cell_type": "code", "execution_count": 19, "metadata": {}, "outputs": [{"data": {"text/plain": ["Fraction(3, 10)"]}, "execution_count": 19, "metadata": {}, "output_type": "execute_result"}], "source": ["Fraction(3, 10)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["but"]}, {"cell_type": "code", "execution_count": 20, "metadata": {}, "outputs": [{"data": {"text/plain": ["Fraction(5404319552844595, 18014398509481984)"]}, "execution_count": 20, "metadata": {}, "output_type": "execute_result"}], "source": ["Fraction(0.3)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We will study this in upcoming lessons.\n", "\n", "But for now, let's just see a quick explanation:"]}, {"cell_type": "code", "execution_count": 21, "metadata": {"collapsed": true}, "outputs": [], "source": ["x = 0.3"]}, {"cell_type": "code", "execution_count": 22, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["0.3\n"]}], "source": ["print(x)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Everything looks ok here - why am I saying 0.3 (float) is just an approximation?\n", "\n", "Python is trying to format the displayed value for readability - so it rounds the number for a better display format!\n", "\n", "We can instead choose to display the value using a certain number of digits:"]}, {"cell_type": "code", "execution_count": 23, "metadata": {}, "outputs": [{"data": {"text/plain": ["'0.30000'"]}, "execution_count": 23, "metadata": {}, "output_type": "execute_result"}], "source": ["format(x, '.5f')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["At 5 digits after the decimal, we might still think 0.3 is an exact representation.\n", "\n", "But let's display a few more digits:"]}, {"cell_type": "code", "execution_count": 24, "metadata": {}, "outputs": [{"data": {"text/plain": ["'0.300000000000000'"]}, "execution_count": 24, "metadata": {}, "output_type": "execute_result"}], "source": ["format(x, '.15f')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Hmm... 15 digits and still looking good!\n", "\n", "How about 25 digits..."]}, {"cell_type": "code", "execution_count": 25, "metadata": {}, "outputs": [{"data": {"text/plain": ["'0.2999999999999999888977698'"]}, "execution_count": 25, "metadata": {}, "output_type": "execute_result"}], "source": ["format(x, '.25f')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now we see that **x** is not quite 0.3..."]}, {"cell_type": "markdown", "metadata": {}, "source": ["In fact, we can quantify the delta this way:"]}, {"cell_type": "code", "execution_count": 26, "metadata": {"collapsed": true}, "outputs": [], "source": ["delta = Fraction(0.3) - Fraction(3, 10)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Theoretically, delta should be 0, but it's not:"]}, {"cell_type": "code", "execution_count": 27, "metadata": {}, "outputs": [{"data": {"text/plain": ["False"]}, "execution_count": 27, "metadata": {}, "output_type": "execute_result"}], "source": ["delta == 0"]}, {"cell_type": "code", "execution_count": 28, "metadata": {}, "outputs": [{"data": {"text/plain": ["Fraction(-1, 90071992547409920)"]}, "execution_count": 28, "metadata": {}, "output_type": "execute_result"}], "source": ["delta"]}, {"cell_type": "markdown", "metadata": {}, "source": ["**delta** is a very small number, the above fraction...\n", "\n", "As a float:"]}, {"cell_type": "code", "execution_count": 29, "metadata": {}, "outputs": [{"data": {"text/plain": ["-1.1102230246251566e-17"]}, "execution_count": 29, "metadata": {}, "output_type": "execute_result"}], "source": ["float(delta)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Constraining the denominator"]}, {"cell_type": "code", "execution_count": 30, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["884279719003555/281474976710656\n", "3.1415926535897931159979635\n"]}], "source": ["x = Fraction(math.pi)\n", "print(x)\n", "print(format(float(x), '.25f'))"]}, {"cell_type": "code", "execution_count": 31, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["22/7\n", "3.1428571428571427937015414\n"]}], "source": ["y = x.limit_denominator(10)\n", "print(y)\n", "print(format(float(y), '.25f'))"]}, {"cell_type": "code", "execution_count": 32, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["311/99\n", "3.1414141414141414365701621\n"]}], "source": ["y = x.limit_denominator(100)\n", "print(y)\n", "print(format(float(y), '.25f'))"]}, {"cell_type": "code", "execution_count": 33, "metadata": {"scrolled": true}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["355/113\n", "3.1415929203539825209645642\n"]}], "source": ["y = x.limit_denominator(500)\n", "print(y)\n", "print(format(float(y), '.25f'))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["## Floats - Internal Representation"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The ``float`` class can be used to represent real numbers."]}, {"cell_type": "code", "execution_count": 1, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Help on class float in module builtins:\n", "\n", "class float(object)\n", " |  float(x) -> floating point number\n", " |  \n", " |  Convert a string or number to a floating point number, if possible.\n", " |  \n", " |  Methods defined here:\n", " |  \n", " |  __abs__(self, /)\n", " |      abs(self)\n", " |  \n", " |  __add__(self, value, /)\n", " |      Return self+value.\n", " |  \n", " |  __bool__(self, /)\n", " |      self != 0\n", " |  \n", " |  __divmod__(self, value, /)\n", " |      Return divmod(self, value).\n", " |  \n", " |  __eq__(self, value, /)\n", " |      Return self==value.\n", " |  \n", " |  __float__(self, /)\n", " |      float(self)\n", " |  \n", " |  __floordiv__(self, value, /)\n", " |      Return self//value.\n", " |  \n", " |  __format__(...)\n", " |      float.__format__(format_spec) -> string\n", " |      \n", " |      Formats the float according to format_spec.\n", " |  \n", " |  __ge__(self, value, /)\n", " |      Return self>=value.\n", " |  \n", " |  __getattribute__(self, name, /)\n", " |      Return getattr(self, name).\n", " |  \n", " |  __getformat__(...) from builtins.type\n", " |      float.__getformat__(typestr) -> string\n", " |      \n", " |      You probably don't want to use this function.  It exists mainly to be\n", " |      used in Python's test suite.\n", " |      \n", " |      typestr must be 'double' or 'float'.  This function returns whichever of\n", " |      'unknown', 'IEEE, big-endian' or 'IEEE, little-endian' best describes the\n", " |      format of floating point numbers used by the C type named by typestr.\n", " |  \n", " |  __getnewargs__(...)\n", " |  \n", " |  __gt__(self, value, /)\n", " |      Return self>value.\n", " |  \n", " |  __hash__(self, /)\n", " |      Return hash(self).\n", " |  \n", " |  __int__(self, /)\n", " |      int(self)\n", " |  \n", " |  __le__(self, value, /)\n", " |      Return self<=value.\n", " |  \n", " |  __lt__(self, value, /)\n", " |      Return self<value.\n", " |  \n", " |  __mod__(self, value, /)\n", " |      Return self%value.\n", " |  \n", " |  __mul__(self, value, /)\n", " |      Return self*value.\n", " |  \n", " |  __ne__(self, value, /)\n", " |      Return self!=value.\n", " |  \n", " |  __neg__(self, /)\n", " |      -self\n", " |  \n", " |  __new__(*args, **kwargs) from builtins.type\n", " |      Create and return a new object.  See help(type) for accurate signature.\n", " |  \n", " |  __pos__(self, /)\n", " |      +self\n", " |  \n", " |  __pow__(self, value, mod=None, /)\n", " |      Return pow(self, value, mod).\n", " |  \n", " |  __radd__(self, value, /)\n", " |      Return value+self.\n", " |  \n", " |  __rdivmod__(self, value, /)\n", " |      Return divmod(value, self).\n", " |  \n", " |  __repr__(self, /)\n", " |      Return repr(self).\n", " |  \n", " |  __rfloordiv__(self, value, /)\n", " |      Return value//self.\n", " |  \n", " |  __rmod__(self, value, /)\n", " |      Return value%self.\n", " |  \n", " |  __rmul__(self, value, /)\n", " |      Return value*self.\n", " |  \n", " |  __round__(...)\n", " |      Return the Integral closest to x, rounding half toward even.\n", " |      When an argument is passed, work like built-in round(x, ndigits).\n", " |  \n", " |  __rpow__(self, value, mod=None, /)\n", " |      Return pow(value, self, mod).\n", " |  \n", " |  __rsub__(self, value, /)\n", " |      Return value-self.\n", " |  \n", " |  __rtruediv__(self, value, /)\n", " |      Return value/self.\n", " |  \n", " |  __setformat__(...) from builtins.type\n", " |      float.__setformat__(typestr, fmt) -> None\n", " |      \n", " |      You probably don't want to use this function.  It exists mainly to be\n", " |      used in Python's test suite.\n", " |      \n", " |      typestr must be 'double' or 'float'.  fmt must be one of 'unknown',\n", " |      'IEEE, big-endian' or 'IEEE, little-endian', and in addition can only be\n", " |      one of the latter two if it appears to match the underlying C reality.\n", " |      \n", " |      Override the automatic determination of C-level floating point type.\n", " |      This affects how floats are converted to and from binary strings.\n", " |  \n", " |  __str__(self, /)\n", " |      Return str(self).\n", " |  \n", " |  __sub__(self, value, /)\n", " |      Return self-value.\n", " |  \n", " |  __truediv__(self, value, /)\n", " |      Return self/value.\n", " |  \n", " |  __trunc__(...)\n", " |      Return the Integral closest to x between 0 and x.\n", " |  \n", " |  as_integer_ratio(...)\n", " |      float.as_integer_ratio() -> (int, int)\n", " |      \n", " |      Return a pair of integers, whose ratio is exactly equal to the original\n", " |      float and with a positive denominator.\n", " |      Raise OverflowError on infinities and a ValueError on NaNs.\n", " |      \n", " |      >>> (10.0).as_integer_ratio()\n", " |      (10, 1)\n", " |      >>> (0.0).as_integer_ratio()\n", " |      (0, 1)\n", " |      >>> (-.25).as_integer_ratio()\n", " |      (-1, 4)\n", " |  \n", " |  conjugate(...)\n", " |      Return self, the complex conjugate of any float.\n", " |  \n", " |  fromhex(...) from builtins.type\n", " |      float.fromhex(string) -> float\n", " |      \n", " |      Create a floating-point number from a hexadecimal string.\n", " |      >>> float.fromhex('0x1.ffffp10')\n", " |      2047.984375\n", " |      >>> float.fromhex('-0x1p-1074')\n", " |      -5e-324\n", " |  \n", " |  hex(...)\n", " |      float.hex() -> string\n", " |      \n", " |      Return a hexadecimal representation of a floating-point number.\n", " |      >>> (-0.1).hex()\n", " |      '-0x1.999999999999ap-4'\n", " |      >>> 3.14159.hex()\n", " |      '0x1.921f9f01b866ep+1'\n", " |  \n", " |  is_integer(...)\n", " |      Return True if the float is an integer.\n", " |  \n", " |  ----------------------------------------------------------------------\n", " |  Data descriptors defined here:\n", " |  \n", " |  imag\n", " |      the imaginary part of a complex number\n", " |  \n", " |  real\n", " |      the real part of a complex number\n", "\n"]}], "source": ["help(float)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The ``float`` class has a single constructor, which can take a number or a string and will attempt to convert it to a float."]}, {"cell_type": "code", "execution_count": 2, "metadata": {}, "outputs": [{"data": {"text/plain": ["10.0"]}, "execution_count": 2, "metadata": {}, "output_type": "execute_result"}], "source": ["float(10)"]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [{"data": {"text/plain": ["3.14"]}, "execution_count": 3, "metadata": {}, "output_type": "execute_result"}], "source": ["float(3.14)"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"data": {"text/plain": ["0.1"]}, "execution_count": 4, "metadata": {}, "output_type": "execute_result"}], "source": ["float('0.1')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["However, strings that represent fractions cannot be converted to floats, unlike the Fraction class we saw earlier."]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"ename": "ValueError", "evalue": "could not convert string to float: '22/7'", "output_type": "error", "traceback": ["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[1;31mValueError\u001b[0m                                Traceback (most recent call last)", "\u001b[1;32m<ipython-input-5-32cff4369993>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[1;32m----> 1\u001b[1;33m \u001b[0mfloat\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34m'22/7'\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m", "\u001b[1;31mValueError\u001b[0m: could not convert string to float: '22/7'"]}], "source": ["float('22/7')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["If you really want to get a float from a string such as ``'22/7'``, you could first create a ``Fraction``, then create a ``float`` from that:"]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": ["from fractions import Fraction"]}, {"cell_type": "code", "execution_count": null, "metadata": {}, "outputs": [], "source": ["float(Fraction('22/7'))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Floats do not always have an exact representation:"]}, {"cell_type": "code", "execution_count": null, "metadata": {}, "outputs": [], "source": ["print(0.1)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Although this looks like ``0.1`` exactly, we need to reveal more digits after the decimal point to see what's going on:"]}, {"cell_type": "code", "execution_count": null, "metadata": {}, "outputs": [], "source": ["format(0.1, '.25f')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["However, certain numbers can be represented exactly in a binary fraction expansion:"]}, {"cell_type": "code", "execution_count": null, "metadata": {}, "outputs": [], "source": ["format(0.125, '.25f')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["This is because 0.125 is precisely 1/8, or 1/(2^3)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["## Floats - Equality Testing"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Because not all real numbers have an exact ``float`` representation, equality testing can be tricky."]}, {"cell_type": "code", "execution_count": 1, "metadata": {}, "outputs": [{"data": {"text/plain": ["False"]}, "execution_count": 1, "metadata": {}, "output_type": "execute_result"}], "source": ["x = 0.1 + 0.1 + 0.1\n", "y = 0.3\n", "x == y"]}, {"cell_type": "markdown", "metadata": {}, "source": ["This is because ``0.1`` and ``0.3`` do not have exact representations:"]}, {"cell_type": "code", "execution_count": 2, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["0.1 --> 0.1000000000000000055511151\n", "x --> 0.3000000000000000444089210\n", "y --> 0.2999999999999999888977698\n"]}], "source": ["print('0.1 --> {0:.25f}'.format(0.1))\n", "print('x --> {0:.25f}'.format(x))\n", "print('y --> {0:.25f}'.format(y))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["However, in some (limited) cases where all the numbers involved do have an exact representation, it will work:"]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 3, "metadata": {}, "output_type": "execute_result"}], "source": ["x = 0.125 + 0.125 + 0.125\n", "y = 0.375\n", "x == y"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["0.125 --> 0.1250000000000000000000000\n", "x --> 0.3750000000000000000000000\n", "y --> 0.3750000000000000000000000\n"]}], "source": ["print('0.125 --> {0:.25f}'.format(0.125))\n", "print('x --> {0:.25f}'.format(x))\n", "print('y --> {0:.25f}'.format(y))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["One simple way to get around this is to round to a specific number of digits and then compare"]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 5, "metadata": {}, "output_type": "execute_result"}], "source": ["x = 0.1 + 0.1 + 0.1\n", "y = 0.3\n", "round(x, 5) == round(y, 5)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can also use a more flexible technique implemented by the ``isclose`` method in the ``math`` module"]}, {"cell_type": "code", "execution_count": 6, "metadata": {"collapsed": true}, "outputs": [], "source": ["from math import isclose"]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Help on built-in function isclose in module math:\n", "\n", "isclose(...)\n", "    isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0) -> bool\n", "    \n", "    Determine whether two floating point numbers are close in value.\n", "    \n", "       rel_tol\n", "           maximum difference for being considered \"close\", relative to the\n", "           magnitude of the input values\n", "        abs_tol\n", "           maximum difference for being considered \"close\", regardless of the\n", "           magnitude of the input values\n", "    \n", "    Return True if a is close in value to b, and False otherwise.\n", "    \n", "    For the values to be considered close, the difference between them\n", "    must be smaller than at least one of the tolerances.\n", "    \n", "    -inf, inf and NaN behave similarly to the IEEE 754 Standard.  That\n", "    is, NaN is not close to anything, even itself.  inf and -inf are\n", "    only close to themselves.\n", "\n"]}], "source": ["help(isclose)"]}, {"cell_type": "code", "execution_count": 8, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 8, "metadata": {}, "output_type": "execute_result"}], "source": ["x = 0.1 + 0.1 + 0.1\n", "y = 0.3\n", "isclose(x, y)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The ``isclose`` method takes two optional parameters, ``rel_tol`` and ``abs_tol``.\n", "\n", "``rel_tol`` is a relative tolerance that will be relative to the magnitude of the largest of the two numbers being compared. Useful when we want to see if two numbers are close to each other as a percentage of their magnitudes.\n", "\n", "``abs_tol`` is an absolute tolerance that is independent of the magnitude of the numbers we are comparing - this is useful for numbers that are close to zero."]}, {"cell_type": "markdown", "metadata": {}, "source": ["In this situation we might consider x and y to be close to each other:"]}, {"cell_type": "code", "execution_count": 9, "metadata": {"collapsed": true}, "outputs": [], "source": ["x = 123456789.01\n", "y = 123456789.02"]}, {"cell_type": "markdown", "metadata": {}, "source": ["but not in this case:"]}, {"cell_type": "code", "execution_count": 10, "metadata": {"collapsed": true}, "outputs": [], "source": ["x = 0.01\n", "y = 0.02"]}, {"cell_type": "markdown", "metadata": {}, "source": ["In both these cases the difference between the two numbers was ``0.01``, yet in one case we considered the numbers \"equal\" and in the other, not \"equal\". Relative tolerances are useful to handle these scenarios."]}, {"cell_type": "code", "execution_count": 11, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 11, "metadata": {}, "output_type": "execute_result"}], "source": ["isclose(123456789.01, 123456789.02, rel_tol=0.01)"]}, {"cell_type": "code", "execution_count": 12, "metadata": {}, "outputs": [{"data": {"text/plain": ["False"]}, "execution_count": 12, "metadata": {}, "output_type": "execute_result"}], "source": ["isclose(0.01, 0.02, rel_tol=0.01)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["On the other hand, we have to be careful with relative tolerances when working with values that are close to zero:"]}, {"cell_type": "code", "execution_count": 13, "metadata": {}, "outputs": [{"data": {"text/plain": ["False"]}, "execution_count": 13, "metadata": {}, "output_type": "execute_result"}], "source": ["x = 0.0000001\n", "y = 0.0000002\n", "isclose(x, y, rel_tol=0.01)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["So, we could use an absolute tolerance here:"]}, {"cell_type": "code", "execution_count": 14, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 14, "metadata": {}, "output_type": "execute_result"}], "source": ["isclose(x, y, abs_tol=0.0001, rel_tol=0)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["In general, we can combine the use of both relative and absolute tolerances in this way:"]}, {"cell_type": "code", "execution_count": 15, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["x = y: True\n", "a = b: True\n"]}], "source": ["x = 0.0000001\n", "y = 0.0000002\n", "\n", "a = 123456789.01\n", "b = 123456789.02\n", "\n", "print('x = y:', isclose(x, y, abs_tol=0.0001, rel_tol=0.01))\n", "print('a = b:', isclose(a, b, abs_tol=0.0001, rel_tol=0.01))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Coercing Floats to Integers"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Truncation"]}, {"cell_type": "code", "execution_count": 1, "metadata": {"collapsed": true}, "outputs": [], "source": ["from math import trunc"]}, {"cell_type": "code", "execution_count": 2, "metadata": {}, "outputs": [{"data": {"text/plain": ["(10, 10, 10)"]}, "execution_count": 2, "metadata": {}, "output_type": "execute_result"}], "source": ["trunc(10.3), trunc(10.5), trunc(10.6)"]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [{"data": {"text/plain": ["(-10, -10, -10)"]}, "execution_count": 3, "metadata": {}, "output_type": "execute_result"}], "source": ["trunc(-10.6), trunc(-10.5), trunc(-10.3)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The **int** constructor uses truncation when a float is passed in:"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"data": {"text/plain": ["(10, 10, 10)"]}, "execution_count": 4, "metadata": {}, "output_type": "execute_result"}], "source": ["int(10.3), int(10.5), int(10.6)"]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"data": {"text/plain": ["(-10, -10, -10)"]}, "execution_count": 5, "metadata": {}, "output_type": "execute_result"}], "source": ["int(-10.5), int(-10.5), int(-10.4)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Floor"]}, {"cell_type": "code", "execution_count": 6, "metadata": {"collapsed": true}, "outputs": [], "source": ["from math import floor"]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"data": {"text/plain": ["(10, 10, 10)"]}, "execution_count": 7, "metadata": {}, "output_type": "execute_result"}], "source": ["floor(10.4), floor(10.5), floor(10.6)"]}, {"cell_type": "code", "execution_count": 8, "metadata": {}, "outputs": [{"data": {"text/plain": ["(-11, -11, -11)"]}, "execution_count": 8, "metadata": {}, "output_type": "execute_result"}], "source": ["floor(-10.4), floor(-10.5), floor(-10.6)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Ceiling"]}, {"cell_type": "code", "execution_count": 9, "metadata": {"collapsed": true}, "outputs": [], "source": ["from math import ceil"]}, {"cell_type": "code", "execution_count": 10, "metadata": {}, "outputs": [{"data": {"text/plain": ["(11, 11, 11)"]}, "execution_count": 10, "metadata": {}, "output_type": "execute_result"}], "source": ["ceil(10.4), ceil(10.5), ceil(10.6)"]}, {"cell_type": "code", "execution_count": 11, "metadata": {}, "outputs": [{"data": {"text/plain": ["(-10, -10, -10)"]}, "execution_count": 11, "metadata": {}, "output_type": "execute_result"}], "source": ["ceil(-10.4), ceil(-10.5), ceil(-10.6)"]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": []}, {"cell_type": "markdown", "metadata": {}, "source": ["### Rounding"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Help on built-in function round in module builtins:\n", "\n", "round(...)\n", "    round(number[, ndigits]) -> number\n", "    \n", "    Round a number to a given precision in decimal digits (default 0 digits).\n", "    This returns an int when called with one argument, otherwise the\n", "    same type as the number. ndigits may be negative.\n", "\n"]}], "source": ["help(round)\n"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### n = 0"]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"data": {"text/plain": ["(2, int)"]}, "execution_count": 5, "metadata": {}, "output_type": "execute_result"}], "source": ["a = round(1.5)\n", "a, type(a)"]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [{"ename": "NameError", "evalue": "name 'b' is not defined", "output_type": "error", "traceback": ["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[1;31mNameError\u001b[0m                                 Traceback (most recent call last)", "\u001b[1;32m<ipython-input-6-356ec769b541>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[0;32m      1\u001b[0m \u001b[0ma\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mround\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;36m1.5\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;36m0\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m----> 2\u001b[1;33m \u001b[0ma\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mtype\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mb\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m", "\u001b[1;31mNameError\u001b[0m: name 'b' is not defined"]}], "source": ["a = round(1.5, 0)\n", "a, type(b)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### n > 0"]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": ["round(1.8888, 3), round(1.8888, 2), round(1.8888, 1), round(1.8888, 0)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### n < 0"]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": ["round(888.88, 1), round(888.88, 0), \\\n", "round(888.88, -1), round(888.88, -2), \\\n", "round(888.88, -3)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Ties"]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": ["round(1.25, 1)"]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": ["round(1.35, 1)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["This is rounding to nearest, with ties to nearest number with even least significant digit, aka Banker's Rounding."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Works similarly with **n** negative."]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": ["round(15, -1)"]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": ["round(25, -1)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Rounding to closest, ties away from zero"]}, {"cell_type": "markdown", "metadata": {}, "source": ["This is traditionally the type of rounding taught in school, which is different from the Banker's Rounding implemented in Python (and in many other programming languages)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["1.5 --> 2 <br>\n", "2.5 --> 3 <br>\n", "\n", "-1.5 --> -2 <br>\n", "-2.5 --> -3 <br>"]}, {"cell_type": "markdown", "metadata": {}, "source": ["To do this type of rounding (to nearest 1) we can add (for positive numbers) or subtract (for negative numbers) 0.5 and then truncate the resulting number."]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": ["def _round(x):\n", "    from math import copysign\n", "    return int(x + 0.5 * copysign(1, x))"]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": ["round(1.5), _round(1.5)"]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": ["round(2.5), _round(2.5)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Decimals"]}, {"cell_type": "code", "execution_count": 1, "metadata": {"collapsed": true}, "outputs": [], "source": ["import decimal"]}, {"cell_type": "code", "execution_count": 2, "metadata": {"collapsed": true}, "outputs": [], "source": ["from decimal import Decimal"]}, {"cell_type": "markdown", "metadata": {"collapsed": true}, "source": ["Decimals have context, that can be used to specify rounding and precision (amongst other things)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Contexts can be local (temporary contexts) or global (default)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Global Context"]}, {"cell_type": "code", "execution_count": 3, "metadata": {"collapsed": true}, "outputs": [], "source": ["g_ctx  = decimal.getcontext()"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"data": {"text/plain": ["28"]}, "execution_count": 4, "metadata": {}, "output_type": "execute_result"}], "source": ["g_ctx.prec"]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"data": {"text/plain": ["'ROUND_HALF_EVEN'"]}, "execution_count": 5, "metadata": {}, "output_type": "execute_result"}], "source": ["g_ctx.rounding"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can change settings in the global context:"]}, {"cell_type": "code", "execution_count": 6, "metadata": {"collapsed": true}, "outputs": [], "source": ["g_ctx.prec = 6"]}, {"cell_type": "code", "execution_count": 7, "metadata": {"collapsed": true}, "outputs": [], "source": ["g_ctx.rounding = decimal.ROUND_HALF_UP"]}, {"cell_type": "markdown", "metadata": {}, "source": ["And if we read this back directly from the global context:"]}, {"cell_type": "code", "execution_count": 8, "metadata": {}, "outputs": [{"data": {"text/plain": ["6"]}, "execution_count": 8, "metadata": {}, "output_type": "execute_result"}], "source": ["decimal.getcontext().prec"]}, {"cell_type": "code", "execution_count": 9, "metadata": {}, "outputs": [{"data": {"text/plain": ["'ROUND_HALF_UP'"]}, "execution_count": 9, "metadata": {}, "output_type": "execute_result"}], "source": ["decimal.getcontext().rounding"]}, {"cell_type": "markdown", "metadata": {}, "source": ["we see that the global context was indeed changed."]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Local Context"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The ``localcontext()`` function will return a context manager that we can use with a ``with`` statement:"]}, {"cell_type": "code", "execution_count": 10, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["6\n", "ROUND_HALF_UP\n"]}], "source": ["with decimal.localcontext() as ctx:\n", "    print(ctx.prec)\n", "    print(ctx.rounding)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Since no argument was specified in the ``localcontext()`` call, it provides us a context manager that uses a copy of the global context."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Modifying the local context has no effect on the global context"]}, {"cell_type": "code", "execution_count": 11, "metadata": {"scrolled": true}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["local prec = 10, global prec = 6\n"]}], "source": ["with decimal.localcontext() as ctx:\n", "    ctx.prec = 10\n", "    print('local prec = {0}, global prec = {1}'.format(ctx.prec, g_ctx.prec))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Rounding"]}, {"cell_type": "code", "execution_count": 12, "metadata": {}, "outputs": [{"data": {"text/plain": ["'ROUND_HALF_UP'"]}, "execution_count": 12, "metadata": {}, "output_type": "execute_result"}], "source": ["decimal.getcontext().rounding"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The rounding mechanism is ROUND_HALF_UP because we set the global context to that earlier in this notebook. Note that normally the default is ROUND_HALF_EVEN.\n", "\n", "So we first reset our global context rounding to that:"]}, {"cell_type": "code", "execution_count": 13, "metadata": {"collapsed": true}, "outputs": [], "source": ["decimal.getcontext().rounding = decimal.ROUND_HALF_EVEN"]}, {"cell_type": "code", "execution_count": 14, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1.2\n", "1.4\n"]}], "source": ["x = Decimal('1.25')\n", "y = Decimal('1.35')\n", "print(round(x, 1))\n", "print(round(y, 1))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's change the rounding mechanism in the global context to ROUND_HALF_UP:"]}, {"cell_type": "code", "execution_count": 15, "metadata": {"collapsed": true}, "outputs": [], "source": ["decimal.getcontext().rounding = decimal.ROUND_HALF_UP"]}, {"cell_type": "code", "execution_count": 16, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1.3\n", "1.4\n"]}], "source": ["x = Decimal('1.25')\n", "y = Decimal('1.35')\n", "print(round(x, 1))\n", "print(round(y, 1))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you may have realized, changing the global context is a pain if you need to constantly switch between different precisions and rounding algorithms. Also, it could introduce bugs if you forget that you changed the global context somewhere further up in your module.\n", "\n", "For this reason, it is usually better to use a local context manager instead:"]}, {"cell_type": "markdown", "metadata": {}, "source": ["First we reset our global context rounding to the default:"]}, {"cell_type": "code", "execution_count": 17, "metadata": {"collapsed": true}, "outputs": [], "source": ["decimal.getcontext().rounding = decimal.ROUND_HALF_EVEN"]}, {"cell_type": "code", "execution_count": 18, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1.2 1.4\n", "1.3 1.4\n", "1.2 1.4\n"]}], "source": ["x = Decimal('1.25')\n", "y = Decimal('1.35')\n", "print(round(x, 1), round(y, 1))\n", "with decimal.localcontext() as ctx:\n", "    ctx.rounding = decimal.ROUND_HALF_UP\n", "    print(round(x, 1), round(y, 1))\n", "print(round(x, 1), round(y, 1))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Decimals: Constructors and Contexts"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The **Decimal** constructor can handle a variety of data types"]}, {"cell_type": "code", "execution_count": 1, "metadata": {"collapsed": true}, "outputs": [], "source": ["import decimal\n", "from decimal import Decimal"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Integers"]}, {"cell_type": "code", "execution_count": 2, "metadata": {}, "outputs": [{"data": {"text/plain": ["Decimal('10')"]}, "execution_count": 2, "metadata": {}, "output_type": "execute_result"}], "source": ["Decimal(10)"]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [{"data": {"text/plain": ["Decimal('-10')"]}, "execution_count": 3, "metadata": {}, "output_type": "execute_result"}], "source": ["Decimal(-10)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Strings"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"data": {"text/plain": ["Decimal('0.1')"]}, "execution_count": 4, "metadata": {}, "output_type": "execute_result"}], "source": ["Decimal('0.1')"]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"data": {"text/plain": ["Decimal('-3.1415')"]}, "execution_count": 5, "metadata": {}, "output_type": "execute_result"}], "source": ["Decimal('-3.1415')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Tuples"]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [{"data": {"text/plain": ["Decimal('3.1415')"]}, "execution_count": 6, "metadata": {}, "output_type": "execute_result"}], "source": ["Decimal ((0, (3,1,4,1,5), -4))"]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"data": {"text/plain": ["Decimal('-1.234')"]}, "execution_count": 7, "metadata": {}, "output_type": "execute_result"}], "source": ["Decimal((1, (1,2,3,4), -3))"]}, {"cell_type": "code", "execution_count": 8, "metadata": {}, "outputs": [{"data": {"text/plain": ["Decimal('1.23E+5')"]}, "execution_count": 8, "metadata": {}, "output_type": "execute_result"}], "source": ["Decimal((0, (1,2,3), 3))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### But don't use Floats"]}, {"cell_type": "code", "execution_count": 9, "metadata": {}, "outputs": [{"data": {"text/plain": ["'0.1000000000000000055511151'"]}, "execution_count": 9, "metadata": {}, "output_type": "execute_result"}], "source": ["format(0.1, '.25f')"]}, {"cell_type": "code", "execution_count": 10, "metadata": {}, "outputs": [{"data": {"text/plain": ["Decimal('0.1000000000000000055511151231257827021181583404541015625')"]}, "execution_count": 10, "metadata": {}, "output_type": "execute_result"}], "source": ["Decimal(0.1)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see, since we passed an approximate binary float to the Decimal constructor it did it's best to represent that binary float **exactly**!!"]}, {"cell_type": "markdown", "metadata": {}, "source": ["So, instead, use strings or tuples in the Decimal constructor."]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Context Precision and the Constructor"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The context precision does nto affect the precision used when creating a Decimal object - those are independent of each other."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's set our global (default) context to a precision of 2"]}, {"cell_type": "code", "execution_count": 11, "metadata": {"collapsed": true}, "outputs": [], "source": ["decimal.getcontext().prec = 2"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now we can create decimal numbers of higher precision than that:"]}, {"cell_type": "code", "execution_count": 12, "metadata": {"collapsed": true}, "outputs": [], "source": ["a = Decimal('0.12345')\n", "b = Decimal('0.12345')"]}, {"cell_type": "code", "execution_count": 13, "metadata": {}, "outputs": [{"data": {"text/plain": ["Decimal('0.12345')"]}, "execution_count": 13, "metadata": {}, "output_type": "execute_result"}], "source": ["a"]}, {"cell_type": "code", "execution_count": 14, "metadata": {}, "outputs": [{"data": {"text/plain": ["Decimal('0.12345')"]}, "execution_count": 14, "metadata": {}, "output_type": "execute_result"}], "source": ["b"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But when we add those two numbers up, the context precision will matter:"]}, {"cell_type": "code", "execution_count": 15, "metadata": {}, "outputs": [{"data": {"text/plain": ["Decimal('0.25')"]}, "execution_count": 15, "metadata": {}, "output_type": "execute_result"}], "source": ["a+b"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see, we ended up with a sum that was rounded to 2 digits after the decimal point (precision = 2)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Local and Global Contexts are Independent"]}, {"cell_type": "code", "execution_count": 16, "metadata": {"collapsed": true}, "outputs": [], "source": ["decimal.getcontext().prec = 6"]}, {"cell_type": "code", "execution_count": 17, "metadata": {}, "outputs": [{"data": {"text/plain": ["'ROUND_HALF_EVEN'"]}, "execution_count": 17, "metadata": {}, "output_type": "execute_result"}], "source": ["decimal.getcontext().rounding"]}, {"cell_type": "code", "execution_count": 18, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["0.24690\n", "c within local context: 0.25\n", "c within global context: 0.25\n"]}], "source": ["a = Decimal('0.12345')\n", "b = Decimal('0.12345')\n", "print(a + b)\n", "with decimal.localcontext() as ctx:\n", "    ctx.prec = 2\n", "    c = a + b\n", "    print('c within local context: {0}'.format(c))\n", "print('c within global context: {0}'.format(c))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Since **c** was created within the local context by adding **a** and **b**, and the local context had a precision of 2, **c** was rounded to 2 digits after the decimal point.\n", "\n", "Once the local context is destroyed (after the **with** block), the variable **c** still exists, and its precision is **still** just 2 - it doesn't magically suddenly get the global context's precision of 6."]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Decimals - Math Operations"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Div and Mod"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The // and % operators (and consequently, the divmod() function) behave differently for integers and Decimals."]}, {"cell_type": "markdown", "metadata": {}, "source": ["This is because integer division for Decimals is performed differently, and results in a truncated division, whereas integers use a floored division.\n", "\n", "These differences are only when negative numbers are involved. If all numbers involved are positive, then integer and Decimal div and mod operations are equal."]}, {"cell_type": "markdown", "metadata": {}, "source": ["But in both cases the // and % operators satisfy the equation:\n", "\n", "``n = d * (n // d) + (n % d)``"]}, {"cell_type": "code", "execution_count": 1, "metadata": {"collapsed": true}, "outputs": [], "source": ["import decimal\n", "from decimal import Decimal"]}, {"cell_type": "code", "execution_count": 2, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["3 1\n", "(3, 1)\n", "True\n"]}], "source": ["x = 10\n", "y = 3\n", "print(x//y, x%y)\n", "print(divmod(x, y))\n", "print( x == y * (x//y) + x % y)"]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["3 1\n", "(Decimal('3'), Decimal('1'))\n", "True\n"]}], "source": ["a = Decimal('10')\n", "b = Decimal('3')\n", "print(a//b, a%b)\n", "print(divmod(a, b))\n", "print( a == b * (a//b) + a % b)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As we can see, the // and % operators had the same result when both numbers were positive."]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["-4 2\n", "(-4, 2)\n", "True\n"]}], "source": ["x = -10\n", "y = 3\n", "print(x//y, x%y)\n", "print(divmod(x, y))\n", "print( x == y * (x//y) + x % y)"]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["-3 -1\n", "(Decimal('-3'), Decimal('-1'))\n", "True\n"]}], "source": ["a = Decimal('-10')\n", "b = Decimal('3')\n", "print(a//b, a%b)\n", "print(divmod(a, b))\n", "print( a == b * (a//b) + a % b)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["On the other hand, we see that in this case the // and % operators did not result in the same values, although the equation was satisfied in both instances."]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Other Mathematical Functions"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The Decimal class implements a variety of mathematical functions."]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["0.1760912590556812420812890085\n", "0.4054651081081643819780131155\n", "4.481689070338064822602055460\n", "1.224744871391589049098642037\n"]}], "source": ["a = Decimal('1.5')\n", "print(a.log10())  # base 10 logarithm\n", "print(a.ln())     # natural logarithm (base e)\n", "print(a.exp())    # e**a\n", "print(a.sqrt())   # square root"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Although you can use the math function of the math module, be aware that the math module functions will cast the Decimal numbers to floats when it performs the various operations. So, if the precision is important (which it probably is if you decided to use Decimal numbers in the first place), choose the math functions of the Decimal class over those of the math module."]}, {"cell_type": "code", "execution_count": 7, "metadata": {"collapsed": true}, "outputs": [], "source": ["x = 2\n", "x_dec = Decimal(2)"]}, {"cell_type": "code", "execution_count": 8, "metadata": {"collapsed": true}, "outputs": [], "source": ["import math"]}, {"cell_type": "code", "execution_count": 9, "metadata": {"collapsed": true}, "outputs": [], "source": ["root_float = math.sqrt(x)\n", "root_mixed = math.sqrt(x_dec)\n", "root_dec = x_dec.sqrt()"]}, {"cell_type": "code", "execution_count": 10, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1.414213562373095145474621859\n", "1.414213562373095145474621859\n", "1.414213562373095048801688724\n"]}], "source": ["print(format(root_float, '1.27f'))\n", "print(format(root_mixed, '1.27f'))\n", "print(root_dec)"]}, {"cell_type": "code", "execution_count": 11, "metadata": {"scrolled": true}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["2.000000000000000444089209850\n", "2.000000000000000444089209850\n", "1.999999999999999999999999999\n"]}], "source": ["print(format(root_float * root_float, '1.27f'))\n", "print(format(root_mixed * root_mixed, '1.27f'))\n", "print(root_dec * root_dec)"]}, {"cell_type": "code", "execution_count": 12, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["0.100000000000000005551115123\n", "0.100000000000000005551115123\n", "0.1\n"]}], "source": ["x = 0.01\n", "x_dec = Decimal('0.01')\n", "\n", "root_float = math.sqrt(x)\n", "root_mixed = math.sqrt(x_dec)\n", "root_dec = x_dec.sqrt()\n", "\n", "print(format(root_float, '1.27f'))\n", "print(format(root_mixed, '1.27f'))\n", "print(root_dec)"]}, {"cell_type": "code", "execution_count": 13, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["0.010000000000000001942890293\n", "0.010000000000000001942890293\n", "0.01\n"]}], "source": ["print(format(root_float * root_float, '1.27f'))\n", "print(format(root_mixed * root_mixed, '1.27f'))\n", "print(root_dec * root_dec)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Decimals: Performance Considerations"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Memory Footprint"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Decimals take up a lot more memory than floats."]}, {"cell_type": "code", "execution_count": 1, "metadata": {"collapsed": true}, "outputs": [], "source": ["import sys\n", "from decimal import Decimal"]}, {"cell_type": "code", "execution_count": 2, "metadata": {"collapsed": true}, "outputs": [], "source": ["a = 3.1415\n", "b = Decimal('3.1415')"]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [{"data": {"text/plain": ["24"]}, "execution_count": 3, "metadata": {}, "output_type": "execute_result"}], "source": ["sys.getsizeof(a)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["24 bytes are used to store the float 3.1415"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"data": {"text/plain": ["104"]}, "execution_count": 4, "metadata": {}, "output_type": "execute_result"}], "source": ["sys.getsizeof(b)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["104 bytes are used to store the Decimal 3.1415"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Computational Performance"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Decimal arithmetic is also much slower than float arithmetic (on a CPU, and even more so if using a GPU)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can do some rough timings to illustrate this."]}, {"cell_type": "markdown", "metadata": {}, "source": ["First we look at the performance difference creating floats vs decimals:"]}, {"cell_type": "code", "execution_count": 5, "metadata": {"collapsed": true}, "outputs": [], "source": ["import time\n", "from decimal import Decimal\n", "\n", "def run_float(n=1):\n", "    for i in range(n):\n", "        a = 3.1415\n", "        \n", "def run_decimal(n=1):\n", "    for i in range(n):\n", "        a = Decimal('3.1415')\n"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Timing float and Decimal operations:"]}, {"cell_type": "code", "execution_count": 6, "metadata": {"collapsed": true}, "outputs": [], "source": ["n = 10000000"]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["float:  0.21406484986433047\n", "decimal:  2.1353148079910156\n"]}], "source": ["start = time.perf_counter()\n", "run_float(n)\n", "end = time.perf_counter()\n", "print('float: ', end-start)\n", "\n", "start = time.perf_counter()\n", "run_decimal(n)\n", "end = time.perf_counter()\n", "print('decimal: ', end-start)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We make a slight variant here to see how addition compares between the two types:"]}, {"cell_type": "code", "execution_count": 11, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["float:  0.1875864573764936\n", "decimal:  0.3911394302055555\n"]}], "source": ["def run_float(n=1):\n", "    a = 3.1415\n", "    for i in range(n):\n", "        a + a\n", "        \n", "def run_decimal(n=1):\n", "    a = Decimal('3.1415')\n", "    for i in range(n):\n", "        a + a\n", "        \n", "start = time.perf_counter()\n", "run_float(n)\n", "end = time.perf_counter()\n", "print('float: ', end-start)\n", "\n", "start = time.perf_counter()\n", "run_decimal(n)\n", "end = time.perf_counter()\n", "print('decimal: ', end-start)"]}, {"cell_type": "markdown", "metadata": {"collapsed": true}, "source": ["How about square roots:\n", "\n", "(We drop the n count a bit)"]}, {"cell_type": "code", "execution_count": 10, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["float:  0.673833850211659\n", "decimal:  14.73112183459776\n"]}], "source": ["n = 5000000\n", "\n", "import math\n", "\n", "def run_float(n=1):\n", "    a = 3.1415\n", "    for i in range(n):\n", "        math.sqrt(a)\n", "        \n", "def run_decimal(n=1):\n", "    a = Decimal('3.1415')\n", "    for i in range(n):\n", "        a.sqrt()\n", "        \n", "start = time.perf_counter()\n", "run_float(n)\n", "end = time.perf_counter()\n", "print('float: ', end-start)\n", "\n", "start = time.perf_counter()\n", "run_decimal(n)\n", "end = time.perf_counter()\n", "print('decimal: ', end-start)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Complex Numbers"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Python's built-in class provides support for complex numbers.\n", "\n", "Complex numbers are defined in rectangular coordinates (real and imaginary parts) using either the constructor or a literal expression."]}, {"cell_type": "markdown", "metadata": {}, "source": ["The complex number 1 + 2j can be defined in either of these ways:"]}, {"cell_type": "code", "execution_count": 1, "metadata": {"collapsed": true}, "outputs": [], "source": ["a = complex(1, 2)\n", "b = 1 + 2j"]}, {"cell_type": "code", "execution_count": 2, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 2, "metadata": {}, "output_type": "execute_result"}], "source": ["a == b"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Note that the real and imaginary parts are defined as floats, and can be retrieved as follows:"]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [{"data": {"text/plain": ["(1.0, float)"]}, "execution_count": 3, "metadata": {}, "output_type": "execute_result"}], "source": ["a.real, type(a.real)"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"data": {"text/plain": ["(2.0, float)"]}, "execution_count": 4, "metadata": {}, "output_type": "execute_result"}], "source": ["a.imag, type(a.imag)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The complex conjugate can be calculated as follows:"]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"data": {"text/plain": ["(1-2j)"]}, "execution_count": 5, "metadata": {}, "output_type": "execute_result"}], "source": ["a.conjugate()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The standard arithmetic operatots are polymorphic and defined for complex numbers"]}, {"cell_type": "code", "execution_count": 6, "metadata": {"collapsed": true}, "outputs": [], "source": ["a = 1 + 2j\n", "b = 3 - 4j\n", "c = 5j\n", "d = 10"]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"data": {"text/plain": ["(4-2j)"]}, "execution_count": 7, "metadata": {}, "output_type": "execute_result"}], "source": ["a + b"]}, {"cell_type": "code", "execution_count": 8, "metadata": {}, "outputs": [{"data": {"text/plain": ["(20+15j)"]}, "execution_count": 8, "metadata": {}, "output_type": "execute_result"}], "source": ["b * c"]}, {"cell_type": "code", "execution_count": 9, "metadata": {}, "outputs": [{"data": {"text/plain": ["0.5j"]}, "execution_count": 9, "metadata": {}, "output_type": "execute_result"}], "source": ["c / d"]}, {"cell_type": "code", "execution_count": 10, "metadata": {}, "outputs": [{"data": {"text/plain": ["(9-2j)"]}, "execution_count": 10, "metadata": {}, "output_type": "execute_result"}], "source": ["d - a"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The // and % operators, although also polymorphic, are not defined for complex numbers:"]}, {"cell_type": "code", "execution_count": 11, "metadata": {}, "outputs": [{"ename": "TypeError", "evalue": "can't take floor of complex number.", "output_type": "error", "traceback": ["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[1;31mTypeError\u001b[0m                                 Traceback (most recent call last)", "\u001b[1;32m<ipython-input-11-d3400ddfd09e>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[1;32m----> 1\u001b[1;33m \u001b[0ma\u001b[0m \u001b[1;33m//\u001b[0m \u001b[0mb\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m", "\u001b[1;31mTypeError\u001b[0m: can't take floor of complex number."]}], "source": ["a // b"]}, {"cell_type": "code", "execution_count": 12, "metadata": {}, "outputs": [{"ename": "TypeError", "evalue": "can't mod complex numbers.", "output_type": "error", "traceback": ["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[1;31mTypeError\u001b[0m                                 Traceback (most recent call last)", "\u001b[1;32m<ipython-input-12-209a85c6b5ad>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[1;32m----> 1\u001b[1;33m \u001b[0ma\u001b[0m \u001b[1;33m%\u001b[0m \u001b[0mb\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m", "\u001b[1;31mTypeError\u001b[0m: can't mod complex numbers."]}], "source": ["a % b"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The == and != operators support complex numbers - but since the real and imaginary parts of complex numbers are floats, the same problems comparing floats using == and != also apply to complex numbers."]}, {"cell_type": "code", "execution_count": 14, "metadata": {}, "outputs": [{"data": {"text/plain": ["False"]}, "execution_count": 14, "metadata": {}, "output_type": "execute_result"}], "source": ["a = 0.1j\n", "a + a + a == 0.3j"]}, {"cell_type": "markdown", "metadata": {}, "source": ["In addition, the standard comparison operators (<, <=, >, >=) are not defined for complex numbers."]}, {"cell_type": "code", "execution_count": 15, "metadata": {}, "outputs": [{"ename": "TypeError", "evalue": "'<' not supported between instances of 'complex' and 'complex'", "output_type": "error", "traceback": ["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[1;31mTypeError\u001b[0m                                 Traceback (most recent call last)", "\u001b[1;32m<ipython-input-15-a9748a0ff9df>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[0;32m      1\u001b[0m \u001b[0ma\u001b[0m \u001b[1;33m=\u001b[0m \u001b[1;36m1\u001b[0m \u001b[1;33m+\u001b[0m \u001b[1;36m1j\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m      2\u001b[0m \u001b[0mb\u001b[0m \u001b[1;33m=\u001b[0m \u001b[1;36m100\u001b[0m \u001b[1;33m+\u001b[0m \u001b[1;36m100j\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m----> 3\u001b[1;33m \u001b[0ma\u001b[0m \u001b[1;33m<\u001b[0m \u001b[0mb\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m", "\u001b[1;31mTypeError\u001b[0m: '<' not supported between instances of 'complex' and 'complex'"]}], "source": ["a = 1 + 1j\n", "b = 100 + 100j\n", "a < b"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Math Functions"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The **cmath** module provides complex alternatives to the standard **math** functions."]}, {"cell_type": "markdown", "metadata": {}, "source": ["In addition, the **cmath** module provides the complex implementation of the **isclose()** method available for floats."]}, {"cell_type": "code", "execution_count": 16, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["(1.7462845577958914+1.4316108957382214j)\n"]}], "source": ["import cmath\n", "\n", "a = 1 + 5j\n", "print(cmath.sqrt(a))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The standard **math** module functions will not work with complex numbers:"]}, {"cell_type": "code", "execution_count": 18, "metadata": {}, "outputs": [{"ename": "TypeError", "evalue": "can't convert complex to float", "output_type": "error", "traceback": ["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[1;31mTypeError\u001b[0m                                 Traceback (most recent call last)", "\u001b[1;32m<ipython-input-18-77a8fdd31911>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[0;32m      1\u001b[0m \u001b[1;32mimport\u001b[0m \u001b[0mmath\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m----> 2\u001b[1;33m \u001b[0mprint\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mmath\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0msqrt\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0ma\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m", "\u001b[1;31mTypeError\u001b[0m: can't convert complex to float"]}], "source": ["import math\n", "print(math.sqrt(a))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Polar / Rectangular Conversions"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The **cmath.phase()** function can be used to return the phase (or argument) of  any complex number."]}, {"cell_type": "markdown", "metadata": {}, "source": ["The standard **abs()** function supports complex numbers and will return the magnitude (euclidean norm) of the complex number."]}, {"cell_type": "code", "execution_count": 19, "metadata": {"collapsed": true}, "outputs": [], "source": ["a = 1 + 1j"]}, {"cell_type": "code", "execution_count": 22, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["(1+1j) = (1.4142135623730951,0.7853981633974483)\n"]}], "source": ["r = abs(a)\n", "phi = cmath.phase(a)\n", "print('{0} = ({1},{2})'.format(a, r, phi))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Complex numbers in polar coordinates can be converted to rectangular coordinates using the **math.rect()** function:"]}, {"cell_type": "code", "execution_count": 26, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["(1.0000000000000002+1.0000000000000002j)\n"]}], "source": ["r = math.sqrt(2)\n", "phi = cmath.pi/4\n", "print(cmath.rect(r, phi))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Euler's Identity and the **isclose()** function"]}, {"cell_type": "markdown", "metadata": {}, "source": ["e<sup>i &pi;</sup> + 1 = 0"]}, {"cell_type": "code", "execution_count": 28, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1.2246467991473532e-16j\n"]}], "source": ["RHS = cmath.exp(cmath.pi * 1j) + 1\n", "print(RHS)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Which, because of limited precision is not quite zero."]}, {"cell_type": "markdown", "metadata": {}, "source": ["However, the result is very close to zero.\n", "\n", "We can use the **isclose()** method of the **cmath** module, which behaves similarly to the **math.isclose()** method. Since we are testing for closeness of two numbers close to zero, we need to make sure an absolute tolerance is also specified:"]}, {"cell_type": "code", "execution_count": 29, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 29, "metadata": {}, "output_type": "execute_result"}], "source": ["cmath.isclose(RHS, 0, abs_tol=0.00001)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["If we had not specified an absolute tolerance:"]}, {"cell_type": "code", "execution_count": 30, "metadata": {}, "outputs": [{"data": {"text/plain": ["False"]}, "execution_count": 30, "metadata": {}, "output_type": "execute_result"}], "source": ["cmath.isclose(RHS, 0)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Booleans"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The **bool** class is used to represent boolean values."]}, {"cell_type": "markdown", "metadata": {}, "source": ["The **bool** class inherits from the **int** class."]}, {"cell_type": "code", "execution_count": 1, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 1, "metadata": {}, "output_type": "execute_result"}], "source": ["issubclass(bool, int)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Two built-in constants, **True** and **False** are singleton instances of the bool class with underlying int values of 1 and 0 respectively."]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"data": {"text/plain": ["(bool, 1658060976, 1)"]}, "execution_count": 7, "metadata": {}, "output_type": "execute_result"}], "source": ["type(True), id(True), int(True)"]}, {"cell_type": "code", "execution_count": 8, "metadata": {}, "outputs": [{"data": {"text/plain": ["(bool, 1658061008, 0)"]}, "execution_count": 8, "metadata": {}, "output_type": "execute_result"}], "source": ["type(False), id(False), int(False)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["These two values are instances of the **bool** class, and by inheritance are also **int** objects."]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 5, "metadata": {}, "output_type": "execute_result"}], "source": ["isinstance(True, bool)"]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 6, "metadata": {}, "output_type": "execute_result"}], "source": ["isinstance(True, int)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Since **True** and **False** are singletons, we can use either the **is** operator, or the **==** operator to compare them to **any** boolean expression."]}, {"cell_type": "code", "execution_count": 9, "metadata": {}, "outputs": [{"data": {"text/plain": ["(1658060976, 1658060976)"]}, "execution_count": 9, "metadata": {}, "output_type": "execute_result"}], "source": ["id(True), id(1 < 2)"]}, {"cell_type": "code", "execution_count": 10, "metadata": {}, "outputs": [{"data": {"text/plain": ["(1658061008, 1658061008)"]}, "execution_count": 10, "metadata": {}, "output_type": "execute_result"}], "source": ["id(False), id(1 == 3)"]}, {"cell_type": "code", "execution_count": 12, "metadata": {}, "outputs": [{"data": {"text/plain": ["(True, True)"]}, "execution_count": 12, "metadata": {}, "output_type": "execute_result"}], "source": ["(1 < 2) is True, (1 < 2) == True"]}, {"cell_type": "code", "execution_count": 13, "metadata": {}, "outputs": [{"data": {"text/plain": ["(True, True)"]}, "execution_count": 13, "metadata": {}, "output_type": "execute_result"}], "source": ["(1 == 2) is False, (1 == 2) == False"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Be careful with that last comparison, the parentheses are necessary!"]}, {"cell_type": "code", "execution_count": 15, "metadata": {}, "outputs": [{"data": {"text/plain": ["False"]}, "execution_count": 15, "metadata": {}, "output_type": "execute_result"}], "source": ["1 == 2 == False"]}, {"cell_type": "code", "execution_count": 16, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 16, "metadata": {}, "output_type": "execute_result"}], "source": ["(1 == 2) == False"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We'll look into this in detail later, but, for now, this happens because a chained comparison such as **a == b == c** is actually evaluated as **a == b and b == c**"]}, {"cell_type": "markdown", "metadata": {}, "source": ["So **1 == 2 == False ** is the same as **1 == 2 and 2 == False**"]}, {"cell_type": "code", "execution_count": 17, "metadata": {}, "outputs": [{"data": {"text/plain": ["(False, False, False)"]}, "execution_count": 17, "metadata": {}, "output_type": "execute_result"}], "source": ["1 == 2, 2 == False, 1==2 and 2==False"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But, "]}, {"cell_type": "code", "execution_count": 18, "metadata": {}, "outputs": [{"data": {"text/plain": ["False"]}, "execution_count": 18, "metadata": {}, "output_type": "execute_result"}], "source": ["(1 == 2)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["So **(1 == 2) == False** evaluates to True"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But since **False** is also **0**, we get the following:"]}, {"cell_type": "code", "execution_count": 36, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 36, "metadata": {}, "output_type": "execute_result"}], "source": ["(1 == 2) == 0"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The underlying integer values of True and False are:"]}, {"cell_type": "code", "execution_count": 19, "metadata": {}, "outputs": [{"data": {"text/plain": ["(1, 0)"]}, "execution_count": 19, "metadata": {}, "output_type": "execute_result"}], "source": ["int(True), int(False)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["So, using an equality comparison:"]}, {"cell_type": "code", "execution_count": 20, "metadata": {}, "outputs": [{"data": {"text/plain": ["(True, True)"]}, "execution_count": 20, "metadata": {}, "output_type": "execute_result"}], "source": ["1 == True, 0 == False"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But, from an object perspective 1 and True are not the same (similarly with 0 and False)"]}, {"cell_type": "code", "execution_count": 21, "metadata": {"scrolled": true}, "outputs": [{"data": {"text/plain": ["(True, False)"]}, "execution_count": 21, "metadata": {}, "output_type": "execute_result"}], "source": ["1 == True, 1 is True"]}, {"cell_type": "code", "execution_count": 23, "metadata": {}, "outputs": [{"data": {"text/plain": ["(True, False)"]}, "execution_count": 23, "metadata": {}, "output_type": "execute_result"}], "source": ["0 == False, 0 is False"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Any integer can be cast to a boolean, and follows the rule:\n", "\n", "bool(x) = True for any x except for zero which returns False"]}, {"cell_type": "code", "execution_count": 24, "metadata": {}, "outputs": [{"data": {"text/plain": ["False"]}, "execution_count": 24, "metadata": {}, "output_type": "execute_result"}], "source": ["bool(0)"]}, {"cell_type": "code", "execution_count": 25, "metadata": {}, "outputs": [{"data": {"text/plain": ["(True, True, True)"]}, "execution_count": 25, "metadata": {}, "output_type": "execute_result"}], "source": ["bool(1), bool(100), bool(-1)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Since booleans are subclassed from integers, they can behave like integers, and because of polymorphism all the standard integer operators, properties and methods apply"]}, {"cell_type": "code", "execution_count": 26, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 26, "metadata": {}, "output_type": "execute_result"}], "source": ["True > False"]}, {"cell_type": "code", "execution_count": 27, "metadata": {}, "outputs": [{"data": {"text/plain": ["3"]}, "execution_count": 27, "metadata": {}, "output_type": "execute_result"}], "source": ["True + 2"]}, {"cell_type": "code", "execution_count": 29, "metadata": {}, "outputs": [{"data": {"text/plain": ["0"]}, "execution_count": 29, "metadata": {}, "output_type": "execute_result"}], "source": ["False // 2"]}, {"cell_type": "code", "execution_count": 33, "metadata": {}, "outputs": [{"data": {"text/plain": ["3"]}, "execution_count": 33, "metadata": {}, "output_type": "execute_result"}], "source": ["True + True + True"]}, {"cell_type": "code", "execution_count": 32, "metadata": {}, "outputs": [{"data": {"text/plain": ["1"]}, "execution_count": 32, "metadata": {}, "output_type": "execute_result"}], "source": ["(True + True + True) % 2"]}, {"cell_type": "code", "execution_count": 34, "metadata": {}, "outputs": [{"data": {"text/plain": ["-1"]}, "execution_count": 34, "metadata": {}, "output_type": "execute_result"}], "source": ["-True"]}, {"cell_type": "code", "execution_count": 35, "metadata": {}, "outputs": [{"data": {"text/plain": ["0"]}, "execution_count": 35, "metadata": {}, "output_type": "execute_result"}], "source": ["100 * False"]}, {"cell_type": "markdown", "metadata": {}, "source": ["I certainly **do not** recommend you write code like that shown above, but be aware that it does work."]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Booleans: Truth Values"]}, {"cell_type": "markdown", "metadata": {}, "source": ["All objects in Python have an associated **truth value**, or **truthyness**"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We saw in a previous lecture that integers have an inherent truth value:"]}, {"cell_type": "code", "execution_count": 2, "metadata": {}, "outputs": [{"data": {"text/plain": ["False"]}, "execution_count": 2, "metadata": {}, "output_type": "execute_result"}], "source": ["bool(0)"]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [{"data": {"text/plain": ["(True, True, True)"]}, "execution_count": 3, "metadata": {}, "output_type": "execute_result"}], "source": ["bool(1), bool(-1), bool(100)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["This truthyness has nothing to do with the fact that **bool** is a subclass of **int**.\n", "\n", "Instead, it has to do with the fact that the **int** class implements a `__bool__()` method:"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Help on class bool in module builtins:\n", "\n", "class bool(int)\n", " |  bool(x) -> bool\n", " |  \n", " |  Returns True when the argument x is true, False otherwise.\n", " |  The builtins True and False are the only two instances of the class bool.\n", " |  The class bool is a subclass of the class int, and cannot be subclassed.\n", " |  \n", " |  Method resolution order:\n", " |      bool\n", " |      int\n", " |      object\n", " |  \n", " |  Methods defined here:\n", " |  \n", " |  __and__(self, value, /)\n", " |      Return self&value.\n", " |  \n", " |  __new__(*args, **kwargs) from builtins.type\n", " |      Create and return a new object.  See help(type) for accurate signature.\n", " |  \n", " |  __or__(self, value, /)\n", " |      Return self|value.\n", " |  \n", " |  __rand__(self, value, /)\n", " |      Return value&self.\n", " |  \n", " |  __repr__(self, /)\n", " |      Return repr(self).\n", " |  \n", " |  __ror__(self, value, /)\n", " |      Return value|self.\n", " |  \n", " |  __rxor__(self, value, /)\n", " |      Return value^self.\n", " |  \n", " |  __str__(self, /)\n", " |      Return str(self).\n", " |  \n", " |  __xor__(self, value, /)\n", " |      Return self^value.\n", " |  \n", " |  ----------------------------------------------------------------------\n", " |  Methods inherited from int:\n", " |  \n", " |  __abs__(self, /)\n", " |      abs(self)\n", " |  \n", " |  __add__(self, value, /)\n", " |      Return self+value.\n", " |  \n", " |  __bool__(self, /)\n", " |      self != 0\n", " |  \n", " |  __ceil__(...)\n", " |      Ceiling of an Integral returns itself.\n", " |  \n", " |  __divmod__(self, value, /)\n", " |      Return divmod(self, value).\n", " |  \n", " |  __eq__(self, value, /)\n", " |      Return self==value.\n", " |  \n", " |  __float__(self, /)\n", " |      float(self)\n", " |  \n", " |  __floor__(...)\n", " |      Flooring an Integral returns itself.\n", " |  \n", " |  __floordiv__(self, value, /)\n", " |      Return self//value.\n", " |  \n", " |  __format__(...)\n", " |      default object formatter\n", " |  \n", " |  __ge__(self, value, /)\n", " |      Return self>=value.\n", " |  \n", " |  __getattribute__(self, name, /)\n", " |      Return getattr(self, name).\n", " |  \n", " |  __getnewargs__(...)\n", " |  \n", " |  __gt__(self, value, /)\n", " |      Return self>value.\n", " |  \n", " |  __hash__(self, /)\n", " |      Return hash(self).\n", " |  \n", " |  __index__(self, /)\n", " |      Return self converted to an integer, if self is suitable for use as an index into a list.\n", " |  \n", " |  __int__(self, /)\n", " |      int(self)\n", " |  \n", " |  __invert__(self, /)\n", " |      ~self\n", " |  \n", " |  __le__(self, value, /)\n", " |      Return self<=value.\n", " |  \n", " |  __lshift__(self, value, /)\n", " |      Return self<<value.\n", " |  \n", " |  __lt__(self, value, /)\n", " |      Return self<value.\n", " |  \n", " |  __mod__(self, value, /)\n", " |      Return self%value.\n", " |  \n", " |  __mul__(self, value, /)\n", " |      Return self*value.\n", " |  \n", " |  __ne__(self, value, /)\n", " |      Return self!=value.\n", " |  \n", " |  __neg__(self, /)\n", " |      -self\n", " |  \n", " |  __pos__(self, /)\n", " |      +self\n", " |  \n", " |  __pow__(self, value, mod=None, /)\n", " |      Return pow(self, value, mod).\n", " |  \n", " |  __radd__(self, value, /)\n", " |      Return value+self.\n", " |  \n", " |  __rdivmod__(self, value, /)\n", " |      Return divmod(value, self).\n", " |  \n", " |  __rfloordiv__(self, value, /)\n", " |      Return value//self.\n", " |  \n", " |  __rlshift__(self, value, /)\n", " |      Return value<<self.\n", " |  \n", " |  __rmod__(self, value, /)\n", " |      Return value%self.\n", " |  \n", " |  __rmul__(self, value, /)\n", " |      Return value*self.\n", " |  \n", " |  __round__(...)\n", " |      Rounding an Integral returns itself.\n", " |      Rounding with an ndigits argument also returns an integer.\n", " |  \n", " |  __rpow__(self, value, mod=None, /)\n", " |      Return pow(value, self, mod).\n", " |  \n", " |  __rrshift__(self, value, /)\n", " |      Return value>>self.\n", " |  \n", " |  __rshift__(self, value, /)\n", " |      Return self>>value.\n", " |  \n", " |  __rsub__(self, value, /)\n", " |      Return value-self.\n", " |  \n", " |  __rtruediv__(self, value, /)\n", " |      Return value/self.\n", " |  \n", " |  __sizeof__(...)\n", " |      Returns size in memory, in bytes\n", " |  \n", " |  __sub__(self, value, /)\n", " |      Return self-value.\n", " |  \n", " |  __truediv__(self, value, /)\n", " |      Return self/value.\n", " |  \n", " |  __trunc__(...)\n", " |      Truncating an Integral returns itself.\n", " |  \n", " |  bit_length(...)\n", " |      int.bit_length() -> int\n", " |      \n", " |      Number of bits necessary to represent self in binary.\n", " |      >>> bin(37)\n", " |      '0b100101'\n", " |      >>> (37).bit_length()\n", " |      6\n", " |  \n", " |  conjugate(...)\n", " |      Returns self, the complex conjugate of any int.\n", " |  \n", " |  from_bytes(...) from builtins.type\n", " |      int.from_bytes(bytes, byteorder, *, signed=False) -> int\n", " |      \n", " |      Return the integer represented by the given array of bytes.\n", " |      \n", " |      The bytes argument must be a bytes-like object (e.g. bytes or bytearray).\n", " |      \n", " |      The byteorder argument determines the byte order used to represent the\n", " |      integer.  If byteorder is 'big', the most significant byte is at the\n", " |      beginning of the byte array.  If byteorder is 'little', the most\n", " |      significant byte is at the end of the byte array.  To request the native\n", " |      byte order of the host system, use `sys.byteorder' as the byte order value.\n", " |      \n", " |      The signed keyword-only argument indicates whether two's complement is\n", " |      used to represent the integer.\n", " |  \n", " |  to_bytes(...)\n", " |      int.to_bytes(length, byteorder, *, signed=False) -> bytes\n", " |      \n", " |      Return an array of bytes representing an integer.\n", " |      \n", " |      The integer is represented using length bytes.  An OverflowError is\n", " |      raised if the integer is not representable with the given number of\n", " |      bytes.\n", " |      \n", " |      The byteorder argument determines the byte order used to represent the\n", " |      integer.  If byteorder is 'big', the most significant byte is at the\n", " |      beginning of the byte array.  If byteorder is 'little', the most\n", " |      significant byte is at the end of the byte array.  To request the native\n", " |      byte order of the host system, use `sys.byteorder' as the byte order value.\n", " |      \n", " |      The signed keyword-only argument determines whether two's complement is\n", " |      used to represent the integer.  If signed is False and a negative integer\n", " |      is given, an OverflowError is raised.\n", " |  \n", " |  ----------------------------------------------------------------------\n", " |  Data descriptors inherited from int:\n", " |  \n", " |  denominator\n", " |      the denominator of a rational number in lowest terms\n", " |  \n", " |  imag\n", " |      the imaginary part of a complex number\n", " |  \n", " |  numerator\n", " |      the numerator of a rational number in lowest terms\n", " |  \n", " |  real\n", " |      the real part of a complex number\n", "\n"]}], "source": ["help(bool)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["If you scroll down in the documentation you shoudl reach a section that looks like this:"]}, {"cell_type": "markdown", "metadata": {}, "source": ["`` \n", "|  __bool__(self, /)\n", "|      self != 0\n", "``"]}, {"cell_type": "markdown", "metadata": {}, "source": ["So, when we write:"]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 5, "metadata": {}, "output_type": "execute_result"}], "source": ["bool(100)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Python is actually calling 100.__bool__() and returning that:"]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 7, "metadata": {}, "output_type": "execute_result"}], "source": ["(100).__bool__()"]}, {"cell_type": "code", "execution_count": 8, "metadata": {}, "outputs": [{"data": {"text/plain": ["False"]}, "execution_count": 8, "metadata": {}, "output_type": "execute_result"}], "source": ["(0).__bool__()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Most objects will implement either the `__bool__()` or `__len__()` methods. If they don't, then their associated value will be **True** always."]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Numeric Types"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Any non-zero numeric value is truthy. Any zero numeric value is falsy:"]}, {"cell_type": "code", "execution_count": 9, "metadata": {}, "outputs": [{"data": {"text/plain": ["(True, True, True, True)"]}, "execution_count": 9, "metadata": {}, "output_type": "execute_result"}], "source": ["from fractions import Fraction\n", "from decimal import Decimal\n", "bool(10), bool(1.5), bool(Fraction(3, 4)), bool(Decimal('10.5'))"]}, {"cell_type": "code", "execution_count": 27, "metadata": {}, "outputs": [{"data": {"text/plain": ["(False, False, False, False, False)"]}, "execution_count": 27, "metadata": {}, "output_type": "execute_result"}], "source": ["bool(0), bool(0.0), bool(Fraction(0,1)), bool(Decimal('0')), bool(0j)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Sequence Types"]}, {"cell_type": "markdown", "metadata": {}, "source": ["An empty sequence type object is Falsy, a non-empty one is truthy:"]}, {"cell_type": "code", "execution_count": 28, "metadata": {}, "outputs": [{"data": {"text/plain": ["(True, True, True, True)"]}, "execution_count": 28, "metadata": {}, "output_type": "execute_result"}], "source": ["bool([1, 2, 3]), bool((1, 2, 3)), bool('abc'), bool(1j)"]}, {"cell_type": "code", "execution_count": 14, "metadata": {}, "outputs": [{"data": {"text/plain": ["(False, False, False)"]}, "execution_count": 14, "metadata": {}, "output_type": "execute_result"}], "source": ["bool([]), bool(()), bool('')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Mapping Types"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Similarly, an empty mapping type will be falsy, a non-empty one truthy:"]}, {"cell_type": "code", "execution_count": 16, "metadata": {}, "outputs": [{"data": {"text/plain": ["(True, True)"]}, "execution_count": 16, "metadata": {}, "output_type": "execute_result"}], "source": ["bool({'a': 1}), bool({1, 2, 3})"]}, {"cell_type": "code", "execution_count": 17, "metadata": {}, "outputs": [{"data": {"text/plain": ["(False, False)"]}, "execution_count": 17, "metadata": {}, "output_type": "execute_result"}], "source": ["bool({}), bool(set())"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### The None Object"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The singleton **None** object is always falsy:"]}, {"cell_type": "code", "execution_count": 18, "metadata": {}, "outputs": [{"data": {"text/plain": ["False"]}, "execution_count": 18, "metadata": {}, "output_type": "execute_result"}], "source": ["bool(None)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### One Application of Truth Values"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Any conditional expression which involves objects other than **bool** types, will use the associated truth value as the result of the conditional expression."]}, {"cell_type": "code", "execution_count": 37, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1\n"]}], "source": ["a = [1, 2, 3]\n", "if a:\n", "    print(a[0])\n", "else:\n", "    print('a is None, or a is empty')"]}, {"cell_type": "code", "execution_count": 38, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["a is None, or a is empty\n"]}], "source": ["a = []\n", "if a:\n", "    print(a[0])\n", "else:\n", "    print('a is None, or a is empty')"]}, {"cell_type": "code", "execution_count": 39, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["a\n"]}], "source": ["a = 'abc'\n", "if a:\n", "    print(a[0])\n", "else:\n", "    print('a is None, or a is empty')"]}, {"cell_type": "code", "execution_count": 40, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["a is None, or a is empty\n"]}], "source": ["a = ''\n", "if a:\n", "    print(a[0])\n", "else:\n", "    print('a is None, or a is empty')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We could write this using a more lengthy expression:"]}, {"cell_type": "code", "execution_count": 41, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["a\n"]}], "source": ["a = 'abc'\n", "if a is not None and len(a) > 0:\n", "    print(a[0])\n", "else:\n", "    print('a is None, or a is empty')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Doing the following would break our code in some instances:"]}, {"cell_type": "code", "execution_count": 43, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["a\n"]}], "source": ["a = 'abc'\n", "if a is not None:\n", "    print(a[0])"]}, {"cell_type": "markdown", "metadata": {}, "source": ["works, but:"]}, {"cell_type": "code", "execution_count": 44, "metadata": {}, "outputs": [{"ename": "IndexError", "evalue": "string index out of range", "output_type": "error", "traceback": ["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[1;31mIndexError\u001b[0m                                Traceback (most recent call last)", "\u001b[1;32m<ipython-input-44-47991d9c7397>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[0;32m      1\u001b[0m \u001b[0ma\u001b[0m \u001b[1;33m=\u001b[0m \u001b[1;34m''\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m      2\u001b[0m \u001b[1;32mif\u001b[0m \u001b[0ma\u001b[0m \u001b[1;32mis\u001b[0m \u001b[1;32mnot\u001b[0m \u001b[1;32mNone\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m----> 3\u001b[1;33m     \u001b[0mprint\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0ma\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;36m0\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m", "\u001b[1;31mIndexError\u001b[0m: string index out of range"]}], "source": ["a = ''\n", "if a is not None:\n", "    print(a[0])"]}, {"cell_type": "raw", "metadata": {}, "source": ["or even:"]}, {"cell_type": "code", "execution_count": 45, "metadata": {}, "outputs": [{"ename": "TypeError", "evalue": "object of type 'NoneType' has no len()", "output_type": "error", "traceback": ["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[1;31mTypeError\u001b[0m                                 Traceback (most recent call last)", "\u001b[1;32m<ipython-input-45-92ec20435e20>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[0;32m      1\u001b[0m \u001b[0ma\u001b[0m \u001b[1;33m=\u001b[0m \u001b[1;32mNone\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m----> 2\u001b[1;33m \u001b[1;32mif\u001b[0m \u001b[0mlen\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0ma\u001b[0m\u001b[1;33m)\u001b[0m \u001b[1;33m>\u001b[0m \u001b[1;36m0\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m      3\u001b[0m     \u001b[0mprint\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0ma\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;36m0\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n", "\u001b[1;31mTypeError\u001b[0m: object of type 'NoneType' has no len()"]}], "source": ["a = None\n", "if len(a) > 0:\n", "    print(a[0])"]}, {"cell_type": "markdown", "metadata": {}, "source": ["To be torough we would need to write:"]}, {"cell_type": "code", "execution_count": 46, "metadata": {"collapsed": true}, "outputs": [], "source": ["a = None\n", "if a is not None and len(a) > 0:\n", "    print(a[0])"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Also, the order of the boolean expressions matter here!\n", "\n", "We'll discuss this and short-circuit evaluations in an upcoming video.\n", "\n", "For example:"]}, {"cell_type": "code", "execution_count": 47, "metadata": {}, "outputs": [{"ename": "TypeError", "evalue": "object of type 'NoneType' has no len()", "output_type": "error", "traceback": ["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[1;31mTypeError\u001b[0m                                 Traceback (most recent call last)", "\u001b[1;32m<ipython-input-47-0842480c6625>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[0;32m      1\u001b[0m \u001b[0ma\u001b[0m \u001b[1;33m=\u001b[0m \u001b[1;32mNone\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m----> 2\u001b[1;33m \u001b[1;32mif\u001b[0m \u001b[0mlen\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0ma\u001b[0m\u001b[1;33m)\u001b[0m \u001b[1;33m>\u001b[0m \u001b[1;36m0\u001b[0m \u001b[1;32mand\u001b[0m \u001b[0ma\u001b[0m \u001b[1;32mis\u001b[0m \u001b[1;32mnot\u001b[0m \u001b[1;32mNone\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m      3\u001b[0m     \u001b[0mprint\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0ma\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;36m0\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n", "\u001b[1;31mTypeError\u001b[0m: object of type 'NoneType' has no len()"]}], "source": ["a = None\n", "if len(a) > 0 and a is not None:\n", "    print(a[0])"]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Booleans: Precedence and Short-Circuiting"]}, {"cell_type": "code", "execution_count": 1, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 1, "metadata": {}, "output_type": "execute_result"}], "source": ["True or True and False"]}, {"cell_type": "markdown", "metadata": {}, "source": ["this is equivalent, because of ``and`` having higer precedence than ``or``, to:"]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 3, "metadata": {}, "output_type": "execute_result"}], "source": ["True or (True and False)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["This is not the same as:"]}, {"cell_type": "code", "execution_count": 2, "metadata": {}, "outputs": [{"data": {"text/plain": ["False"]}, "execution_count": 2, "metadata": {}, "output_type": "execute_result"}], "source": ["(True or True) and False"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Short-Circuiting"]}, {"cell_type": "code", "execution_count": 13, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["a is at least double b\n"]}], "source": ["a = 10\n", "b = 2\n", "\n", "if a/b > 2:\n", "    print('a is at least double b')"]}, {"cell_type": "code", "execution_count": 12, "metadata": {}, "outputs": [{"ename": "ZeroDivisionError", "evalue": "division by zero", "output_type": "error", "traceback": ["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[1;31mZeroDivisionError\u001b[0m                         Traceback (most recent call last)", "\u001b[1;32m<ipython-input-12-98ac73a1accd>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[0;32m      2\u001b[0m \u001b[0mb\u001b[0m \u001b[1;33m=\u001b[0m \u001b[1;36m0\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m      3\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m----> 4\u001b[1;33m \u001b[1;32mif\u001b[0m \u001b[0ma\u001b[0m\u001b[1;33m/\u001b[0m\u001b[0mb\u001b[0m \u001b[1;33m>\u001b[0m \u001b[1;36m2\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m      5\u001b[0m     \u001b[0mprint\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34m'a is at least double b'\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n", "\u001b[1;31mZeroDivisionError\u001b[0m: division by zero"]}], "source": ["a = 10\n", "b = 0\n", "\n", "if a/b > 2:\n", "    print('a is at least double b')"]}, {"cell_type": "code", "execution_count": 11, "metadata": {}, "outputs": [], "source": ["a = 10\n", "b = 0\n", "\n", "if b and a/b > 2:\n", "    print('a is at least double b')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Can also be useful to deal with null or empty strings in a database:"]}, {"cell_type": "code", "execution_count": 14, "metadata": {"collapsed": true}, "outputs": [], "source": ["import string"]}, {"cell_type": "code", "execution_count": 15, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Help on module string:\n", "\n", "NAME\n", "    string - A collection of string constants.\n", "\n", "DESCRIPTION\n", "    Public module variables:\n", "    \n", "    whitespace -- a string containing all ASCII whitespace\n", "    ascii_lowercase -- a string containing all ASCII lowercase letters\n", "    ascii_uppercase -- a string containing all ASCII uppercase letters\n", "    ascii_letters -- a string containing all ASCII letters\n", "    digits -- a string containing all ASCII decimal digits\n", "    hexdigits -- a string containing all ASCII hexadecimal digits\n", "    octdigits -- a string containing all ASCII octal digits\n", "    punctuation -- a string containing all ASCII punctuation characters\n", "    printable -- a string containing all ASCII characters considered printable\n", "\n", "CLASSES\n", "    builtins.object\n", "        Formatter\n", "        Template\n", "    \n", "    class Formatter(builtins.object)\n", "     |  Methods defined here:\n", "     |  \n", "     |  check_unused_args(self, used_args, args, kwargs)\n", "     |  \n", "     |  convert_field(self, value, conversion)\n", "     |  \n", "     |  format(*args, **kwargs)\n", "     |  \n", "     |  format_field(self, value, format_spec)\n", "     |  \n", "     |  get_field(self, field_name, args, kwargs)\n", "     |      # given a field_name, find the object it references.\n", "     |      #  field_name:   the field being looked up, e.g. \"0.name\"\n", "     |      #                 or \"lookup[3]\"\n", "     |      #  used_args:    a set of which args have been used\n", "     |      #  args, kwargs: as passed in to vformat\n", "     |  \n", "     |  get_value(self, key, args, kwargs)\n", "     |  \n", "     |  parse(self, format_string)\n", "     |      # returns an iterable that contains tuples of the form:\n", "     |      # (literal_text, field_name, format_spec, conversion)\n", "     |      # literal_text can be zero length\n", "     |      # field_name can be None, in which case there's no\n", "     |      #  object to format and output\n", "     |      # if field_name is not None, it is looked up, formatted\n", "     |      #  with format_spec and conversion and then used\n", "     |  \n", "     |  vformat(self, format_string, args, kwargs)\n", "     |  \n", "     |  ----------------------------------------------------------------------\n", "     |  Data descriptors defined here:\n", "     |  \n", "     |  __dict__\n", "     |      dictionary for instance variables (if defined)\n", "     |  \n", "     |  __weakref__\n", "     |      list of weak references to the object (if defined)\n", "    \n", "    class Template(builtins.object)\n", "     |  A string class for supporting $-substitutions.\n", "     |  \n", "     |  Methods defined here:\n", "     |  \n", "     |  __init__(self, template)\n", "     |      Initialize self.  See help(type(self)) for accurate signature.\n", "     |  \n", "     |  safe_substitute(*args, **kws)\n", "     |  \n", "     |  substitute(*args, **kws)\n", "     |  \n", "     |  ----------------------------------------------------------------------\n", "     |  Data descriptors defined here:\n", "     |  \n", "     |  __dict__\n", "     |      dictionary for instance variables (if defined)\n", "     |  \n", "     |  __weakref__\n", "     |      list of weak references to the object (if defined)\n", "     |  \n", "     |  ----------------------------------------------------------------------\n", "     |  Data and other attributes defined here:\n", "     |  \n", "     |  delimiter = '$'\n", "     |  \n", "     |  flags = <RegexFlag.IGNORECASE: 2>\n", "     |  \n", "     |  idpattern = '[_a-z][_a-z0-9]*'\n", "     |  \n", "     |  pattern = re.compile('\\n    \\\\$(?:\\n      (?P<escaped>\\\\$)..._a-z][_a-...\n", "\n", "FUNCTIONS\n", "    capwords(s, sep=None)\n", "        capwords(s [,sep]) -> string\n", "        \n", "        Split the argument into words using split, capitalize each\n", "        word using capitalize, and join the capitalized words using\n", "        join.  If the optional second argument sep is absent or None,\n", "        runs of whitespace characters are replaced by a single space\n", "        and leading and trailing whitespace are removed, otherwise\n", "        sep is used to split and join the words.\n", "\n", "DATA\n", "    __all__ = ['ascii_letters', 'ascii_lowercase', 'ascii_uppercase', 'cap...\n", "    ascii_letters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n", "    ascii_lowercase = 'abcdefghijklmnopqrstuvwxyz'\n", "    ascii_uppercase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n", "    digits = '0123456789'\n", "    hexdigits = '0123456789abcdefABCDEF'\n", "    octdigits = '01234567'\n", "    printable = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTU...\n", "    punctuation = '!\"#$%&\\'()*+,-./:;<=>?@[\\\\]^_`{|}~'\n", "    whitespace = ' \\t\\n\\r\\x0b\\x0c'\n", "\n", "FILE\n", "    c:\\users\\fbapt\\anaconda3\\envs\\deepdive\\lib\\string.py\n", "\n", "\n"]}], "source": ["help(string)"]}, {"cell_type": "code", "execution_count": 16, "metadata": {}, "outputs": [{"data": {"text/plain": ["'0123456789'"]}, "execution_count": 16, "metadata": {}, "output_type": "execute_result"}], "source": ["string.digits"]}, {"cell_type": "code", "execution_count": 17, "metadata": {}, "outputs": [{"data": {"text/plain": ["'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'"]}, "execution_count": 17, "metadata": {}, "output_type": "execute_result"}], "source": ["string.ascii_letters"]}, {"cell_type": "code", "execution_count": 19, "metadata": {}, "outputs": [{"ename": "IndexError", "evalue": "string index out of range", "output_type": "error", "traceback": ["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[1;31mIndexError\u001b[0m                                Traceback (most recent call last)", "\u001b[1;32m<ipython-input-19-b6d1fe6f1f39>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[0;32m      1\u001b[0m \u001b[0mname\u001b[0m \u001b[1;33m=\u001b[0m \u001b[1;34m''\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m----> 2\u001b[1;33m \u001b[1;32mif\u001b[0m \u001b[0mname\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;36m0\u001b[0m\u001b[1;33m]\u001b[0m \u001b[1;32min\u001b[0m \u001b[0mstring\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mdigits\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m      3\u001b[0m     \u001b[0mprint\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34m'Name cannot start with a digit!'\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n", "\u001b[1;31mIndexError\u001b[0m: string index out of range"]}], "source": ["name = ''\n", "if name[0] in string.digits:\n", "    print('Name cannot start with a digit!')"]}, {"cell_type": "code", "execution_count": 20, "metadata": {"collapsed": true}, "outputs": [], "source": ["name = ''\n", "if name and name[0] in string.digits:\n", "    print('Name cannot start with a digit!')"]}, {"cell_type": "code", "execution_count": 21, "metadata": {"collapsed": true}, "outputs": [], "source": ["name = None\n", "if name and name[0] in string.digits:\n", "    print('Name cannot start with a digit!')"]}, {"cell_type": "code", "execution_count": 22, "metadata": {"collapsed": true}, "outputs": [], "source": ["name = 'Bob'\n", "if name and name[0] in string.digits:\n", "    print('Name cannot start with a digit!')"]}, {"cell_type": "code", "execution_count": 23, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Name cannot start with a digit!\n"]}], "source": ["name = '1Bob'\n", "if name and name[0] in string.digits:\n", "    print('Name cannot start with a digit!')"]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": []}, {"cell_type": "markdown", "metadata": {}, "source": ["### Booleans: Boolean Operators"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The way the Boolean operators ``and``, ``or`` actually work is a littel different in Python:"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### or"]}, {"cell_type": "markdown", "metadata": {}, "source": ["``X or Y``: If X is falsy, returns Y, otherwise evaluates and returns X"]}, {"cell_type": "code", "execution_count": 1, "metadata": {}, "outputs": [{"data": {"text/plain": ["'abc'"]}, "execution_count": 1, "metadata": {}, "output_type": "execute_result"}], "source": ["'' or 'abc'"]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [{"data": {"text/plain": ["100"]}, "execution_count": 3, "metadata": {}, "output_type": "execute_result"}], "source": ["0 or 100"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"data": {"text/plain": ["[1, 2, 3]"]}, "execution_count": 4, "metadata": {}, "output_type": "execute_result"}], "source": ["[] or [1, 2, 3]"]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"data": {"text/plain": ["[1, 2]"]}, "execution_count": 5, "metadata": {}, "output_type": "execute_result"}], "source": ["[1, 2] or [1, 2, 3]"]}, {"cell_type": "markdown", "metadata": {}, "source": ["You should note that the truth value of ``Y`` is never even considered when evaluating the ``or`` result!\n", "\n", "Only the left operand matters.\n", "\n", "Of course, Y will be evaluated if it is being returned - but its truth value does not affect how the ``or`` is being calculated.\n", "\n", "You probably will notice that this means ``Y`` is not evaluated if ``X`` is returned - short-circuiting!!!"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We could (almost!) write the ``or`` operator ourselves in this way:"]}, {"cell_type": "code", "execution_count": 15, "metadata": {"collapsed": true}, "outputs": [], "source": ["def _or(x, y):\n", "    if x:\n", "        return x\n", "    else:\n", "        return y"]}, {"cell_type": "code", "execution_count": 25, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["True\n", "True\n", "True\n"]}], "source": ["print(_or(0, 100) == (0 or 100))\n", "print(_or(None, 'n/a') == (None or 'n/a'))\n", "print(_or('abc', 'n/a') == ('abc' or 'n/a'))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Why did I say almost?\n", "\n", "Unlike the ``or`` operator, our ``_or`` function will always evaluate x and y (they are passed as arguments) - so we do not have short-circuiting!"]}, {"cell_type": "code", "execution_count": 31, "metadata": {}, "outputs": [{"data": {"text/plain": ["1"]}, "execution_count": 31, "metadata": {}, "output_type": "execute_result"}], "source": ["1 or 1/0"]}, {"cell_type": "code", "execution_count": 32, "metadata": {}, "outputs": [{"ename": "ZeroDivisionError", "evalue": "division by zero", "output_type": "error", "traceback": ["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[1;31mZeroDivisionError\u001b[0m                         Traceback (most recent call last)", "\u001b[1;32m<ipython-input-32-7b66dcdf3d9c>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[1;32m----> 1\u001b[1;33m \u001b[0m_or\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;36m1\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;36m1\u001b[0m\u001b[1;33m/\u001b[0m\u001b[1;36m0\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m", "\u001b[1;31mZeroDivisionError\u001b[0m: division by zero"]}], "source": ["_or(1, 1/0)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### and"]}, {"cell_type": "markdown", "metadata": {}, "source": ["`X and Y`: If X is falsy, returns X, otherwise evaluates and returns Y"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Once again, note that the truth value of Y is never considered when evaluating `and`, and that ``Y`` is only evaluated if it needs to be returned (short-circuiting)"]}, {"cell_type": "code", "execution_count": 33, "metadata": {"collapsed": true}, "outputs": [], "source": ["s1 = None\n", "s2 = ''\n", "s3 = 'abc'"]}, {"cell_type": "code", "execution_count": 35, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["None\n", "\n", "a\n"]}], "source": ["print(s1 and s1[0])\n", "print(s2 and s2[0])\n", "print(s3 and s3[0])"]}, {"cell_type": "code", "execution_count": 51, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["\n", "\n", "a\n"]}], "source": ["print((s1 and s1[0]) or '')\n", "print((s2 and s2[0]) or '')\n", "print((s3 and s3[0]) or '')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["This technique will also work to return any default value if ``s`` is an empty string or None:"]}, {"cell_type": "code", "execution_count": 54, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["n/a\n", "n/a\n", "a\n"]}], "source": ["print((s1 and s1[0]) or 'n/a')\n", "print((s2 and s2[0]) or 'n/a')\n", "print((s3 and s3[0]) or 'n/a')"]}, {"cell_type": "markdown", "metadata": {"collapsed": true}, "source": ["The ``not`` function"]}, {"cell_type": "code", "execution_count": 1, "metadata": {}, "outputs": [{"data": {"text/plain": ["False"]}, "execution_count": 1, "metadata": {}, "output_type": "execute_result"}], "source": ["not 'abc'"]}, {"cell_type": "code", "execution_count": 2, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 2, "metadata": {}, "output_type": "execute_result"}], "source": ["not []"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"data": {"text/plain": ["False"]}, "execution_count": 4, "metadata": {}, "output_type": "execute_result"}], "source": ["bool(None)"]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 5, "metadata": {}, "output_type": "execute_result"}], "source": ["not None"]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Comparison Operators"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Identity and Membership Operators"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The **is** and **is not** operators will work with any data type since they are comparing the memory addresses of the objects (which are integers)"]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [{"data": {"text/plain": ["False"]}, "execution_count": 3, "metadata": {}, "output_type": "execute_result"}], "source": ["0.1 is (3+4j)"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"data": {"text/plain": ["False"]}, "execution_count": 4, "metadata": {}, "output_type": "execute_result"}], "source": ["'a' is [1, 2, 3]"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The **in** and **not in** operators are used with iterables and test membership:"]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 5, "metadata": {}, "output_type": "execute_result"}], "source": ["1 in [1, 2, 3]"]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [{"data": {"text/plain": ["False"]}, "execution_count": 6, "metadata": {}, "output_type": "execute_result"}], "source": ["[1, 2] in [1, 2, 3]"]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 7, "metadata": {}, "output_type": "execute_result"}], "source": ["[1, 2] in [[1,2], [2,3], 'abc']"]}, {"cell_type": "code", "execution_count": 8, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 8, "metadata": {}, "output_type": "execute_result"}], "source": ["'key1' in {'key1': 1, 'key2': 2}"]}, {"cell_type": "code", "execution_count": 9, "metadata": {}, "outputs": [{"data": {"text/plain": ["False"]}, "execution_count": 9, "metadata": {}, "output_type": "execute_result"}], "source": ["1 in {'key1': 1, 'key2': 2}"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We'll come back to these operators in later sections on iterables and mappings."]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Equality Operators"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The **==** and **!=** operators are value comparison operators. \n", "\n", "They will work with mixed types that are comparable in some sense.\n", "\n", "For example, you can compare Fraction and Decimal objects, but it would not make sense to compare string and integer objects."]}, {"cell_type": "code", "execution_count": 10, "metadata": {}, "outputs": [{"data": {"text/plain": ["False"]}, "execution_count": 10, "metadata": {}, "output_type": "execute_result"}], "source": ["1 == '1'"]}, {"cell_type": "code", "execution_count": 11, "metadata": {"collapsed": true}, "outputs": [], "source": ["from decimal import Decimal\n", "from fractions import Fraction"]}, {"cell_type": "code", "execution_count": 12, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 12, "metadata": {}, "output_type": "execute_result"}], "source": ["Decimal('0.1') == Fraction(1, 10)"]}, {"cell_type": "code", "execution_count": 13, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 13, "metadata": {}, "output_type": "execute_result"}], "source": ["1 == 1 + 0j"]}, {"cell_type": "code", "execution_count": 14, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 14, "metadata": {}, "output_type": "execute_result"}], "source": ["True == Fraction(2, 2)"]}, {"cell_type": "code", "execution_count": 15, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 15, "metadata": {}, "output_type": "execute_result"}], "source": ["False == 0j"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Ordering Comparisons"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Many, but not all data types have an ordering defined.\n", "\n", "For example, complex numbers do not."]}, {"cell_type": "code", "execution_count": 16, "metadata": {}, "outputs": [{"ename": "TypeError", "evalue": "'<' not supported between instances of 'complex' and 'complex'", "output_type": "error", "traceback": ["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[1;31mTypeError\u001b[0m                                 Traceback (most recent call last)", "\u001b[1;32m<ipython-input-16-82ffa8a7b757>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[1;32m----> 1\u001b[1;33m \u001b[1;36m1\u001b[0m \u001b[1;33m+\u001b[0m \u001b[1;36m1j\u001b[0m \u001b[1;33m<\u001b[0m \u001b[1;36m2\u001b[0m \u001b[1;33m+\u001b[0m \u001b[1;36m2j\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m", "\u001b[1;31mTypeError\u001b[0m: '<' not supported between instances of 'complex' and 'complex'"]}], "source": ["1 + 1j < 2 + 2j"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Mixed type ordering comparisons is supported, but again, it needs to make sense:"]}, {"cell_type": "code", "execution_count": 17, "metadata": {}, "outputs": [{"ename": "TypeError", "evalue": "'<' not supported between instances of 'int' and 'str'", "output_type": "error", "traceback": ["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[1;31mTypeError\u001b[0m                                 Traceback (most recent call last)", "\u001b[1;32m<ipython-input-17-ca85dbce74b5>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[1;32m----> 1\u001b[1;33m \u001b[1;36m1\u001b[0m \u001b[1;33m<\u001b[0m \u001b[1;34m'a'\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m", "\u001b[1;31mTypeError\u001b[0m: '<' not supported between instances of 'int' and 'str'"]}], "source": ["1 < 'a'"]}, {"cell_type": "code", "execution_count": 18, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 18, "metadata": {}, "output_type": "execute_result"}], "source": ["Decimal('0.1') < Fraction(1, 2)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Chained Comparisons"]}, {"cell_type": "markdown", "metadata": {}, "source": ["It is possible to chain comparisons.\n", "\n", "For example, in **a < b < c**, Python simply **ands** the pairwise comparisons: **a < b and b < c**"]}, {"cell_type": "code", "execution_count": 19, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 19, "metadata": {}, "output_type": "execute_result"}], "source": ["1 < 2 < 3"]}, {"cell_type": "code", "execution_count": 20, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 20, "metadata": {}, "output_type": "execute_result"}], "source": ["1 < 2 > -5 < 50 > 4"]}, {"cell_type": "code", "execution_count": 29, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 29, "metadata": {}, "output_type": "execute_result"}], "source": ["1 < 2 == Decimal('2.0')"]}, {"cell_type": "code", "execution_count": 28, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 28, "metadata": {}, "output_type": "execute_result"}], "source": ["import string\n", "'A' < 'a' < 'z' > 'Z' in string.ascii_letters "]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Positional Arguments"]}, {"cell_type": "code", "execution_count": 1, "metadata": {"collapsed": true}, "outputs": [], "source": ["def my_func(a, b, c):\n", "    print(\"a={0}, b={1}, c={2}\".format(a, b, c))"]}, {"cell_type": "code", "execution_count": 2, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["a=1, b=2, c=3\n"]}], "source": ["my_func(1, 2, 3)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Default Values"]}, {"cell_type": "code", "execution_count": 3, "metadata": {"collapsed": true}, "outputs": [], "source": ["def my_func(a, b=2, c=3):\n", "    print(\"a={0}, b={1}, c={2}\".format(a, b, c))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Note that once a parameter is assigned a default value, **all** parameters thereafter **must** be asigned a default value too!"]}, {"cell_type": "markdown", "metadata": {}, "source": ["For example, this will not work:"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"ename": "SyntaxError", "evalue": "non-default argument follows default argument (<ipython-input-4-2180ec769037>, line 1)", "output_type": "error", "traceback": ["\u001b[1;36m  File \u001b[1;32m\"<ipython-input-4-2180ec769037>\"\u001b[1;36m, line \u001b[1;32m1\u001b[0m\n\u001b[1;33m    def fn(a, b=2, c):\u001b[0m\n\u001b[1;37m          ^\u001b[0m\n\u001b[1;31mSyntaxError\u001b[0m\u001b[1;31m:\u001b[0m non-default argument follows default argument\n"]}], "source": ["def fn(a, b=2, c):\n", "    print(a, b, c)"]}, {"cell_type": "code", "execution_count": 5, "metadata": {"collapsed": true}, "outputs": [], "source": ["def my_func(a, b=2, c=3):\n", "    print(\"a={0}, b={1}, c={2}\".format(a, b, c))"]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["a=10, b=20, c=30\n"]}], "source": ["my_func(10, 20, 30)"]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["a=10, b=20, c=3\n"]}], "source": ["my_func(10, 20)"]}, {"cell_type": "code", "execution_count": 8, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["a=10, b=2, c=3\n"]}], "source": ["my_func(10)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Since **a** does not have a default value, it **must** be specified:"]}, {"cell_type": "code", "execution_count": 9, "metadata": {}, "outputs": [{"ename": "TypeError", "evalue": "my_func() missing 1 required positional argument: 'a'", "output_type": "error", "traceback": ["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[1;31mTypeError\u001b[0m                                 Traceback (most recent call last)", "\u001b[1;32m<ipython-input-9-d82eda95de40>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[1;32m----> 1\u001b[1;33m \u001b[0mmy_func\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m", "\u001b[1;31mTypeError\u001b[0m: my_func() missing 1 required positional argument: 'a'"]}], "source": ["my_func()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Keyword Arguments (named arguments)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Positional arguments, can **optionally**, be specified using their corresponding parameter name.\n", "\n", "This allows us to pass the arguments without using the positional assignment:"]}, {"cell_type": "code", "execution_count": 10, "metadata": {"collapsed": true}, "outputs": [], "source": ["def my_func(a, b=2, c=3):\n", "    print(\"a={0}, b={1}, c={2}\".format(a, b, c))"]}, {"cell_type": "code", "execution_count": 11, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["a=10, b=20, c=30\n"]}], "source": ["my_func(c=30, b=20, a=10)"]}, {"cell_type": "code", "execution_count": 12, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["a=10, b=20, c=30\n"]}], "source": ["my_func(10, c=30, b=20)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Note that once a keyword argument has been used, **all** arguments thereafter **must** also be named:"]}, {"cell_type": "code", "execution_count": 13, "metadata": {}, "outputs": [{"ename": "SyntaxError", "evalue": "positional argument follows keyword argument (<ipython-input-13-ea05eeab2151>, line 1)", "output_type": "error", "traceback": ["\u001b[1;36m  File \u001b[1;32m\"<ipython-input-13-ea05eeab2151>\"\u001b[1;36m, line \u001b[1;32m1\u001b[0m\n\u001b[1;33m    my_func(10, b=20, 30)\u001b[0m\n\u001b[1;37m                     ^\u001b[0m\n\u001b[1;31mSyntaxError\u001b[0m\u001b[1;31m:\u001b[0m positional argument follows keyword argument\n"]}], "source": ["my_func(10, b=20, 30)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["However, if a parameter has a default value, it *can* be omitted from the argument list, named or not:"]}, {"cell_type": "code", "execution_count": 15, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["a=10, b=2, c=30\n"]}], "source": ["my_func(10, c=30)"]}, {"cell_type": "code", "execution_count": 16, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["a=30, b=2, c=10\n"]}], "source": ["my_func(a=30, c=10)"]}, {"cell_type": "code", "execution_count": 17, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["a=30, b=2, c=10\n"]}], "source": ["my_func(c=10, a=30)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Unpacking Iterables"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Side Note on Tuples"]}, {"cell_type": "markdown", "metadata": {"collapsed": true}, "source": ["This is a tuple:"]}, {"cell_type": "code", "execution_count": 1, "metadata": {"collapsed": true}, "outputs": [], "source": ["a = (1, 2, 3)"]}, {"cell_type": "code", "execution_count": 2, "metadata": {}, "outputs": [{"data": {"text/plain": ["tuple"]}, "execution_count": 2, "metadata": {}, "output_type": "execute_result"}], "source": ["type(a)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["This is also a tuple:"]}, {"cell_type": "code", "execution_count": 3, "metadata": {"collapsed": true}, "outputs": [], "source": ["a = 1, 2, 3"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"data": {"text/plain": ["tuple"]}, "execution_count": 4, "metadata": {}, "output_type": "execute_result"}], "source": ["type(a)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["In fact what defines a tuple is not **()**, but the **,** (comma)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["To create a tuple with a single element:"]}, {"cell_type": "code", "execution_count": 5, "metadata": {"collapsed": true}, "outputs": [], "source": ["a = (1)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["will not work!!"]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [{"data": {"text/plain": ["int"]}, "execution_count": 6, "metadata": {}, "output_type": "execute_result"}], "source": ["type(a)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Instead, we have to use a comma:"]}, {"cell_type": "code", "execution_count": 7, "metadata": {"collapsed": true}, "outputs": [], "source": ["a = (1,)"]}, {"cell_type": "code", "execution_count": 8, "metadata": {}, "outputs": [{"data": {"text/plain": ["tuple"]}, "execution_count": 8, "metadata": {}, "output_type": "execute_result"}], "source": ["type(a)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["And in fact, we don't even need the **()**:"]}, {"cell_type": "code", "execution_count": 9, "metadata": {"collapsed": true}, "outputs": [], "source": ["a = 1,"]}, {"cell_type": "code", "execution_count": 10, "metadata": {}, "outputs": [{"data": {"text/plain": ["tuple"]}, "execution_count": 10, "metadata": {}, "output_type": "execute_result"}], "source": ["type(a)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The only exception is to create an empty tuple:"]}, {"cell_type": "code", "execution_count": 11, "metadata": {"collapsed": true}, "outputs": [], "source": ["a = ()"]}, {"cell_type": "code", "execution_count": 12, "metadata": {}, "outputs": [{"data": {"text/plain": ["tuple"]}, "execution_count": 12, "metadata": {}, "output_type": "execute_result"}], "source": ["type(a)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Or we can use the tuple constructor:"]}, {"cell_type": "code", "execution_count": 13, "metadata": {"collapsed": true}, "outputs": [], "source": ["a = tuple()"]}, {"cell_type": "code", "execution_count": 14, "metadata": {}, "outputs": [{"data": {"text/plain": ["tuple"]}, "execution_count": 14, "metadata": {}, "output_type": "execute_result"}], "source": ["type(a)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Unpacking"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Unpacking is a way to split an iterable object into individual variables contained in a list or tuple: "]}, {"cell_type": "code", "execution_count": 15, "metadata": {"collapsed": true}, "outputs": [], "source": ["l = [1, 2, 3, 4]"]}, {"cell_type": "code", "execution_count": 16, "metadata": {"collapsed": true}, "outputs": [], "source": ["a, b, c, d = l"]}, {"cell_type": "code", "execution_count": 17, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1 2 3 4\n"]}], "source": ["print(a, b, c, d)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Strings are iterables too:"]}, {"cell_type": "code", "execution_count": 18, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["X Y Z\n"]}], "source": ["a, b, c = 'XYZ'\n", "print(a, b, c)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Swapping Two Variables"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Here's a quick application of unpacking to swap the values of two variables."]}, {"cell_type": "markdown", "metadata": {}, "source": ["First we look at the \"traditional\" way you would have to do it in other languages such as Java:"]}, {"cell_type": "code", "execution_count": 19, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["a=10, b=20\n", "a=20, b=10\n"]}], "source": ["a = 10\n", "b = 20\n", "print(\"a={0}, b={1}\".format(a, b))\n", "\n", "tmp = a\n", "a = b\n", "b = tmp\n", "print(\"a={0}, b={1}\".format(a, b))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But using unpacking we can simplify this:"]}, {"cell_type": "code", "execution_count": 20, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["a=10, b=20\n", "a=20, b=10\n"]}], "source": ["a = 10\n", "b = 20\n", "print(\"a={0}, b={1}\".format(a, b))\n", "\n", "a, b = b, a\n", "print(\"a={0}, b={1}\".format(a, b))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["In fact, we can even simplify the initial assignment of values to a and b as follows:"]}, {"cell_type": "code", "execution_count": 21, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["a=10, b=20\n", "a=20, b=10\n"]}], "source": ["a, b = 10, 20\n", "print(\"a={0}, b={1}\".format(a, b))\n", "\n", "a, b = b, a\n", "print(\"a={0}, b={1}\".format(a, b))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Unpacking Unordered Objects"]}, {"cell_type": "code", "execution_count": 22, "metadata": {"collapsed": true}, "outputs": [], "source": ["dict1 = {'p': 1, 'y': 2, 't': 3, 'h': 4, 'o': 5, 'n': 6}"]}, {"cell_type": "code", "execution_count": 23, "metadata": {}, "outputs": [{"data": {"text/plain": ["{'h': 4, 'n': 6, 'o': 5, 'p': 1, 't': 3, 'y': 2}"]}, "execution_count": 23, "metadata": {}, "output_type": "execute_result"}], "source": ["dict1"]}, {"cell_type": "code", "execution_count": 24, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["p\n", "y\n", "t\n", "h\n", "o\n", "n\n"]}], "source": ["for c in dict1:\n", "    print(c)"]}, {"cell_type": "code", "execution_count": 25, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["p\n", "y\n", "t\n", "h\n", "o\n", "n\n"]}], "source": ["a, b, c, d, e, f = dict1\n", "print(a)\n", "print(b)\n", "print(c)\n", "print(d)\n", "print(e)\n", "print(f)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Note that this order is not guaranteed. You can always use an OrderedDict if that is a requirement."]}, {"cell_type": "markdown", "metadata": {}, "source": ["The same applies to sets."]}, {"cell_type": "code", "execution_count": 26, "metadata": {"collapsed": true}, "outputs": [], "source": ["s = {'p', 'y', 't', 'h', 'o', 'n'}"]}, {"cell_type": "code", "execution_count": 27, "metadata": {}, "outputs": [{"data": {"text/plain": ["set"]}, "execution_count": 27, "metadata": {}, "output_type": "execute_result"}], "source": ["type(s)"]}, {"cell_type": "code", "execution_count": 28, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["{'p', 't', 'y', 'n', 'o', 'h'}\n"]}], "source": ["print(s)"]}, {"cell_type": "code", "execution_count": 29, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["p\n", "t\n", "y\n", "n\n", "o\n", "h\n"]}], "source": ["for c in s:\n", "    print(c)"]}, {"cell_type": "code", "execution_count": 30, "metadata": {"collapsed": true}, "outputs": [], "source": ["a, b, c, d, e, f = s"]}, {"cell_type": "code", "execution_count": 31, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["p\n", "t\n", "y\n", "n\n", "o\n", "h\n"]}], "source": ["print(a)\n", "print(b)\n", "print(c)\n", "print(d)\n", "print(e)\n", "print(f)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Extended Unpacking"]}, {"cell_type": "markdown", "metadata": {"collapsed": true}, "source": ["Let's see how we might split a list into it's first element, and \"everything else\" using slicing:"]}, {"cell_type": "code", "execution_count": 1, "metadata": {"collapsed": true}, "outputs": [], "source": ["l = [1, 2, 3, 4, 5, 6]"]}, {"cell_type": "code", "execution_count": 2, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1\n", "[2, 3, 4, 5, 6]\n"]}], "source": ["a = l[0]\n", "b = l[1:]\n", "print(a)\n", "print(b)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can even use unpacking to simplify this slightly:"]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1\n", "[2, 3, 4, 5, 6]\n"]}], "source": ["a, b = l[0], l[1:]\n", "print(a)\n", "print(b)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But we can use the **\\*** operator to achieve the same result:"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1\n", "[2, 3, 4, 5, 6]\n"]}], "source": ["a, *b = l\n", "print(a)\n", "print(b)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Note that the **\\*** operator can only appear **once**!"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Like standard unpacking, this extended unpacking will work with any iterable."]}, {"cell_type": "markdown", "metadata": {}, "source": ["With tuples:"]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["-10\n", "[5, 2, 100]\n"]}], "source": ["a, *b = -10, 5, 2, 100\n", "print(a)\n", "print(b)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["With strings:"]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["p\n", "['y', 't', 'h', 'o', 'n']\n"]}], "source": ["a, *b = 'python'\n", "print(a)\n", "print(b)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["What about extracting the first, second, last elements and *the rest*."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Again we can use slicing:"]}, {"cell_type": "code", "execution_count": 9, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["p\n", "y\n", "tho\n", "n\n"]}], "source": ["s = 'python'\n", "\n", "a, b, c, d = s[0], s[1], s[2:-1], s[-1]\n", "print(a)\n", "print(b)\n", "print(c)\n", "print(d)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But we can just as easily do it this way using unpacking:"]}, {"cell_type": "code", "execution_count": 13, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["p\n", "y\n", "['t', 'h', 'o']\n", "n\n"]}], "source": ["a, b, *c, d = s\n", "print(a)\n", "print(b)\n", "print(c)\n", "print(d)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see though, **c** is a list of characters, not a string.\n", "\n", "It that's a problem we can easily fix it this way:"]}, {"cell_type": "code", "execution_count": 11, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["['t', 'h', 'o']\n", "tho\n"]}], "source": ["print(c)\n", "c = ''.join(c)\n", "print(c)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can also use unpacking on the right hand side of an assignment expression:"]}, {"cell_type": "code", "execution_count": 51, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["[1, 2, 3, 4, 5, 6]\n"]}], "source": ["l1 = [1, 2, 3]\n", "l2 = [4, 5, 6]\n", "l = [*l1, *l2]\n", "print(l)"]}, {"cell_type": "code", "execution_count": 53, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["[1, 2, 3, 'A', 'B', 'C']\n"]}], "source": ["l1 = [1, 2, 3]\n", "s = 'ABC'\n", "l = [*l1, *s]\n", "print(l)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["This unpacking works with unordered types such as sets and dictionaries as well.\n", "\n", "The only thing is that it may not be very useful considering there is no particular ordering, so a first or last element has no real useful meaning."]}, {"cell_type": "code", "execution_count": 15, "metadata": {"collapsed": true}, "outputs": [], "source": ["s = {10, -99, 3, 'd'}"]}, {"cell_type": "code", "execution_count": 16, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["10\n", "3\n", "d\n", "-99\n"]}], "source": ["for c in s:\n", "    print(c)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see, the order of the elements when we created the set was not retained!"]}, {"cell_type": "code", "execution_count": 54, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["10\n", "3\n", "['d', -99]\n"]}], "source": ["s = {10, -99, 3, 'd'}\n", "a, b, *c = s\n", "print(a)\n", "print(b)\n", "print(c)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["So unpacking this way is of limited use.\n", "\n", "However consider this:"]}, {"cell_type": "code", "execution_count": 55, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["[10, 3, 'd', -99]\n"]}], "source": ["s = {10, -99, 3, 'd'}\n", "*a, = s\n", "print(a)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["At first blush, this doesn't look terribly exciting - we simply unpacked the set values into a list.\n", "\n", "But this is actually quite useful in both sets and dictionaries to combine things (although to be sure, there are alternative ways to do this as well - which we'll cover later in this course)"]}, {"cell_type": "code", "execution_count": 21, "metadata": {"collapsed": true}, "outputs": [], "source": ["s1 = {1, 2, 3}\n", "s2 = {3, 4, 5}"]}, {"cell_type": "markdown", "metadata": {}, "source": ["How can we combine both these sets into a single merged set?"]}, {"cell_type": "code", "execution_count": 22, "metadata": {}, "outputs": [{"ename": "TypeError", "evalue": "unsupported operand type(s) for +: 'set' and 'set'", "output_type": "error", "traceback": ["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[1;31mTypeError\u001b[0m                                 Traceback (most recent call last)", "\u001b[1;32m<ipython-input-22-1659087814e1>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[1;32m----> 1\u001b[1;33m \u001b[0ms1\u001b[0m \u001b[1;33m+\u001b[0m \u001b[0ms2\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m", "\u001b[1;31mTypeError\u001b[0m: unsupported operand type(s) for +: 'set' and 'set'"]}], "source": ["s1 + s2"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Well, **+** doesn't work..."]}, {"cell_type": "markdown", "metadata": {}, "source": ["We could use the built-in method for unioning sets:"]}, {"cell_type": "code", "execution_count": 23, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Help on class set in module builtins:\n", "\n", "class set(object)\n", " |  set() -> new empty set object\n", " |  set(iterable) -> new set object\n", " |  \n", " |  Build an unordered collection of unique elements.\n", " |  \n", " |  Methods defined here:\n", " |  \n", " |  __and__(self, value, /)\n", " |      Return self&value.\n", " |  \n", " |  __contains__(...)\n", " |      x.__contains__(y) <==> y in x.\n", " |  \n", " |  __eq__(self, value, /)\n", " |      Return self==value.\n", " |  \n", " |  __ge__(self, value, /)\n", " |      Return self>=value.\n", " |  \n", " |  __getattribute__(self, name, /)\n", " |      Return getattr(self, name).\n", " |  \n", " |  __gt__(self, value, /)\n", " |      Return self>value.\n", " |  \n", " |  __iand__(self, value, /)\n", " |      Return self&=value.\n", " |  \n", " |  __init__(self, /, *args, **kwargs)\n", " |      Initialize self.  See help(type(self)) for accurate signature.\n", " |  \n", " |  __ior__(self, value, /)\n", " |      Return self|=value.\n", " |  \n", " |  __isub__(self, value, /)\n", " |      Return self-=value.\n", " |  \n", " |  __iter__(self, /)\n", " |      Implement iter(self).\n", " |  \n", " |  __ixor__(self, value, /)\n", " |      Return self^=value.\n", " |  \n", " |  __le__(self, value, /)\n", " |      Return self<=value.\n", " |  \n", " |  __len__(self, /)\n", " |      Return len(self).\n", " |  \n", " |  __lt__(self, value, /)\n", " |      Return self<value.\n", " |  \n", " |  __ne__(self, value, /)\n", " |      Return self!=value.\n", " |  \n", " |  __new__(*args, **kwargs) from builtins.type\n", " |      Create and return a new object.  See help(type) for accurate signature.\n", " |  \n", " |  __or__(self, value, /)\n", " |      Return self|value.\n", " |  \n", " |  __rand__(self, value, /)\n", " |      Return value&self.\n", " |  \n", " |  __reduce__(...)\n", " |      Return state information for pickling.\n", " |  \n", " |  __repr__(self, /)\n", " |      Return repr(self).\n", " |  \n", " |  __ror__(self, value, /)\n", " |      Return value|self.\n", " |  \n", " |  __rsub__(self, value, /)\n", " |      Return value-self.\n", " |  \n", " |  __rxor__(self, value, /)\n", " |      Return value^self.\n", " |  \n", " |  __sizeof__(...)\n", " |      S.__sizeof__() -> size of S in memory, in bytes\n", " |  \n", " |  __sub__(self, value, /)\n", " |      Return self-value.\n", " |  \n", " |  __xor__(self, value, /)\n", " |      Return self^value.\n", " |  \n", " |  add(...)\n", " |      Add an element to a set.\n", " |      \n", " |      This has no effect if the element is already present.\n", " |  \n", " |  clear(...)\n", " |      Remove all elements from this set.\n", " |  \n", " |  copy(...)\n", " |      Return a shallow copy of a set.\n", " |  \n", " |  difference(...)\n", " |      Return the difference of two or more sets as a new set.\n", " |      \n", " |      (i.e. all elements that are in this set but not the others.)\n", " |  \n", " |  difference_update(...)\n", " |      Remove all elements of another set from this set.\n", " |  \n", " |  discard(...)\n", " |      Remove an element from a set if it is a member.\n", " |      \n", " |      If the element is not a member, do nothing.\n", " |  \n", " |  intersection(...)\n", " |      Return the intersection of two sets as a new set.\n", " |      \n", " |      (i.e. all elements that are in both sets.)\n", " |  \n", " |  intersection_update(...)\n", " |      Update a set with the intersection of itself and another.\n", " |  \n", " |  isdisjoint(...)\n", " |      Return True if two sets have a null intersection.\n", " |  \n", " |  issubset(...)\n", " |      Report whether another set contains this set.\n", " |  \n", " |  issuperset(...)\n", " |      Report whether this set contains another set.\n", " |  \n", " |  pop(...)\n", " |      Remove and return an arbitrary set element.\n", " |      Raises KeyError if the set is empty.\n", " |  \n", " |  remove(...)\n", " |      Remove an element from a set; it must be a member.\n", " |      \n", " |      If the element is not a member, raise a KeyError.\n", " |  \n", " |  symmetric_difference(...)\n", " |      Return the symmetric difference of two sets as a new set.\n", " |      \n", " |      (i.e. all elements that are in exactly one of the sets.)\n", " |  \n", " |  symmetric_difference_update(...)\n", " |      Update a set with the symmetric difference of itself and another.\n", " |  \n", " |  union(...)\n", " |      Return the union of sets as a new set.\n", " |      \n", " |      (i.e. all elements that are in either set.)\n", " |  \n", " |  update(...)\n", " |      Update a set with the union of itself and others.\n", " |  \n", " |  ----------------------------------------------------------------------\n", " |  Data and other attributes defined here:\n", " |  \n", " |  __hash__ = None\n", "\n"]}], "source": ["help(set)"]}, {"cell_type": "code", "execution_count": 25, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["{1, 2, 3}\n", "{3, 4, 5}\n"]}, {"data": {"text/plain": ["{1, 2, 3, 4, 5}"]}, "execution_count": 25, "metadata": {}, "output_type": "execute_result"}], "source": ["print(s1)\n", "print(s2)\n", "s1.union(s2)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["What about joining 4 different sets?"]}, {"cell_type": "code", "execution_count": 57, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["{1, 2, 3, 4, 5, 6, 7, 8, 9}\n", "{1, 2, 3, 4, 5, 6, 7, 8, 9}\n"]}], "source": ["s1 = {1, 2, 3}\n", "s2 = {3, 4, 5}\n", "s3 = {5, 6, 7}\n", "s4 = {7, 8, 9}\n", "print(s1.union(s2).union(s3).union(s4))\n", "print(s1.union(s2, s3, s4))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Or we could use unpacking in this way:"]}, {"cell_type": "code", "execution_count": 27, "metadata": {}, "outputs": [{"data": {"text/plain": ["{1, 2, 3, 4, 5, 6, 7, 8, 9}"]}, "execution_count": 27, "metadata": {}, "output_type": "execute_result"}], "source": ["{*s1, *s2, *s3, *s4}"]}, {"cell_type": "markdown", "metadata": {}, "source": ["What we did here was to unpack each set directly into another set!"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The same works for dictionaries - just remember that **\\*** for dictionaries unpacks the keys only."]}, {"cell_type": "code", "execution_count": 29, "metadata": {}, "outputs": [{"data": {"text/plain": ["['key1', 'key2', 'key2', 'key3']"]}, "execution_count": 29, "metadata": {}, "output_type": "execute_result"}], "source": ["d1 = {'key1': 1, 'key2': 2}\n", "d2 = {'key2': 3, 'key3': 3}\n", "[*d1, *d2]"]}, {"cell_type": "markdown", "metadata": {}, "source": ["So, is there anything to unpack the key-value pairs for dictionaries instead of just the keys?"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Yes - we can use the **\\*\\*** operator:"]}, {"cell_type": "code", "execution_count": 30, "metadata": {}, "outputs": [{"data": {"text/plain": ["{'key1': 1, 'key2': 3, 'key3': 3}"]}, "execution_count": 30, "metadata": {}, "output_type": "execute_result"}], "source": ["d1 = {'key1': 1, 'key2': 2}\n", "d2 = {'key2': 3, 'key3': 3}\n", "\n", "{**d1, **d2}"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Notice what happened to the value of **key2**. The value for the second occurrence of **key2** was retained (overwritten)."]}, {"cell_type": "markdown", "metadata": {}, "source": ["In fact, if we write the unpacking reversing the order of d1 and d2:"]}, {"cell_type": "code", "execution_count": 31, "metadata": {}, "outputs": [{"data": {"text/plain": ["{'key1': 1, 'key2': 2, 'key3': 3}"]}, "execution_count": 31, "metadata": {}, "output_type": "execute_result"}], "source": ["{**d2, **d1}"]}, {"cell_type": "markdown", "metadata": {}, "source": ["we see that the value of **key2** is now **2**, since it was the second occurrence."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Of course, we can unpack a dictionary into a dictionary as seen above, but we can mix in our own key-value pairs as well - it is just a dictionary literal after all."]}, {"cell_type": "code", "execution_count": 32, "metadata": {}, "outputs": [{"data": {"text/plain": ["{'a': 1, 'b': 2, 'c': 3, 'key1': 1, 'key2': 3, 'key3': 3}"]}, "execution_count": 32, "metadata": {}, "output_type": "execute_result"}], "source": ["{'a': 1, 'b': 2, **d1, **d2, 'c':3}"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Again, if we have the same keys, only the \"latest\" value of the key is retained:"]}, {"cell_type": "code", "execution_count": 33, "metadata": {}, "outputs": [{"data": {"text/plain": ["{'key1': 1, 'key2': 3, 'key3': 200}"]}, "execution_count": 33, "metadata": {}, "output_type": "execute_result"}], "source": ["{'key1': 100, **d1, **d2, 'key3': 200}"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Nested Unpacking"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Python even supports nested unpacking:"]}, {"cell_type": "code", "execution_count": 36, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1\n", "2\n", "X\n", "Y\n"]}], "source": ["a, b, (c, d) = [1, 2, ['X', 'Y']]\n", "print(a)\n", "print(b)\n", "print(c)\n", "print(d)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["In fact, since a string is an iterable, we can even write:"]}, {"cell_type": "code", "execution_count": 37, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1\n", "2\n", "X\n", "Y\n"]}], "source": ["a, b, (c, d) = [1, 2, 'XY']\n", "print(a)\n", "print(b)\n", "print(c)\n", "print(d)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can even write something like this:"]}, {"cell_type": "code", "execution_count": 38, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1\n", "2\n", "p\n", "y\n", "['t', 'h', 'o', 'n']\n"]}], "source": ["a, b, (c, d, *e) = [1, 2, 'python']\n", "print(a)\n", "print(b)\n", "print(c)\n", "print(d)\n", "print(e)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Remember when we said that we can use a * only **once**..."]}, {"cell_type": "markdown", "metadata": {}, "source": ["How about this then?"]}, {"cell_type": "code", "execution_count": 39, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1\n", "[2, 3]\n", "p\n", "y\n", "['t', 'h', 'o', 'n']\n"]}], "source": ["a, *b, (c, d, *e) = [1, 2, 3, 'python']\n", "print(a)\n", "print(b)\n", "print(c)\n", "print(d)\n", "print(e)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can break down what happened here in multiple steps:"]}, {"cell_type": "code", "execution_count": 40, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1\n", "[2, 3]\n", "python\n"]}], "source": ["a, *b, tmp = [1, 2, 3, 'python']\n", "print(a)\n", "print(b)\n", "print(tmp)"]}, {"cell_type": "code", "execution_count": 41, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["p\n", "y\n", "['t', 'h', 'o', 'n']\n"]}], "source": ["c, d, *e = tmp\n", "print(c)\n", "print(d)\n", "print(e)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["So putting it together we get our original line of code:"]}, {"cell_type": "code", "execution_count": 68, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1\n", "[2, 3]\n", "p\n", "y\n", "['t', 'h', 'o', 'n']\n"]}], "source": ["a, *b, (c, d, *e) = [1, 2, 3, 'python']\n", "print(a)\n", "print(b)\n", "print(c)\n", "print(d)\n", "print(e)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["If we wanted to do the same thing using slicing:"]}, {"cell_type": "code", "execution_count": 1, "metadata": {}, "outputs": [{"data": {"text/plain": ["(1, [2, 3], 'p', 'y', ['t', 'h', 'o', 'n'])"]}, "execution_count": 1, "metadata": {}, "output_type": "execute_result"}], "source": ["l = [1, 2, 3, 'python']\n", "l[0], l[1:-1], l[-1][0], l[-1][1], list(l[-1][2:])"]}, {"cell_type": "code", "execution_count": 2, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1\n", "[2, 3]\n", "p\n", "y\n", "['t', 'h', 'o', 'n']\n"]}], "source": ["l = [1, 2, 3, 'python']\n", "a, b, c, d, e = l[0], l[1:-1], l[-1][0], l[-1][1], list(l[-1][2:])\n", "print(a)\n", "print(b)\n", "print(c)\n", "print(d)\n", "print(e)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Of course, this works for arbitrary lengths and indexable sequence types:"]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1\n", "[2, 3, 4]\n", "u\n", "n\n", "['l', 'a', 'd', 'e', 'n', ' ', 's', 'w', 'a', 'l', 'l', 'o', 'w']\n"]}], "source": ["l = [1, 2, 3, 4, 'unladen swallow']\n", "a, b, c, d, e = l[0], l[1:-1], l[-1][0], l[-1][1], list(l[-1][2:])\n", "print(a)\n", "print(b)\n", "print(c)\n", "print(d)\n", "print(e)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["or even:"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1\n", "[2, 3, 4]\n", "a\n", "b\n", "['c', 'd']\n"]}], "source": ["l = [1, 2, 3, 4, ['a', 'b', 'c', 'd']]\n", "a, b, c, d, e = l[0], l[1:-1], l[-1][0], l[-1][1], list(l[-1][2:])\n", "print(a)\n", "print(b)\n", "print(c)\n", "print(d)\n", "print(e)"]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": []}, {"cell_type": "markdown", "metadata": {}, "source": ["### \\*args"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Recall from iterable unpacking:"]}, {"cell_type": "code", "execution_count": 10, "metadata": {"collapsed": true}, "outputs": [], "source": ["a, b, *c = 10, 20, 'a', 'b'"]}, {"cell_type": "code", "execution_count": 11, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["10 20\n"]}], "source": ["print(a, b)"]}, {"cell_type": "code", "execution_count": 12, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["['a', 'b']\n"]}], "source": ["print(c)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can use a similar concept in function definitions to allow for arbitrary numbers of **positional** parameters/arguments:"]}, {"cell_type": "code", "execution_count": 13, "metadata": {"collapsed": true}, "outputs": [], "source": ["def func1(a, b, *args):\n", "    print(a)\n", "    print(b)\n", "    print(args)"]}, {"cell_type": "code", "execution_count": 14, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1\n", "2\n", "('a', 'b')\n"]}], "source": ["func1(1, 2, 'a', 'b')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["A few things to note:"]}, {"cell_type": "markdown", "metadata": {}, "source": ["1. Unlike iterable unpacking, **\\*args** will be a **tuple**, not a list.\n", "\n", "2. The name of the parameter **args** can be anything you prefer\n", "\n", "3. You cannot specify positional arguments **after** the **\\*args** parameter - this does something different that we'll cover in the next lecture."]}, {"cell_type": "code", "execution_count": 15, "metadata": {}, "outputs": [], "source": ["def func1(a, b, *my_vars):\n", "    print(a)\n", "    print(b)\n", "    print(my_vars)"]}, {"cell_type": "code", "execution_count": 16, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["10\n", "20\n", "('a', 'b', 'c')\n"]}], "source": ["func1(10, 20, 'a', 'b', 'c')"]}, {"cell_type": "code", "execution_count": 17, "metadata": {"collapsed": true}, "outputs": [], "source": ["def func1(a, b, *c, d):\n", "    print(a)\n", "    print(b)\n", "    print(c)\n", "    print(d)"]}, {"cell_type": "code", "execution_count": 18, "metadata": {}, "outputs": [{"ename": "TypeError", "evalue": "func1() missing 1 required keyword-only argument: 'd'", "output_type": "error", "traceback": ["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[1;31mTypeError\u001b[0m                                 Traceback (most recent call last)", "\u001b[1;32m<ipython-input-18-50a3343cf093>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[1;32m----> 1\u001b[1;33m \u001b[0mfunc1\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;36m10\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;36m20\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;34m'a'\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;34m'b'\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;36m100\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m", "\u001b[1;31mTypeError\u001b[0m: func1() missing 1 required keyword-only argument: 'd'"]}], "source": ["func1(10, 20, 'a', 'b', 100)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's see how we might use this to calculate the average of an arbitrary number of parameters."]}, {"cell_type": "code", "execution_count": 19, "metadata": {}, "outputs": [], "source": ["def avg(*args):\n", "    count = len(args)\n", "    total = sum(args)\n", "    return total/count"]}, {"cell_type": "code", "execution_count": 20, "metadata": {}, "outputs": [{"data": {"text/plain": ["3.0"]}, "execution_count": 20, "metadata": {}, "output_type": "execute_result"}], "source": ["avg(2, 2, 4, 4)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But watch what happens here:"]}, {"cell_type": "code", "execution_count": 21, "metadata": {}, "outputs": [{"ename": "ZeroDivisionError", "evalue": "division by zero", "output_type": "error", "traceback": ["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[1;31mZeroDivisionError\u001b[0m                         Traceback (most recent call last)", "\u001b[1;32m<ipython-input-21-867ab4243063>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[1;32m----> 1\u001b[1;33m \u001b[0mavg\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m", "\u001b[1;32m<ipython-input-19-03b621c670aa>\u001b[0m in \u001b[0;36mavg\u001b[1;34m(*args)\u001b[0m\n\u001b[0;32m      2\u001b[0m     \u001b[0mcount\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mlen\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0margs\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m      3\u001b[0m     \u001b[0mtotal\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0msum\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0margs\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m----> 4\u001b[1;33m     \u001b[1;32mreturn\u001b[0m \u001b[0mtotal\u001b[0m\u001b[1;33m/\u001b[0m\u001b[0mcount\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m", "\u001b[1;31mZeroDivisionError\u001b[0m: division by zero"]}], "source": ["avg()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The problem is that we passed zero arguments.\n", "\n", "We can fix this in one of two ways:"]}, {"cell_type": "code", "execution_count": 22, "metadata": {}, "outputs": [], "source": ["def avg(*args):\n", "    count = len(args)\n", "    total = sum(args)\n", "    if count == 0:\n", "        return 0\n", "    else:\n", "        return total/count"]}, {"cell_type": "code", "execution_count": 23, "metadata": {}, "outputs": [{"data": {"text/plain": ["3.0"]}, "execution_count": 23, "metadata": {}, "output_type": "execute_result"}], "source": ["avg(2, 2, 4, 4)"]}, {"cell_type": "code", "execution_count": 24, "metadata": {}, "outputs": [{"data": {"text/plain": ["0"]}, "execution_count": 24, "metadata": {}, "output_type": "execute_result"}], "source": ["avg()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But we may not want to allow specifying zero arguments, in which case we can split our parameters into a required (non-defaulted) positional argument, and the rest:"]}, {"cell_type": "code", "execution_count": 25, "metadata": {"collapsed": true}, "outputs": [], "source": ["def avg(a, *args):\n", "    count = len(args) + 1\n", "    total = a + sum(args)\n", "    return total/count"]}, {"cell_type": "code", "execution_count": 26, "metadata": {}, "outputs": [{"data": {"text/plain": ["3.0"]}, "execution_count": 26, "metadata": {}, "output_type": "execute_result"}], "source": ["avg(2, 2, 4, 4)"]}, {"cell_type": "code", "execution_count": 27, "metadata": {}, "outputs": [{"ename": "TypeError", "evalue": "avg() missing 1 required positional argument: 'a'", "output_type": "error", "traceback": ["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[1;31mTypeError\u001b[0m                                 Traceback (most recent call last)", "\u001b[1;32m<ipython-input-27-867ab4243063>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[1;32m----> 1\u001b[1;33m \u001b[0mavg\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m", "\u001b[1;31mTypeError\u001b[0m: avg() missing 1 required positional argument: 'a'"]}], "source": ["avg()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see, an exception occurs if we do not specify at least one argument."]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Unpacking an iterable into positional arguments"]}, {"cell_type": "code", "execution_count": 28, "metadata": {"collapsed": true}, "outputs": [], "source": ["def func1(a, b, c):\n", "    print(a)\n", "    print(b)\n", "    print(c)"]}, {"cell_type": "code", "execution_count": 29, "metadata": {"collapsed": true}, "outputs": [], "source": ["l = [10, 20, 30]"]}, {"cell_type": "markdown", "metadata": {}, "source": ["This will **not** work:"]}, {"cell_type": "code", "execution_count": 30, "metadata": {"scrolled": true}, "outputs": [{"ename": "TypeError", "evalue": "func1() missing 2 required positional arguments: 'b' and 'c'", "output_type": "error", "traceback": ["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[1;31mTypeError\u001b[0m                                 Traceback (most recent call last)", "\u001b[1;32m<ipython-input-30-3255f48773bf>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[1;32m----> 1\u001b[1;33m \u001b[0mfunc1\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0ml\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m", "\u001b[1;31mTypeError\u001b[0m: func1() missing 2 required positional arguments: 'b' and 'c'"]}], "source": ["func1(l)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The function expects three positional arguments, but we only supplied a single one (albeit a list).\n", "\n", "But we could unpack the list, and **then** pass it to as the function arguments:"]}, {"cell_type": "code", "execution_count": 31, "metadata": {}, "outputs": [{"data": {"text/plain": ["(10, 20, 30)"]}, "execution_count": 31, "metadata": {}, "output_type": "execute_result"}], "source": ["*l,"]}, {"cell_type": "code", "execution_count": 32, "metadata": {"scrolled": true}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["10\n", "20\n", "30\n"]}], "source": ["func1(*l)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["What about mixing positional and keyword arguments with this?"]}, {"cell_type": "code", "execution_count": 33, "metadata": {"collapsed": true}, "outputs": [], "source": ["def func1(a, b, c, *d):\n", "    print(a)\n", "    print(b)\n", "    print(c)\n", "    print(d)"]}, {"cell_type": "code", "execution_count": 34, "metadata": {"scrolled": true}, "outputs": [{"ename": "SyntaxError", "evalue": "positional argument follows keyword argument (<ipython-input-34-f5236a91cb18>, line 1)", "output_type": "error", "traceback": ["\u001b[1;36m  File \u001b[1;32m\"<ipython-input-34-f5236a91cb18>\"\u001b[1;36m, line \u001b[1;32m1\u001b[0m\n\u001b[1;33m    func1(10, c=20, b=10, 'a', 'b')\u001b[0m\n\u001b[1;37m                         ^\u001b[0m\n\u001b[1;31mSyntaxError\u001b[0m\u001b[1;31m:\u001b[0m positional argument follows keyword argument\n"]}], "source": ["func1(10, c=20, b=10, 'a', 'b')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Recall that once a keyword argument is used in a function call, we **cannot** use positional arguments after that. \n", "\n", "However, in the next lecture we'll look at how to address this issue."]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Keyword Arguments"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Recall: positional parameters defined in functions can also be passed as named (keyword) arguments."]}, {"cell_type": "code", "execution_count": 1, "metadata": {"collapsed": true}, "outputs": [], "source": ["def func1(a, b, c):\n", "    print(a, b, c)"]}, {"cell_type": "code", "execution_count": 2, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["10 20 30\n"]}], "source": ["func1(10, 20, 30)"]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["10 20 30\n"]}], "source": ["func1(b=20, c=30, a=10)"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["10 20 30\n"]}], "source": ["func1(10, c=30, b=20)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Using a named argument is optional and up to the caller."]}, {"cell_type": "markdown", "metadata": {}, "source": ["What if we wanted to force calls to our function to use named arguments?"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can do so by **exhausting** all the positional arguments, and then adding some additional parameters in teh function definition:"]}, {"cell_type": "code", "execution_count": 5, "metadata": {"collapsed": true}, "outputs": [], "source": ["def func1(a, b, *args, d):\n", "    print(a, b, args, d)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now we will need at least two positional arguments, an optional (possibly even zero) number of additional arguments, and this extra argument which is supposed to go into **d**. This argument can **only** be passed to the function using a named (keyword) argument:"]}, {"cell_type": "markdown", "metadata": {}, "source": ["So, this will not work:"]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [{"ename": "TypeError", "evalue": "func1() missing 1 required keyword-only argument: 'd'", "output_type": "error", "traceback": ["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[1;31mTypeError\u001b[0m                                 Traceback (most recent call last)", "\u001b[1;32m<ipython-input-6-50a3343cf093>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[1;32m----> 1\u001b[1;33m \u001b[0mfunc1\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;36m10\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;36m20\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;34m'a'\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;34m'b'\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;36m100\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m", "\u001b[1;31mTypeError\u001b[0m: func1() missing 1 required keyword-only argument: 'd'"]}], "source": ["func1(10, 20, 'a', 'b', 100)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But this will:"]}, {"cell_type": "code", "execution_count": null, "metadata": {}, "outputs": [], "source": ["func1(10, 20, 'a', 'b', d=100)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see, **d** took the keyword argument, while the remaining arguments were handled as positional parameters."]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can even define a function that has only optional positional arguments and mandatory keyword arguments:"]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": ["def func1(*args, d):\n", "    print(args)\n", "    print(d)"]}, {"cell_type": "code", "execution_count": null, "metadata": {}, "outputs": [], "source": ["func1(1, 2, 3, d='hello')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can of course, not pass any positional arguments:"]}, {"cell_type": "code", "execution_count": null, "metadata": {}, "outputs": [], "source": ["func1(d='hello')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["but the positional argument is mandatory (since no default was provided in the function definition):"]}, {"cell_type": "code", "execution_count": null, "metadata": {}, "outputs": [], "source": ["func1()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["To make the keyword argument optional, we just need to specify a default value in the function definition:"]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": ["def func1(*args, d='n/a'):\n", "    print(args)\n", "    print(d)"]}, {"cell_type": "code", "execution_count": null, "metadata": {}, "outputs": [], "source": ["func1(1, 2, 3)"]}, {"cell_type": "code", "execution_count": null, "metadata": {}, "outputs": [], "source": ["func1()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Sometimes we want **only** keyword arguments, in which case we still have to exhaust the positional arguments first - but we can use the following syntax if we do not want any positional parameters passed in:"]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": ["def func1(*, d='hello'):\n", "    print(d)"]}, {"cell_type": "code", "execution_count": null, "metadata": {}, "outputs": [], "source": ["func1(10, d='bye')"]}, {"cell_type": "code", "execution_count": null, "metadata": {}, "outputs": [], "source": ["func1(d='bye')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Of course, if we do not provide a default value for the keyword argument, then we effectively are forcing the caller to provide the keyword argument:"]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": ["def func1(*, a, b):\n", "    print(a)\n", "    print(b)"]}, {"cell_type": "code", "execution_count": null, "metadata": {}, "outputs": [], "source": ["func1(a=10, b=20)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["but, the following would not work:"]}, {"cell_type": "code", "execution_count": null, "metadata": {}, "outputs": [], "source": ["func1(10, 20)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Unlike positional parameters, keyword arguments do not have to be defined with non-defaulted and then defaulted arguments:"]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": ["def func1(a, *, b='hello', c):\n", "    print(a, b, c)"]}, {"cell_type": "code", "execution_count": null, "metadata": {}, "outputs": [], "source": ["func1(5, c='bye')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can also include positional non-defaulted (first), positional defaulted (after positional non-defaulted) followed lastly (after exhausting positional arguments) by keyword args (defaulted or non-defaulted in any order)"]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": ["def func1(a, b=20, *args, d=0, e='n/a'):\n", "    print(a, b, args, d, e)"]}, {"cell_type": "code", "execution_count": null, "metadata": {}, "outputs": [], "source": ["func1(5, 4, 3, 2, 1, d=0, e='all engines running')"]}, {"cell_type": "code", "execution_count": null, "metadata": {}, "outputs": [], "source": ["func1(0, 600, d='goooood morning', e='python!')"]}, {"cell_type": "code", "execution_count": null, "metadata": {}, "outputs": [], "source": ["func1(11, 'm/s', 24, 'mph', d='unladen', e='swallow')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see, defining parameters and passing arguments is extremely flexible in Python! Even more so, when you account for the fact that the parameters are not statically typed!"]}, {"cell_type": "markdown", "metadata": {}, "source": ["In the next video, we'll look at one more thing we can do with function parameters!"]}, {"cell_type": "markdown", "metadata": {}, "source": ["### **kwargs"]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [], "source": ["def func(**kwargs):\n", "    print(kwargs)"]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["{'x': 100, 'y': 200}\n"]}], "source": ["func(x=100, y=200)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can also use it in conjunction with **\\*args**: "]}, {"cell_type": "code", "execution_count": 7, "metadata": {"collapsed": true}, "outputs": [], "source": ["def func(*args, **kwargs):\n", "    print(args)\n", "    print(kwargs)"]}, {"cell_type": "code", "execution_count": 8, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["(1, 2)\n", "{'a': 100, 'b': 200}\n"]}], "source": ["func(1, 2, a=100, b=200)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Note: You cannot do the following:"]}, {"cell_type": "code", "execution_count": 9, "metadata": {}, "outputs": [{"ename": "SyntaxError", "evalue": "named arguments must follow bare * (<ipython-input-9-330c63b7f22e>, line 1)", "output_type": "error", "traceback": ["\u001b[1;36m  File \u001b[1;32m\"<ipython-input-9-330c63b7f22e>\"\u001b[1;36m, line \u001b[1;32m1\u001b[0m\n\u001b[1;33m    def func(*, **kwargs):\u001b[0m\n\u001b[1;37m               ^\u001b[0m\n\u001b[1;31mSyntaxError\u001b[0m\u001b[1;31m:\u001b[0m named arguments must follow bare *\n"]}], "source": ["def func(*, **kwargs):\n", "    print(kwargs)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["There is no need to even do this, since **\\*\\*kwargs** essentially indicates no more positional arguments."]}, {"cell_type": "code", "execution_count": 10, "metadata": {"collapsed": true}, "outputs": [], "source": ["def func(a, b, **kwargs):\n", "    print(a)\n", "    print(b)\n", "    print(kwargs)"]}, {"cell_type": "code", "execution_count": 11, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1\n", "2\n", "{'x': 100, 'y': 200}\n"]}], "source": ["func(1, 2, x=100, y=200)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Also, you cannot specify parameters **after** **\\*\\*kwargs** has been used:"]}, {"cell_type": "code", "execution_count": 12, "metadata": {}, "outputs": [{"ename": "SyntaxError", "evalue": "invalid syntax (<ipython-input-12-ffdc3153243b>, line 1)", "output_type": "error", "traceback": ["\u001b[1;36m  File \u001b[1;32m\"<ipython-input-12-ffdc3153243b>\"\u001b[1;36m, line \u001b[1;32m1\u001b[0m\n\u001b[1;33m    def func(a, b, **kwargs, c):\u001b[0m\n\u001b[1;37m                             ^\u001b[0m\n\u001b[1;31mSyntaxError\u001b[0m\u001b[1;31m:\u001b[0m invalid syntax\n"]}], "source": ["def func(a, b, **kwargs, c):\n", "    pass"]}, {"cell_type": "markdown", "metadata": {}, "source": ["If you want to specify both specific keyword-only arguments and **\\*\\*kwargs** you will need to first get to a point where you can define a keyword-only argument (i.e. exhaust the positional arguments, using either **\\*args** or just **\\***)"]}, {"cell_type": "code", "execution_count": 13, "metadata": {"collapsed": true}, "outputs": [], "source": ["def func(*, d, **kwargs):\n", "    print(d)\n", "    print(kwargs)"]}, {"cell_type": "code", "execution_count": 14, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1\n", "{'x': 100, 'y': 200}\n"]}], "source": ["func(d=1, x=100, y=200)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Putting it all Together"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Positionals Only: no extra positionals, no defaults (all positionals required)"]}, {"cell_type": "code", "execution_count": 1, "metadata": {"collapsed": true}, "outputs": [], "source": ["def func(a, b):\n", "    print(a, b)"]}, {"cell_type": "code", "execution_count": 2, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["hello world\n"]}], "source": ["func('hello', 'world')"]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["hello world\n"]}], "source": ["func(b='world', a='hello')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Positionals Only: no extra positionals, defaults (some positionals optional)"]}, {"cell_type": "code", "execution_count": 4, "metadata": {"collapsed": true}, "outputs": [], "source": ["def func(a, b='world', c=10):\n", "    print(a, b, c)"]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["hello world 10\n"]}], "source": ["func('hello')"]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["hello world !\n"]}], "source": ["func('hello', c='!')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Positionals Only: extra positionals, no defaults (all positionals required)"]}, {"cell_type": "code", "execution_count": 7, "metadata": {"collapsed": true}, "outputs": [], "source": ["def func(a, b, *args):\n", "    print(a, b, args)"]}, {"cell_type": "code", "execution_count": 8, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1 2 ('x', 'y', 'z')\n"]}], "source": ["func(1, 2, 'x', 'y', 'z')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Note that we cannot call the function this way:"]}, {"cell_type": "code", "execution_count": 9, "metadata": {}, "outputs": [{"ename": "SyntaxError", "evalue": "positional argument follows keyword argument (<ipython-input-9-f1b0ffb3b67d>, line 1)", "output_type": "error", "traceback": ["\u001b[1;36m  File \u001b[1;32m\"<ipython-input-9-f1b0ffb3b67d>\"\u001b[1;36m, line \u001b[1;32m1\u001b[0m\n\u001b[1;33m    func(b=2, a=1, 'x', 'y', 'z')\u001b[0m\n\u001b[1;37m                  ^\u001b[0m\n\u001b[1;31mSyntaxError\u001b[0m\u001b[1;31m:\u001b[0m positional argument follows keyword argument\n"]}], "source": ["func(b=2, a=1, 'x', 'y', 'z')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Keywords Only: no positionals, no defaults (all keyword args required)"]}, {"cell_type": "code", "execution_count": 10, "metadata": {"collapsed": true}, "outputs": [], "source": ["def func(*, a, b):\n", "    print(a, b)"]}, {"cell_type": "code", "execution_count": 11, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1 2\n"]}], "source": ["func(a=1, b=2)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Keywords Only: no positionals, some defaults (not all keyword args required)"]}, {"cell_type": "code", "execution_count": 12, "metadata": {"collapsed": true}, "outputs": [], "source": ["def func(*, a=1, b):\n", "    print(a, b)"]}, {"cell_type": "code", "execution_count": 13, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["10 20\n"]}], "source": ["func(a=10, b=20)"]}, {"cell_type": "code", "execution_count": 14, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1 2\n"]}], "source": ["func(b=2)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Keywords and Positionals: some positionals (no defaults), keywords (no defaults)"]}, {"cell_type": "code", "execution_count": 15, "metadata": {}, "outputs": [], "source": ["def func(a, b, *, c, d):\n", "    print(a, b, c, d)"]}, {"cell_type": "code", "execution_count": 16, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1 2 3 4\n"]}], "source": ["func(1, 2, c=3, d=4)"]}, {"cell_type": "code", "execution_count": 17, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1 2 3 4\n"]}], "source": ["func(1, 2, d=4, c=3)"]}, {"cell_type": "code", "execution_count": 18, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1 2 3 4\n"]}], "source": ["func(1, c=3, d=4, b=2)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Keywords and Positionals: some positional defaults"]}, {"cell_type": "code", "execution_count": 19, "metadata": {"collapsed": true}, "outputs": [], "source": ["def func(a, b=2, *, c, d=4):\n", "    print(a, b, c, d)"]}, {"cell_type": "code", "execution_count": 20, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1 2 3 4\n"]}], "source": ["func(1, c=3)"]}, {"cell_type": "code", "execution_count": 21, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1 2 3 4\n"]}], "source": ["func(c=3, a=1)"]}, {"cell_type": "code", "execution_count": 22, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1 2 3 4\n"]}], "source": ["func(1, 2, c=3, d=4)"]}, {"cell_type": "code", "execution_count": 23, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1 2 3 4\n"]}], "source": ["func(c=3, a=1, b=2, d=4)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Keywords and Positionals: extra positionals"]}, {"cell_type": "code", "execution_count": 24, "metadata": {}, "outputs": [], "source": ["def func(a, b=2, *args, c=3, d):\n", "    print(a, b, args, c, d)"]}, {"cell_type": "code", "execution_count": 25, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1 2 ('x', 'y', 'z') 3 4\n"]}], "source": ["func(1, 2, 'x', 'y', 'z', c=3, d=4)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Note that if we are going to use the extra arguments, then we cannot actually use a default value for b:"]}, {"cell_type": "code", "execution_count": 26, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1 x ('y', 'z') 3 4\n"]}], "source": ["func(1, 'x', 'y', 'z', c=3, d=4)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["as you can see, **b** was assigned the value **x**"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Keywords and Positionals: no extra positionals, extra keywords"]}, {"cell_type": "code", "execution_count": 27, "metadata": {"collapsed": true}, "outputs": [], "source": ["def func(a, b, *, c, d=4, **kwargs):\n", "    print(a, b, c, d, kwargs)"]}, {"cell_type": "code", "execution_count": 28, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1 2 3 4 {'x': 100, 'y': 200, 'z': 300}\n"]}], "source": ["func(1, 2, c=3, x=100, y=200, z=300)"]}, {"cell_type": "code", "execution_count": 29, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1 2 3 4 {'x': 100, 'y': 200, 'z': 300}\n"]}], "source": ["func(x=100, y=200, z=300, c=3, b=2, a=1)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Keywords and Positionals: extra positionals, extra keywords"]}, {"cell_type": "code", "execution_count": 30, "metadata": {}, "outputs": [], "source": ["def func(a, b, *args, c, d=4, **kwargs):\n", "    print(a, b, args, c, d, kwargs)"]}, {"cell_type": "code", "execution_count": 31, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1 2 ('x', 'y', 'z') 3 5 {'x': 100, 'y': 200, 'z': 300}\n"]}], "source": ["func(1, 2, 'x', 'y', 'z', c=3, d=5, x=100, y=200, z=300)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Keywords and Positionals: only extra positionals and extra keywords"]}, {"cell_type": "code", "execution_count": 32, "metadata": {"collapsed": true}, "outputs": [], "source": ["def func(*args, **kwargs):\n", "    print(args, kwargs)"]}, {"cell_type": "code", "execution_count": 33, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["(1, 2, 3) {'x': 100, 'y': 200, 'z': 300}\n"]}], "source": ["func(1, 2, 3, x=100, y=200, z=300)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### The Print Function"]}, {"cell_type": "code", "execution_count": 34, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Help on built-in function print in module builtins:\n", "\n", "print(...)\n", "    print(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False)\n", "    \n", "    Prints the values to a stream, or to sys.stdout by default.\n", "    Optional keyword arguments:\n", "    file:  a file-like object (stream); defaults to the current sys.stdout.\n", "    sep:   string inserted between values, default a space.\n", "    end:   string appended after the last value, default a newline.\n", "    flush: whether to forcibly flush the stream.\n", "\n"]}], "source": ["help(print)"]}, {"cell_type": "code", "execution_count": 35, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1 2 3\n"]}], "source": ["print(1, 2, 3)"]}, {"cell_type": "code", "execution_count": 36, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1--2--3\n"]}], "source": ["print(1, 2, 3, sep='--')"]}, {"cell_type": "code", "execution_count": 37, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1 2 3***\n"]}], "source": ["print(1, 2, 3, end='***\\n')"]}, {"cell_type": "code", "execution_count": 38, "metadata": {"scrolled": true}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1\t2\t3\t***\t4\t5\t6\t***\n"]}], "source": ["print(1, 2, 3, sep='\\t', end='\\t***\\t')\n", "print(4, 5, 6, sep='\\t', end='\\t***\\n')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Another Use Case"]}, {"cell_type": "code", "execution_count": 39, "metadata": {"collapsed": true}, "outputs": [], "source": ["def calc_hi_lo_avg(*args, log_to_console=False):\n", "    hi = int(bool(args)) and max(args)\n", "    lo = int(bool(args)) and min(args)\n", "    avg = (hi + lo)/2\n", "    if log_to_console:\n", "        print(\"high={0}, low={1}, avg={2}\".format(hi, lo, avg))\n", "    return avg"]}, {"cell_type": "code", "execution_count": 40, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["3.0\n"]}], "source": ["avg = calc_hi_lo_avg(1, 2, 3, 4, 5)\n", "print(avg)"]}, {"cell_type": "code", "execution_count": 41, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["high=5, low=1, avg=3.0\n", "3.0\n"]}], "source": ["avg = calc_hi_lo_avg(1, 2, 3, 4, 5, log_to_console=True)\n", "print(avg)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["### A Simple Function Timer"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We want to create a simple function that can time how fast a function runs.\n", "\n", "We want this function to be generic in the sense that it can be used to time any function (along with it's positional and keyword arguments), as well as specifying the number of the times the function should be timed, and the returns the average of the timings."]}, {"cell_type": "markdown", "metadata": {}, "source": ["We'll call our function **time_it**, and it will need to have the following parameters:\n", "\n", "* the function we want to time\n", "* the positional arguments of the function we want to time (if any)\n", "* the keyword-only arguments of the function we want to time (if any)\n", "* the number of times we want to run this function"]}, {"cell_type": "code", "execution_count": 1, "metadata": {"collapsed": true}, "outputs": [], "source": ["import time"]}, {"cell_type": "code", "execution_count": 4, "metadata": {"collapsed": true}, "outputs": [], "source": ["def time_it(fn, *args, rep=5, **kwargs):\n", "    print(args, rep, kwargs)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now we could the function this way:"]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["(1, 2, 3) 5 {'sep': '-'}\n"]}], "source": ["time_it(print, 1, 2, 3, sep='-')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's modify our function to actually run the print function with any positional and keyword args (except for rep) passed to it:"]}, {"cell_type": "code", "execution_count": 11, "metadata": {"collapsed": true}, "outputs": [], "source": ["def time_it(fn, *args, rep=5, **kwargs):\n", "    for i in range(rep):\n", "        fn(*args, **kwargs)"]}, {"cell_type": "code", "execution_count": 12, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1-2-3\n", "1-2-3\n", "1-2-3\n", "1-2-3\n", "1-2-3\n"]}], "source": ["time_it(print, 1, 2, 3, sep='-')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see **1, 2, 3** was passed to the **print** function's positional parameters, and the keyword_only arg **sep** was also passed to it. \n", "\n", "We can even add more arguments:"]}, {"cell_type": "code", "execution_count": 13, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1-2-3 *** 1-2-3 *** 1-2-3 *** "]}], "source": ["time_it(print, 1, 2, 3, sep='-', end=' *** ', rep=3)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now all that's really left for us to do is to time the function and return the average time:"]}, {"cell_type": "code", "execution_count": 16, "metadata": {"collapsed": true}, "outputs": [], "source": ["def time_it(fn, *args, rep=5, **kwargs):\n", "    start = time.perf_counter()\n", "    for i in range(rep):\n", "        fn(*args, **kwargs)\n", "    end = time.perf_counter()\n", "    return (end - start) / rep"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's write a few functions we might want to time:"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We'll create three functions that all do the same thing: calculate powers of n**k for k in some range of integer values"]}, {"cell_type": "code", "execution_count": 17, "metadata": {"collapsed": true}, "outputs": [], "source": ["def compute_powers_1(n, *, start=1, end):\n", "    # using a for loop\n", "    results = []\n", "    for i in range(start, end):\n", "        results.append(n**i)\n", "    return results"]}, {"cell_type": "code", "execution_count": 22, "metadata": {"collapsed": true}, "outputs": [], "source": ["def compute_powers_2(n, *, start=1, end):\n", "    # using a list comprehension\n", "    return [n**i for i in range(start, end)]"]}, {"cell_type": "code", "execution_count": 23, "metadata": {"collapsed": true}, "outputs": [], "source": ["def compute_powers_3(n, *, start=1, end):\n", "    # using a generator expression\n", "    return (n**i for i in range(start, end))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's run these functions and see the results:"]}, {"cell_type": "code", "execution_count": 24, "metadata": {}, "outputs": [{"data": {"text/plain": ["[2, 4, 8, 16]"]}, "execution_count": 24, "metadata": {}, "output_type": "execute_result"}], "source": ["compute_powers_1(2, end=5)"]}, {"cell_type": "code", "execution_count": 25, "metadata": {}, "outputs": [{"data": {"text/plain": ["[2, 4, 8, 16]"]}, "execution_count": 25, "metadata": {}, "output_type": "execute_result"}], "source": ["compute_powers_2(2, end=5)"]}, {"cell_type": "code", "execution_count": 26, "metadata": {}, "outputs": [{"data": {"text/plain": ["[2, 4, 8, 16]"]}, "execution_count": 26, "metadata": {}, "output_type": "execute_result"}], "source": ["list(compute_powers_3(2, end=5))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Finally let's run these functions through our **time_it** function and see the results:"]}, {"cell_type": "code", "execution_count": 36, "metadata": {}, "outputs": [{"data": {"text/plain": ["2.5798198230283234"]}, "execution_count": 36, "metadata": {}, "output_type": "execute_result"}], "source": ["time_it(compute_powers_1, n=2, end=20000, rep=4)"]}, {"cell_type": "code", "execution_count": 37, "metadata": {}, "outputs": [{"data": {"text/plain": ["2.3151767636341347"]}, "execution_count": 37, "metadata": {}, "output_type": "execute_result"}], "source": ["time_it(compute_powers_2, 2, end=20000, rep=4)"]}, {"cell_type": "code", "execution_count": 39, "metadata": {}, "outputs": [{"data": {"text/plain": ["3.0854032573301993e-06"]}, "execution_count": 39, "metadata": {}, "output_type": "execute_result"}], "source": ["time_it(compute_powers_3, 2, end=20000, rep=4)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Although the **compute_powers_3** function appears to be **much** faster than the other two, it doesn't quite do the same thing! \n", "\n", "We'll cover generators in detail later in this course."]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": []}, {"cell_type": "markdown", "metadata": {}, "source": ["### Default Values - Beware!"]}, {"cell_type": "code", "execution_count": 10, "metadata": {"collapsed": true}, "outputs": [], "source": ["from datetime import datetime"]}, {"cell_type": "code", "execution_count": 11, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["2017-08-22 04:04:17.700303\n"]}], "source": ["print(datetime.utcnow())"]}, {"cell_type": "code", "execution_count": 12, "metadata": {"collapsed": true}, "outputs": [], "source": ["def log(msg, *, dt=datetime.utcnow()):\n", "    print('{0}: {1}'.format(dt, msg))"]}, {"cell_type": "code", "execution_count": 13, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["2017-08-22 04:04:18.406943: message 1\n"]}], "source": ["log('message 1')"]}, {"cell_type": "code", "execution_count": 16, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["2001-01-01 00:00:00: message 2\n"]}], "source": ["log('message 2', dt='2001-01-01 00:00:00')"]}, {"cell_type": "code", "execution_count": 17, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["2017-08-22 04:04:18.406943: message 3\n"]}], "source": ["log('message 3')"]}, {"cell_type": "code", "execution_count": 18, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["2017-08-22 04:04:18.406943: message 4\n"]}], "source": ["log('message 4')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see, the default for **dt** is calculated when the function is **defined** and is **NOT** re-evaluated when the function is called."]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Solution Pattern"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Here is one pattern we can use to achieve the desired result:\n", "\n", "We actually set the default to None - this makes the argument optional, and we can then test for None **inside** the function and default to the current time if it is None."]}, {"cell_type": "code", "execution_count": 34, "metadata": {}, "outputs": [], "source": ["def log(msg, *, dt=None):\n", "    dt = dt or datetime.utcnow()\n", "    # above is equivalent to:\n", "    #if not dt:\n", "    #    dt = datetime.utcnow()\n", "    print('{0}: {1}'.format(dt, msg))    "]}, {"cell_type": "code", "execution_count": 35, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["2017-08-22 04:15:11.797640: message 1\n"]}], "source": ["log('message 1')"]}, {"cell_type": "code", "execution_count": 36, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["2017-08-22 04:15:14.529496: message 2\n"]}], "source": ["log('message 2')"]}, {"cell_type": "code", "execution_count": 37, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["2001-01-01 00:00:00: message 3\n"]}], "source": ["log('message 3', dt='2001-01-01 00:00:00')"]}, {"cell_type": "code", "execution_count": 38, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["2017-08-22 04:15:18.045607: message 4\n"]}], "source": ["log('message 4')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Parameter Defaults - Beware 2"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Another gotcha with parameter defaults comes with mutable types, and is an easy trap to fall into."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Again, you have to remember that function parameter defaults are evaluated once, when the function is defined (i.e. when the module is loaded, or in this Jupyter notebook, when we \"execute\" the function definition), and not every time the function is called."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Consider the following scenario.\n", "\n", "We are creating a grocery list, and we want our list to contain consistently formatted data with name, quantity and measurement unit:\n", "\n", "``\n", "bananas (2 units)\n", "grapes (1 bunch)\n", "milk (1 liter)\n", "python (1 medium-rare)\n", "``"]}, {"cell_type": "markdown", "metadata": {}, "source": ["To make sure the data is consistent, we want to use a function that we can call to add the item to our list.\n", "\n", "So we'll need to provide it our current grocery list as well as the item information to be added:"]}, {"cell_type": "code", "execution_count": 1, "metadata": {"collapsed": true}, "outputs": [], "source": ["def add_item(name, quantity, unit, grocery_list):\n", "    item_fmt = \"{0} ({1} {2})\".format(name, quantity, unit)\n", "    grocery_list.append(item_fmt)\n", "    return grocery_list"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We have two stores we want to visit, so we set up two grocery lists:"]}, {"cell_type": "code", "execution_count": 2, "metadata": {"collapsed": true}, "outputs": [], "source": ["store_1 = []\n", "store_2 = []"]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [{"data": {"text/plain": ["['python (1 medium-rare)']"]}, "execution_count": 3, "metadata": {}, "output_type": "execute_result"}], "source": ["add_item('bananas', 2, 'units', store_1)\n", "add_item('grapes', 1, 'bunch', store_1)\n", "add_item('python', 1, 'medium-rare', store_2)"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"data": {"text/plain": ["['bananas (2 units)', 'grapes (1 bunch)']"]}, "execution_count": 4, "metadata": {}, "output_type": "execute_result"}], "source": ["store_1"]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"data": {"text/plain": ["['python (1 medium-rare)']"]}, "execution_count": 5, "metadata": {}, "output_type": "execute_result"}], "source": ["store_2"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Ok, working great. But let's make the function a little easier to use - if the user does not supply an existing grocery list to append the item to, let's just go ahead and default our `grocery_list` to an empty list hence starting a new shopping list:"]}, {"cell_type": "code", "execution_count": 6, "metadata": {"collapsed": true}, "outputs": [], "source": ["def add_item(name, quantity, unit, grocery_list=[]):\n", "    item_fmt = \"{0} ({1} {2})\".format(name, quantity, unit)\n", "    grocery_list.append(item_fmt)\n", "    return grocery_list"]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"data": {"text/plain": ["['bananas (2 units)', 'grapes (1 bunch)']"]}, "execution_count": 7, "metadata": {}, "output_type": "execute_result"}], "source": ["store_1 = add_item('bananas', 2, 'units')\n", "add_item('grapes', 1, 'bunch', store_1)"]}, {"cell_type": "code", "execution_count": 8, "metadata": {}, "outputs": [{"data": {"text/plain": ["['bananas (2 units)', 'grapes (1 bunch)']"]}, "execution_count": 8, "metadata": {}, "output_type": "execute_result"}], "source": ["store_1"]}, {"cell_type": "markdown", "metadata": {}, "source": ["OK, so that seems to be working as expected.\n", "\n", "Let's start our second list:"]}, {"cell_type": "code", "execution_count": 9, "metadata": {"collapsed": true}, "outputs": [], "source": ["store_2 = add_item('milk', 1, 'gallon')"]}, {"cell_type": "code", "execution_count": 10, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["['bananas (2 units)', 'grapes (1 bunch)', 'milk (1 gallon)']\n"]}], "source": ["print(store_2)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["??? What's going on? Our second list somehow contains the items that are in the first list."]}, {"cell_type": "markdown", "metadata": {}, "source": ["What happened is that the returned value in the first call we made was the default grocery list - but remember that the list was created once and for all when the function was **created** not called. So everytime we call the function, that is the **same** list being used as the default. \n", "\n", "When we started out first list, we were adding item to that default list.\n", "\n", "When we started our second list, we were adding items to the **same** default list (since it is the same object)."]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can avoid this problem using the same pattern as in the previous example we had with the default date time value. We use None as a default value instead, and generate a new empty list (hence starting a new list) if none was provided."]}, {"cell_type": "code", "execution_count": 11, "metadata": {"collapsed": true}, "outputs": [], "source": ["def add_item(name, quantity, unit, grocery_list=None):\n", "    if not grocery_list:\n", "        grocery_list = []\n", "    item_fmt = \"{0} ({1} {2})\".format(name, quantity, unit)\n", "    grocery_list.append(item_fmt)\n", "    return grocery_list"]}, {"cell_type": "code", "execution_count": 12, "metadata": {}, "outputs": [{"data": {"text/plain": ["['bananas (2 units)', 'grapes (1 bunch)']"]}, "execution_count": 12, "metadata": {}, "output_type": "execute_result"}], "source": ["store_1 = add_item('bananas', 2, 'units')\n", "add_item('grapes', 1, 'bunch', store_1)"]}, {"cell_type": "code", "execution_count": 13, "metadata": {}, "outputs": [{"data": {"text/plain": ["['milk (1 gallon)']"]}, "execution_count": 13, "metadata": {}, "output_type": "execute_result"}], "source": ["store_2 = add_item('milk', 1, 'gallon')\n", "store_2"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Issue resolved!"]}, {"cell_type": "markdown", "metadata": {}, "source": ["However, there are legitimate use cases (well, almost legitimate, often we're better off using a different approach that we'll see when we look at closures), but here's a simple one.\n", "\n", "We want our function to cache results, so that we don't recalculate something more than once.\n", "\n", "Let's say we have a factorial function, that can be defined recursively as:\n", "\n", "`n! = n * (n-1)!`"]}, {"cell_type": "code", "execution_count": 14, "metadata": {"collapsed": true}, "outputs": [], "source": ["def factorial(n):\n", "    if n < 1:\n", "        return 1\n", "    else:\n", "        print('calculating {0}!'.format(n))\n", "        return n * factorial(n-1)"]}, {"cell_type": "code", "execution_count": 15, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["calculating 3!\n", "calculating 2!\n", "calculating 1!\n"]}, {"data": {"text/plain": ["6"]}, "execution_count": 15, "metadata": {}, "output_type": "execute_result"}], "source": ["factorial(3)"]}, {"cell_type": "code", "execution_count": 16, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["calculating 3!\n", "calculating 2!\n", "calculating 1!\n"]}, {"data": {"text/plain": ["6"]}, "execution_count": 16, "metadata": {}, "output_type": "execute_result"}], "source": ["factorial(3)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see we had to recalculate all those factorials the second time around.\n", "\n", "Let's cache the results leveraging what we saw in the previous example:"]}, {"cell_type": "code", "execution_count": 17, "metadata": {"collapsed": true}, "outputs": [], "source": ["def factorial(n, cache={}):\n", "    if n < 1:\n", "        return 1\n", "    elif n in cache:\n", "        return cache[n]\n", "    else:\n", "        print('calculating {0}!'.format(n))\n", "        result = n * factorial(n-1)\n", "        cache[n] = result\n", "        return result"]}, {"cell_type": "code", "execution_count": 18, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["calculating 3!\n", "calculating 2!\n", "calculating 1!\n"]}, {"data": {"text/plain": ["6"]}, "execution_count": 18, "metadata": {}, "output_type": "execute_result"}], "source": ["factorial(3)"]}, {"cell_type": "code", "execution_count": 19, "metadata": {}, "outputs": [{"data": {"text/plain": ["6"]}, "execution_count": 19, "metadata": {}, "output_type": "execute_result"}], "source": ["factorial(3)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now as you can see, the second time around we did not have to recalculate all the factorials. In fact, to calculate higher factorials, you'll notice that we don't need to re-run *all* the recursive calls:"]}, {"cell_type": "code", "execution_count": 20, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["calculating 5!\n", "calculating 4!\n"]}, {"data": {"text/plain": ["120"]}, "execution_count": 20, "metadata": {}, "output_type": "execute_result"}], "source": ["factorial(5)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["`5!` and `4!` was calculated since they weren't cached, but since `3!` was already cached we didn't have to recalculate it - it was a quick lookup instead."]}, {"cell_type": "markdown", "metadata": {}, "source": ["This technique is something called memoization, and we'll come back to it in much more detail when we discuss closures and decorators."]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Docstrings and Annotations"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Docstrings"]}, {"cell_type": "markdown", "metadata": {"collapsed": true}, "source": ["When we call **help()** on a class, function, module, etc, Python will typically display some information:"]}, {"cell_type": "code", "execution_count": 1, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Help on built-in function print in module builtins:\n", "\n", "print(...)\n", "    print(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False)\n", "    \n", "    Prints the values to a stream, or to sys.stdout by default.\n", "    Optional keyword arguments:\n", "    file:  a file-like object (stream); defaults to the current sys.stdout.\n", "    sep:   string inserted between values, default a space.\n", "    end:   string appended after the last value, default a newline.\n", "    flush: whether to forcibly flush the stream.\n", "\n"]}], "source": ["help(print)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can define such help using docstrings and annotations."]}, {"cell_type": "code", "execution_count": 2, "metadata": {"collapsed": true}, "outputs": [], "source": ["def my_func(a, b):\n", "    return a*b"]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Help on function my_func in module __main__:\n", "\n", "my_func(a, b)\n", "\n"]}], "source": ["help(my_func)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Pretty bare! So let's add some additional help:"]}, {"cell_type": "code", "execution_count": 4, "metadata": {"collapsed": true}, "outputs": [], "source": ["def my_func(a, b):\n", "    'Returns the product of a and b'\n", "    return a*b"]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Help on function my_func in module __main__:\n", "\n", "my_func(a, b)\n", "    Returns the product of a and b\n", "\n"]}], "source": ["help(my_func)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Docstrings can span multiple lines using a multi-line string literal:"]}, {"cell_type": "code", "execution_count": 6, "metadata": {"collapsed": true}, "outputs": [], "source": ["def fact(n):\n", "    '''Calculates n! (factorial function)\n", "    \n", "    Inputs:\n", "        n: non-negative integer\n", "    Returns:\n", "        the factorial of n\n", "    '''\n", "    \n", "    if n < 0:\n", "        '''Note that this is not part of the docstring!'''\n", "        return 1\n", "    else:\n", "        return n * fact(n-1)\n", "    \n", "    "]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Help on function fact in module __main__:\n", "\n", "fact(n)\n", "    Calculates n! (factorial function)\n", "    \n", "    Inputs:\n", "        n: non-negative integer\n", "    Returns:\n", "        the factorial of n\n", "\n"]}], "source": ["help(fact)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Docstrings, when found, are simply attached to the function in the `__doc__` property:"]}, {"cell_type": "code", "execution_count": 8, "metadata": {}, "outputs": [{"data": {"text/plain": ["'Calculates n! (factorial function)\\n    \\n    Inputs:\\n        n: non-negative integer\\n    Returns:\\n        the factorial of n\\n    '"]}, "execution_count": 8, "metadata": {}, "output_type": "execute_result"}], "source": ["fact.__doc__"]}, {"cell_type": "markdown", "metadata": {}, "source": ["And the Python **help()** function simply returns the contents of `__doc__`"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Annotations"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can also add metadata annotations to a function's parameters and return. These metadata annotations can be any **expression** (string, type, function call, etc)"]}, {"cell_type": "code", "execution_count": 9, "metadata": {"collapsed": true}, "outputs": [], "source": ["def my_func(a:'annotation for a', \n", "            b:'annotation for b')->'annotation for return':\n", "    \n", "    return a*b"]}, {"cell_type": "code", "execution_count": 10, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Help on function my_func in module __main__:\n", "\n", "my_func(a:'annotation for a', b:'annotation for b') -> 'annotation for return'\n", "\n"]}], "source": ["help(my_func)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The annotations can be any expression, not just strings:"]}, {"cell_type": "code", "execution_count": 11, "metadata": {"collapsed": true}, "outputs": [], "source": ["x = 3\n", "y = 5\n", "def my_func(a: str) -> 'a repeated ' + str(max(3, 5)) + ' times':\n", "\treturn a*max(x, y)"]}, {"cell_type": "code", "execution_count": 12, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Help on function my_func in module __main__:\n", "\n", "my_func(a:str) -> 'a repeated 5 times'\n", "\n"]}], "source": ["help(my_func)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Note that these annotations do **not** force a type on the parameters or the return value - they are simply there for documentation purposes within Python and **may** be used by external applications and modules, such as IDE's."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Just like docstrings are stored in the `__doc__` property, annotations are stored in the `__annotations__` property - a dictionary whose keys are the parameter names, and values are the annotation."]}, {"cell_type": "code", "execution_count": 13, "metadata": {}, "outputs": [{"data": {"text/plain": ["{'a': str, 'return': 'a repeated 5 times'}"]}, "execution_count": 13, "metadata": {}, "output_type": "execute_result"}], "source": ["my_func.__annotations__"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Of course we can combine both docstrings and annotations:"]}, {"cell_type": "code", "execution_count": 14, "metadata": {"collapsed": true}, "outputs": [], "source": ["def fact(n: 'int >= 0')->int:\n", "    '''Calculates n! (factorial function)\n", "    \n", "    Inputs:\n", "        n: non-negative integer\n", "    Returns:\n", "        the factorial of n\n", "    '''\n", "    \n", "    if n < 0:\n", "        '''Note that this is not part of the docstring!'''\n", "        return 1\n", "    else:\n", "        return n * fact(n-1)"]}, {"cell_type": "code", "execution_count": 15, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Help on function fact in module __main__:\n", "\n", "fact(n:'int >= 0') -> int\n", "    Calculates n! (factorial function)\n", "    \n", "    Inputs:\n", "        n: non-negative integer\n", "    Returns:\n", "        the factorial of n\n", "\n"]}], "source": ["help(fact)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Annotations will work with default parameters too: just specify the default **after** the annotation:"]}, {"cell_type": "code", "execution_count": 16, "metadata": {"collapsed": true}, "outputs": [], "source": ["def my_func(a:str='a', b:int=1)->str:\n", "    return a*b"]}, {"cell_type": "code", "execution_count": 17, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Help on function my_func in module __main__:\n", "\n", "my_func(a:str='a', b:int=1) -> str\n", "\n"]}], "source": ["help(my_func)"]}, {"cell_type": "code", "execution_count": 18, "metadata": {}, "outputs": [{"data": {"text/plain": ["'a'"]}, "execution_count": 18, "metadata": {}, "output_type": "execute_result"}], "source": ["my_func()"]}, {"cell_type": "code", "execution_count": 19, "metadata": {}, "outputs": [{"data": {"text/plain": ["'abcabcabc'"]}, "execution_count": 19, "metadata": {}, "output_type": "execute_result"}], "source": ["my_func('abc', 3)"]}, {"cell_type": "code", "execution_count": 20, "metadata": {"collapsed": true}, "outputs": [], "source": ["def my_func(a:int=0, *args:'additional args'):\n", "    print(a, args)"]}, {"cell_type": "code", "execution_count": 21, "metadata": {}, "outputs": [{"data": {"text/plain": ["{'a': int, 'args': 'additional args'}"]}, "execution_count": 21, "metadata": {}, "output_type": "execute_result"}], "source": ["my_func.__annotations__"]}, {"cell_type": "code", "execution_count": 22, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Help on function my_func in module __main__:\n", "\n", "my_func(a:int=0, *args:'additional args')\n", "\n"]}], "source": ["help(my_func)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Lambda Expressions"]}, {"cell_type": "code", "execution_count": 1, "metadata": {}, "outputs": [{"data": {"text/plain": ["<function __main__.<lambda>>"]}, "execution_count": 1, "metadata": {}, "output_type": "execute_result"}], "source": ["lambda x: x**2"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see, the above expression just created a function."]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Assigning to a Variable"]}, {"cell_type": "code", "execution_count": 2, "metadata": {"collapsed": true}, "outputs": [], "source": ["func = lambda x: x**2"]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [{"data": {"text/plain": ["function"]}, "execution_count": 3, "metadata": {}, "output_type": "execute_result"}], "source": ["type(func)"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"data": {"text/plain": ["9"]}, "execution_count": 4, "metadata": {}, "output_type": "execute_result"}], "source": ["func(3)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can specify arguments for lambdas just like we would for any function created using **def**, except for annotations:"]}, {"cell_type": "code", "execution_count": 5, "metadata": {"collapsed": true}, "outputs": [], "source": ["func_1 = lambda x, y=10: (x, y)"]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [{"data": {"text/plain": ["(1, 2)"]}, "execution_count": 6, "metadata": {}, "output_type": "execute_result"}], "source": ["func_1(1, 2)"]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"data": {"text/plain": ["(1, 10)"]}, "execution_count": 7, "metadata": {}, "output_type": "execute_result"}], "source": ["func_1(1)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can even use \\* and \\*\\*:"]}, {"cell_type": "code", "execution_count": 8, "metadata": {"collapsed": true}, "outputs": [], "source": ["func_2 = lambda x, *args, y, **kwargs: (x, *args, y, {**kwargs})"]}, {"cell_type": "code", "execution_count": 9, "metadata": {}, "outputs": [{"data": {"text/plain": ["(1, 'a', 'b', 100, {'a': 10, 'b': 20})"]}, "execution_count": 9, "metadata": {}, "output_type": "execute_result"}], "source": ["func_2(1, 'a', 'b', y=100, a=10, b=20)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Passing as an Argument"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Lambdas are functions, and can therefore be passed to any other function as an argument (or returned from another function)"]}, {"cell_type": "code", "execution_count": 10, "metadata": {"collapsed": true}, "outputs": [], "source": ["def apply_func(x, fn):\n", "    return fn(x)"]}, {"cell_type": "code", "execution_count": 11, "metadata": {}, "outputs": [{"data": {"text/plain": ["9"]}, "execution_count": 11, "metadata": {}, "output_type": "execute_result"}], "source": ["apply_func(3, lambda x: x**2)"]}, {"cell_type": "code", "execution_count": 12, "metadata": {}, "outputs": [{"data": {"text/plain": ["27"]}, "execution_count": 12, "metadata": {}, "output_type": "execute_result"}], "source": ["apply_func(3, lambda x: x**3)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Of course we can make this even more generic:"]}, {"cell_type": "code", "execution_count": 13, "metadata": {"collapsed": true}, "outputs": [], "source": ["def apply_func(fn, *args, **kwargs):\n", "    return fn(*args, **kwargs)"]}, {"cell_type": "code", "execution_count": 14, "metadata": {}, "outputs": [{"data": {"text/plain": ["3"]}, "execution_count": 14, "metadata": {}, "output_type": "execute_result"}], "source": ["apply_func(lambda x, y: x+y, 1, 2)"]}, {"cell_type": "code", "execution_count": 15, "metadata": {}, "outputs": [{"data": {"text/plain": ["3"]}, "execution_count": 15, "metadata": {}, "output_type": "execute_result"}], "source": ["apply_func(lambda x, *, y: x+y, 1, y=2)"]}, {"cell_type": "code", "execution_count": 16, "metadata": {}, "outputs": [{"data": {"text/plain": ["15"]}, "execution_count": 16, "metadata": {}, "output_type": "execute_result"}], "source": ["apply_func(lambda *args: sum(args), 1, 2, 3, 4, 5)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Of course in the example above, we really did not need to create a lambda!"]}, {"cell_type": "code", "execution_count": 17, "metadata": {}, "outputs": [{"data": {"text/plain": ["15"]}, "execution_count": 17, "metadata": {}, "output_type": "execute_result"}], "source": ["apply_func(sum, (1, 2, 3, 4, 5))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Of course, we don't have to use lambdas when calling **apply_func**, we can also pass in a function defined using a **def** statement:"]}, {"cell_type": "code", "execution_count": 18, "metadata": {"collapsed": true}, "outputs": [], "source": ["def multiply(x, y):\n", "    return x * y"]}, {"cell_type": "code", "execution_count": 19, "metadata": {}, "outputs": [{"data": {"text/plain": ["'aaaaa'"]}, "execution_count": 19, "metadata": {}, "output_type": "execute_result"}], "source": ["apply_func(multiply, 'a', 5)"]}, {"cell_type": "code", "execution_count": 20, "metadata": {}, "outputs": [{"data": {"text/plain": ["'aaaaa'"]}, "execution_count": 20, "metadata": {}, "output_type": "execute_result"}], "source": ["apply_func(lambda x, y: x*y, 'a', 5)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Lambdas and Sorting"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Python has a built-in **sorted** method that can be used to sort any iterable. It will use the default ordering of the particular items, but sometimes you may want to (or need to) specify a different criteria for sorting."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's start with a simple list:"]}, {"cell_type": "code", "execution_count": 1, "metadata": {"collapsed": true}, "outputs": [], "source": ["l = ['a', 'B', 'c', 'D']"]}, {"cell_type": "code", "execution_count": 2, "metadata": {}, "outputs": [{"data": {"text/plain": ["['B', 'D', 'a', 'c']"]}, "execution_count": 2, "metadata": {}, "output_type": "execute_result"}], "source": ["sorted(l)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see there is a difference between upper and lower-case characters when sorting strings.\n", "\n", "What if we wanted to make a case-insensitive sort?\n", "\n", "Python's **sorted** function kas a keyword-only argument that allows us to modify the values that are used to sort the list."]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [{"data": {"text/plain": ["['a', 'B', 'c', 'D']"]}, "execution_count": 3, "metadata": {}, "output_type": "execute_result"}], "source": ["sorted(l, key=str.upper)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We could have used a lambda here (but you should not, this is just to illustrate using a lambda in this case):"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"data": {"text/plain": ["['a', 'B', 'c', 'D']"]}, "execution_count": 4, "metadata": {}, "output_type": "execute_result"}], "source": ["sorted(l, key = lambda s: s.upper())"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's look at how we might create a sorted list from a dictionary:"]}, {"cell_type": "code", "execution_count": 5, "metadata": {"collapsed": true}, "outputs": [], "source": ["d = {'def': 300, 'abc': 200, 'ghi': 100}"]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [{"data": {"text/plain": ["{'abc': 200, 'def': 300, 'ghi': 100}"]}, "execution_count": 6, "metadata": {}, "output_type": "execute_result"}], "source": ["d"]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"data": {"text/plain": ["['abc', 'def', 'ghi']"]}, "execution_count": 7, "metadata": {}, "output_type": "execute_result"}], "source": ["sorted(d)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["What happened here? \n", "\n", "Remember that iterating dictionaries actually iterates the keys - so we ended up with tyhe keys sorted alphabetically.\n", "\n", "What if we want to return the keys sorted by their associated value instead?"]}, {"cell_type": "code", "execution_count": 8, "metadata": {}, "outputs": [{"data": {"text/plain": ["['ghi', 'abc', 'def']"]}, "execution_count": 8, "metadata": {}, "output_type": "execute_result"}], "source": ["sorted(d, key=lambda k: d[k])"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Maybe we want to sort complex numbers based on their distance from the origin:"]}, {"cell_type": "code", "execution_count": 9, "metadata": {"collapsed": true}, "outputs": [], "source": ["def dist(x):\n", "    return (x.real)**2 + (x.imag)**2"]}, {"cell_type": "code", "execution_count": 10, "metadata": {"collapsed": true}, "outputs": [], "source": ["l = [3+3j, 1+1j, 0]"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Trying to sort this list directly won't work since Python does not have an ordering defined for complex numbers:"]}, {"cell_type": "code", "execution_count": 11, "metadata": {}, "outputs": [{"ename": "TypeError", "evalue": "'<' not supported between instances of 'complex' and 'complex'", "output_type": "error", "traceback": ["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[1;31mTypeError\u001b[0m                                 Traceback (most recent call last)", "\u001b[1;32m<ipython-input-11-5ed0ddfda5a6>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[1;32m----> 1\u001b[1;33m \u001b[0msorted\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0ml\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m", "\u001b[1;31mTypeError\u001b[0m: '<' not supported between instances of 'complex' and 'complex'"]}], "source": ["sorted(l)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Instead, let's try to specify the key using the distance:"]}, {"cell_type": "code", "execution_count": 12, "metadata": {}, "outputs": [{"data": {"text/plain": ["[0, (1+1j), (3+3j)]"]}, "execution_count": 12, "metadata": {}, "output_type": "execute_result"}], "source": ["sorted(l, key=dist)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Of course, if we're only going to use the **dist** function once, we can just do the same thing this way:"]}, {"cell_type": "code", "execution_count": 13, "metadata": {}, "outputs": [{"data": {"text/plain": ["[0, (1+1j), (3+3j)]"]}, "execution_count": 13, "metadata": {}, "output_type": "execute_result"}], "source": ["sorted(l, key=lambda x: (x.real)**2 + (x.imag)**2)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["And here's another example where we want to sort a list of strings based on the **last character** of the string:"]}, {"cell_type": "code", "execution_count": 14, "metadata": {"collapsed": true}, "outputs": [], "source": ["l = ['Cleese', 'Idle', 'Palin', 'Chapman', 'Gilliam', 'Jones']"]}, {"cell_type": "code", "execution_count": 15, "metadata": {}, "outputs": [{"data": {"text/plain": ["['Chapman', 'Cleese', 'Gilliam', 'Idle', 'Jones', 'Palin']"]}, "execution_count": 15, "metadata": {}, "output_type": "execute_result"}], "source": ["sorted(l)"]}, {"cell_type": "code", "execution_count": 16, "metadata": {}, "outputs": [{"data": {"text/plain": ["['Cleese', 'Idle', 'Gilliam', 'Palin', 'Chapman', 'Jones']"]}, "execution_count": 16, "metadata": {}, "output_type": "execute_result"}], "source": ["sorted(l, key=lambda s: s[-1])"]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Challenge: Randomizing an Iterable using Sorted"]}, {"cell_type": "code", "execution_count": 1, "metadata": {"collapsed": true}, "outputs": [], "source": ["import random"]}, {"cell_type": "code", "execution_count": 2, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Help on built-in function random:\n", "\n", "random(...) method of random.Random instance\n", "    random() -> x in the interval [0, 1).\n", "\n"]}], "source": ["help(random.random)"]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [{"data": {"text/plain": ["0.8655691916467607"]}, "execution_count": 3, "metadata": {}, "output_type": "execute_result"}], "source": ["random.random()"]}, {"cell_type": "code", "execution_count": 4, "metadata": {"collapsed": true}, "outputs": [], "source": ["l = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]"]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"data": {"text/plain": ["[5, 7, 2, 1, 3, 10, 9, 6, 8, 4]"]}, "execution_count": 5, "metadata": {}, "output_type": "execute_result"}], "source": ["sorted(l, key=lambda x: random.random())"]}, {"cell_type": "markdown", "metadata": {"collapsed": true}, "source": ["Of course, this works for any iterable:"]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [{"data": {"text/plain": ["['b', 'd', 'g', 'e', 'a', 'c', 'f']"]}, "execution_count": 6, "metadata": {}, "output_type": "execute_result"}], "source": ["sorted('abcdefg', key = lambda x: random.random())"]}, {"cell_type": "markdown", "metadata": {}, "source": ["And to get a string back instead of just a list:"]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"data": {"text/plain": ["'adfegbc'"]}, "execution_count": 7, "metadata": {}, "output_type": "execute_result"}], "source": ["''.join(sorted('abcdefg', key = lambda x: random.random()))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Function Introspection"]}, {"cell_type": "code", "execution_count": 1, "metadata": {"collapsed": true}, "outputs": [], "source": ["def fact(n: \"some non-negative integer\") -> \"n! or 0 if n < 0\":\n", "    \"\"\"Calculates the factorial of a non-negative integer n\n", "    \n", "    If n is negative, returns 0.\n", "    \"\"\"\n", "    if n < 0:\n", "        return 0\n", "    elif n <= 1:\n", "        return 1\n", "    else:\n", "        return n * fact(n-1)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Since functions are objects, we can add attributes to a function:"]}, {"cell_type": "code", "execution_count": 2, "metadata": {"collapsed": true}, "outputs": [], "source": ["fact.short_description = \"factorial function\""]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["factorial function\n"]}], "source": ["print(fact.short_description)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can see all the attributes that belong to a function using the **dir** function:"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"data": {"text/plain": ["['__annotations__',\n", " '__call__',\n", " '__class__',\n", " '__closure__',\n", " '__code__',\n", " '__defaults__',\n", " '__delattr__',\n", " '__dict__',\n", " '__dir__',\n", " '__doc__',\n", " '__eq__',\n", " '__format__',\n", " '__ge__',\n", " '__get__',\n", " '__getattribute__',\n", " '__globals__',\n", " '__gt__',\n", " '__hash__',\n", " '__init__',\n", " '__init_subclass__',\n", " '__kwdefaults__',\n", " '__le__',\n", " '__lt__',\n", " '__module__',\n", " '__name__',\n", " '__ne__',\n", " '__new__',\n", " '__qualname__',\n", " '__reduce__',\n", " '__reduce_ex__',\n", " '__repr__',\n", " '__setattr__',\n", " '__sizeof__',\n", " '__str__',\n", " '__subclasshook__',\n", " 'short_description']"]}, "execution_count": 4, "metadata": {}, "output_type": "execute_result"}], "source": ["dir(fact)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can see our **short_description** attribute, as well as some attributes we have seen before: **__annotations__** and **__doc__**:"]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"data": {"text/plain": ["'Calculates the factorial of a non-negative integer n\\n    \\n    If n is negative, returns 0.\\n    '"]}, "execution_count": 5, "metadata": {}, "output_type": "execute_result"}], "source": ["fact.__doc__"]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [{"data": {"text/plain": ["{'n': 'some non-negative integer', 'return': 'n! or 0 if n < 0'}"]}, "execution_count": 6, "metadata": {}, "output_type": "execute_result"}], "source": ["fact.__annotations__"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We'll revisit some of these attributes later in this course, but let's take a look at a few here:"]}, {"cell_type": "code", "execution_count": 7, "metadata": {"collapsed": true}, "outputs": [], "source": ["def my_func(a, b=2, c=3, *, kw1, kw2=2, **kwargs):\n", "    pass"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's assign my_func to another variable:"]}, {"cell_type": "code", "execution_count": 8, "metadata": {"collapsed": true}, "outputs": [], "source": ["f = my_func"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The **__name__** attribute holds the function's name:"]}, {"cell_type": "code", "execution_count": 9, "metadata": {}, "outputs": [{"data": {"text/plain": ["'my_func'"]}, "execution_count": 9, "metadata": {}, "output_type": "execute_result"}], "source": ["my_func.__name__"]}, {"cell_type": "code", "execution_count": 10, "metadata": {}, "outputs": [{"data": {"text/plain": ["'my_func'"]}, "execution_count": 10, "metadata": {}, "output_type": "execute_result"}], "source": ["f.__name__"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The **__defaults__** attribute is a tuple containing any positional parameter defaults:"]}, {"cell_type": "code", "execution_count": 11, "metadata": {}, "outputs": [{"data": {"text/plain": ["(2, 3)"]}, "execution_count": 11, "metadata": {}, "output_type": "execute_result"}], "source": ["my_func.__defaults__"]}, {"cell_type": "code", "execution_count": 12, "metadata": {}, "outputs": [{"data": {"text/plain": ["{'kw2': 2}"]}, "execution_count": 12, "metadata": {}, "output_type": "execute_result"}], "source": ["my_func.__kwdefaults__"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's create a function with some local variables:"]}, {"cell_type": "code", "execution_count": 13, "metadata": {"collapsed": true}, "outputs": [], "source": ["def my_func(a, b=1, *args, **kwargs):\n", "    i = 10\n", "    b = min(i, b)\n", "    return a * b"]}, {"cell_type": "code", "execution_count": 14, "metadata": {}, "outputs": [{"data": {"text/plain": ["'aaaaaaaaaa'"]}, "execution_count": 14, "metadata": {}, "output_type": "execute_result"}], "source": ["my_func('a', 100)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The **__code__** attribute contains a **code** object:"]}, {"cell_type": "code", "execution_count": 15, "metadata": {}, "outputs": [{"data": {"text/plain": ["<code object my_func at 0x0000016640E71300, file \"<ipython-input-13-785cf1a800f4>\", line 1>"]}, "execution_count": 15, "metadata": {}, "output_type": "execute_result"}], "source": ["my_func.__code__"]}, {"cell_type": "markdown", "metadata": {}, "source": ["This **code** object itself has various properties:"]}, {"cell_type": "code", "execution_count": 16, "metadata": {}, "outputs": [{"data": {"text/plain": ["['__class__',\n", " '__delattr__',\n", " '__dir__',\n", " '__doc__',\n", " '__eq__',\n", " '__format__',\n", " '__ge__',\n", " '__getattribute__',\n", " '__gt__',\n", " '__hash__',\n", " '__init__',\n", " '__init_subclass__',\n", " '__le__',\n", " '__lt__',\n", " '__ne__',\n", " '__new__',\n", " '__reduce__',\n", " '__reduce_ex__',\n", " '__repr__',\n", " '__setattr__',\n", " '__sizeof__',\n", " '__str__',\n", " '__subclasshook__',\n", " 'co_argcount',\n", " 'co_cellvars',\n", " 'co_code',\n", " 'co_consts',\n", " 'co_filename',\n", " 'co_firstlineno',\n", " 'co_flags',\n", " 'co_freevars',\n", " 'co_kwonlyargcount',\n", " 'co_lnotab',\n", " 'co_name',\n", " 'co_names',\n", " 'co_nlocals',\n", " 'co_stacksize',\n", " 'co_varnames']"]}, "execution_count": 16, "metadata": {}, "output_type": "execute_result"}], "source": ["dir(my_func.__code__)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Attribute **__co_varnames__** is a tuple containing the parameter names and local variables:"]}, {"cell_type": "code", "execution_count": 17, "metadata": {}, "outputs": [{"data": {"text/plain": ["('a', 'b', 'args', 'kwargs', 'i')"]}, "execution_count": 17, "metadata": {}, "output_type": "execute_result"}], "source": ["my_func.__code__.co_varnames"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Attribute **co_argcount** returns the number of arguments (minus any \\* and \\*\\* args)"]}, {"cell_type": "code", "execution_count": 18, "metadata": {}, "outputs": [{"data": {"text/plain": ["2"]}, "execution_count": 18, "metadata": {}, "output_type": "execute_result"}], "source": ["my_func.__code__.co_argcount"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### The **inspect** module"]}, {"cell_type": "markdown", "metadata": {}, "source": ["It is much easier to use the **inspect** module!"]}, {"cell_type": "code", "execution_count": 19, "metadata": {"collapsed": true}, "outputs": [], "source": ["import inspect"]}, {"cell_type": "code", "execution_count": 20, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 20, "metadata": {}, "output_type": "execute_result"}], "source": ["inspect.isfunction(my_func)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["By the way, there is a difference between a function and a method! A method is a function that is bound to some object:"]}, {"cell_type": "code", "execution_count": 21, "metadata": {}, "outputs": [{"data": {"text/plain": ["False"]}, "execution_count": 21, "metadata": {}, "output_type": "execute_result"}], "source": ["inspect.ismethod(my_func)"]}, {"cell_type": "code", "execution_count": 22, "metadata": {"collapsed": true}, "outputs": [], "source": ["class MyClass:\n", "    def f_instance(self):\n", "        pass\n", "    \n", "    @classmethod\n", "    def f_class(cls):\n", "        pass\n", "    \n", "    @staticmethod\n", "    def f_static():\n", "        pass"]}, {"cell_type": "markdown", "metadata": {}, "source": ["**Instance methods** are bound to the **instance** of a class (not the class itself)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["**Class methods** are bound to the **class**, not instances"]}, {"cell_type": "markdown", "metadata": {}, "source": ["**Static methods** are no bound either to the class or its instances"]}, {"cell_type": "code", "execution_count": 23, "metadata": {}, "outputs": [{"data": {"text/plain": ["(True, False)"]}, "execution_count": 23, "metadata": {}, "output_type": "execute_result"}], "source": ["inspect.isfunction(MyClass.f_instance), inspect.ismethod(MyClass.f_instance)"]}, {"cell_type": "code", "execution_count": 24, "metadata": {}, "outputs": [{"data": {"text/plain": ["(False, True)"]}, "execution_count": 24, "metadata": {}, "output_type": "execute_result"}], "source": ["inspect.isfunction(MyClass.f_class), inspect.ismethod(MyClass.f_class)"]}, {"cell_type": "code", "execution_count": 25, "metadata": {}, "outputs": [{"data": {"text/plain": ["(True, False)"]}, "execution_count": 25, "metadata": {}, "output_type": "execute_result"}], "source": ["inspect.isfunction(MyClass.f_static), inspect.ismethod(MyClass.f_static)"]}, {"cell_type": "code", "execution_count": 26, "metadata": {"collapsed": true}, "outputs": [], "source": ["my_obj = MyClass()"]}, {"cell_type": "code", "execution_count": 27, "metadata": {}, "outputs": [{"data": {"text/plain": ["(False, True)"]}, "execution_count": 27, "metadata": {}, "output_type": "execute_result"}], "source": ["inspect.isfunction(my_obj.f_instance), inspect.ismethod(my_obj.f_instance)"]}, {"cell_type": "code", "execution_count": 28, "metadata": {}, "outputs": [{"data": {"text/plain": ["(False, True)"]}, "execution_count": 28, "metadata": {}, "output_type": "execute_result"}], "source": ["inspect.isfunction(my_obj.f_class), inspect.ismethod(my_obj.f_class)"]}, {"cell_type": "code", "execution_count": 29, "metadata": {}, "outputs": [{"data": {"text/plain": ["(True, False)"]}, "execution_count": 29, "metadata": {}, "output_type": "execute_result"}], "source": ["inspect.isfunction(my_obj.f_static), inspect.ismethod(my_obj.f_static)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["If you just want to know if something is a function or method:"]}, {"cell_type": "code", "execution_count": 30, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 30, "metadata": {}, "output_type": "execute_result"}], "source": ["inspect.isroutine(my_func)"]}, {"cell_type": "code", "execution_count": 31, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 31, "metadata": {}, "output_type": "execute_result"}], "source": ["inspect.isroutine(MyClass.f_instance)"]}, {"cell_type": "code", "execution_count": 32, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 32, "metadata": {}, "output_type": "execute_result"}], "source": ["inspect.isroutine(my_obj.f_class)"]}, {"cell_type": "code", "execution_count": 33, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 33, "metadata": {}, "output_type": "execute_result"}], "source": ["inspect.isroutine(my_obj.f_static)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We'll revisit this in more detail in section on OOP."]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Introspecting Callable Code"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can get back the source code of our function using the **getsource()** method:"]}, {"cell_type": "code", "execution_count": 34, "metadata": {}, "outputs": [{"data": {"text/plain": ["'def fact(n: \"some non-negative integer\") -> \"n! or 0 if n < 0\":\\n    \"\"\"Calculates the factorial of a non-negative integer n\\n    \\n    If n is negative, returns 0.\\n    \"\"\"\\n    if n <= 1:\\n        return 1\\n    else:\\n        return n * fact(n-1)\\n'"]}, "execution_count": 34, "metadata": {}, "output_type": "execute_result"}], "source": ["inspect.getsource(fact)"]}, {"cell_type": "code", "execution_count": 35, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["def fact(n: \"some non-negative integer\") -> \"n! or 0 if n < 0\":\n", "    \"\"\"Calculates the factorial of a non-negative integer n\n", "    \n", "    If n is negative, returns 0.\n", "    \"\"\"\n", "    if n <= 1:\n", "        return 1\n", "    else:\n", "        return n * fact(n-1)\n", "\n"]}], "source": ["print(inspect.getsource(fact))"]}, {"cell_type": "code", "execution_count": 36, "metadata": {}, "outputs": [{"data": {"text/plain": ["'    def f_instance(self):\\n        pass\\n'"]}, "execution_count": 36, "metadata": {}, "output_type": "execute_result"}], "source": ["inspect.getsource(MyClass.f_instance)"]}, {"cell_type": "code", "execution_count": 37, "metadata": {}, "outputs": [{"data": {"text/plain": ["'    def f_instance(self):\\n        pass\\n'"]}, "execution_count": 37, "metadata": {}, "output_type": "execute_result"}], "source": ["inspect.getsource(my_obj.f_instance)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can also find out where the function was defined:"]}, {"cell_type": "code", "execution_count": 38, "metadata": {}, "outputs": [{"data": {"text/plain": ["<module '__main__'>"]}, "execution_count": 38, "metadata": {}, "output_type": "execute_result"}], "source": ["inspect.getmodule(fact)"]}, {"cell_type": "code", "execution_count": 39, "metadata": {}, "outputs": [{"data": {"text/plain": ["<module 'builtins' (built-in)>"]}, "execution_count": 39, "metadata": {}, "output_type": "execute_result"}], "source": ["inspect.getmodule(print)"]}, {"cell_type": "code", "execution_count": 40, "metadata": {"collapsed": true}, "outputs": [], "source": ["import math"]}, {"cell_type": "code", "execution_count": 41, "metadata": {}, "outputs": [{"data": {"text/plain": ["<module 'math' (built-in)>"]}, "execution_count": 41, "metadata": {}, "output_type": "execute_result"}], "source": ["inspect.getmodule(math.sin)"]}, {"cell_type": "code", "execution_count": 42, "metadata": {"collapsed": true}, "outputs": [], "source": ["# setting up variable\n", "i = 10\n", "\n", "# comment line 1\n", "# comment line 2\n", "def my_func(a, b=1):\n", "    # comment inside my_func\n", "    pass"]}, {"cell_type": "code", "execution_count": 43, "metadata": {}, "outputs": [{"data": {"text/plain": ["'# comment line 1\\n# comment line 2\\n'"]}, "execution_count": 43, "metadata": {}, "output_type": "execute_result"}], "source": ["inspect.getcomments(my_func)"]}, {"cell_type": "code", "execution_count": 44, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["# comment line 1\n", "# comment line 2\n", "\n"]}], "source": ["print(inspect.getcomments(my_func))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Introspecting Callable Signatures"]}, {"cell_type": "code", "execution_count": 45, "metadata": {"collapsed": true}, "outputs": [], "source": ["# TODO: Provide implementation\n", "def my_func(a: 'a string', \n", "            b: int = 1, \n", "            *args: 'additional positional args', \n", "            kw1: 'first keyword-only arg', \n", "            kw2: 'second keyword-only arg' = 10,\n", "            **kwargs: 'additional keyword-only args') -> str:\n", "    \"\"\"does something\n", "       or other\"\"\"\n", "    pass"]}, {"cell_type": "code", "execution_count": 46, "metadata": {}, "outputs": [{"data": {"text/plain": ["<Signature (a:'a string', b:int=1, *args:'additional positional args', kw1:'first keyword-only arg', kw2:'second keyword-only arg'=10, **kwargs:'additional keyword-only args') -> str>"]}, "execution_count": 46, "metadata": {}, "output_type": "execute_result"}], "source": ["inspect.signature(my_func)"]}, {"cell_type": "code", "execution_count": 47, "metadata": {}, "outputs": [{"data": {"text/plain": ["inspect.Signature"]}, "execution_count": 47, "metadata": {}, "output_type": "execute_result"}], "source": ["type(inspect.signature(my_func))"]}, {"cell_type": "code", "execution_count": 48, "metadata": {"collapsed": true}, "outputs": [], "source": ["sig = inspect.signature(my_func)"]}, {"cell_type": "code", "execution_count": 49, "metadata": {}, "outputs": [{"data": {"text/plain": ["['__class__',\n", " '__delattr__',\n", " '__dir__',\n", " '__doc__',\n", " '__eq__',\n", " '__format__',\n", " '__ge__',\n", " '__getattribute__',\n", " '__gt__',\n", " '__hash__',\n", " '__init__',\n", " '__init_subclass__',\n", " '__le__',\n", " '__lt__',\n", " '__module__',\n", " '__ne__',\n", " '__new__',\n", " '__reduce__',\n", " '__reduce_ex__',\n", " '__repr__',\n", " '__setattr__',\n", " '__setstate__',\n", " '__sizeof__',\n", " '__slots__',\n", " '__str__',\n", " '__subclasshook__',\n", " '_bind',\n", " '_bound_arguments_cls',\n", " '_hash_basis',\n", " '_parameter_cls',\n", " '_parameters',\n", " '_return_annotation',\n", " 'bind',\n", " 'bind_partial',\n", " 'empty',\n", " 'from_builtin',\n", " 'from_callable',\n", " 'from_function',\n", " 'parameters',\n", " 'replace',\n", " 'return_annotation']"]}, "execution_count": 49, "metadata": {}, "output_type": "execute_result"}], "source": ["dir(sig)"]}, {"cell_type": "code", "execution_count": 50, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["a a:'a string'\n", "b b:int=1\n", "args *args:'additional positional args'\n", "kw1 kw1:'first keyword-only arg'\n", "kw2 kw2:'second keyword-only arg'=10\n", "kwargs **kwargs:'additional keyword-only args'\n"]}], "source": ["for param_name, param in sig.parameters.items():\n", "    print(param_name, param)"]}, {"cell_type": "code", "execution_count": 51, "metadata": {"collapsed": true}, "outputs": [], "source": ["def print_info(f: \"callable\") -> None:\n", "    print(f.__name__)\n", "    print('=' * len(f.__name__), end='\\n\\n')\n", "    \n", "    print('{0}\\n{1}\\n'.format(inspect.getcomments(f), \n", "                              inspect.cleandoc(f.__doc__)))\n", "    \n", "    print('{0}\\n{1}'.format('Inputs', '-'*len('Inputs')))\n", "    \n", "    sig = inspect.signature(f)\n", "    for param in sig.parameters.values():\n", "        print('Name:', param.name)\n", "        print('Default:', param.default)\n", "        print('Annotation:', param.annotation)\n", "        print('Kind:', param.kind)\n", "        print('--------------------------\\n')\n", "        \n", "    print('{0}\\n{1}'.format('\\n\\nOutput', '-'*len('Output')))\n", "    print(sig.return_annotation)"]}, {"cell_type": "code", "execution_count": 52, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["my_func\n", "=======\n", "\n", "# TODO: Provide implementation\n", "\n", "does something\n", "or other\n", "\n", "Inputs\n", "------\n", "Name: a\n", "Default: <class 'inspect._empty'>\n", "Annotation: a string\n", "Kind: POSITIONAL_OR_KEYWORD\n", "--------------------------\n", "\n", "Name: b\n", "Default: 1\n", "Annotation: <class 'int'>\n", "Kind: POSITIONAL_OR_KEYWORD\n", "--------------------------\n", "\n", "Name: args\n", "Default: <class 'inspect._empty'>\n", "Annotation: additional positional args\n", "Kind: VAR_POSITIONAL\n", "--------------------------\n", "\n", "Name: kw1\n", "Default: <class 'inspect._empty'>\n", "Annotation: first keyword-only arg\n", "Kind: KEYWORD_ONLY\n", "--------------------------\n", "\n", "Name: kw2\n", "Default: 10\n", "Annotation: second keyword-only arg\n", "Kind: KEYWORD_ONLY\n", "--------------------------\n", "\n", "Name: kwargs\n", "Default: <class 'inspect._empty'>\n", "Annotation: additional keyword-only args\n", "Kind: VAR_KEYWORD\n", "--------------------------\n", "\n", "\n", "\n", "Output\n", "------\n", "<class 'str'>\n"]}], "source": ["print_info(my_func)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### A Side Note on Positional Only Arguments"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Some built-in callables have arguments that are positional only (i.e. cannot be specified using a keyword).\n", "\n", "However, Python does not currently have any syntax that allows us to define callables with positional only arguments.\n", "\n", "In general, the documentation uses a **/** character to indicate that all preceding arguments are positional-only. But not always :-("]}, {"cell_type": "code", "execution_count": 53, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Help on built-in function divmod in module builtins:\n", "\n", "divmod(x, y, /)\n", "    Return the tuple (x//y, x%y).  Invariant: div*y + mod == x.\n", "\n"]}], "source": ["help(divmod)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Here we see that the **divmod** function takes two positional-only parameters:"]}, {"cell_type": "code", "execution_count": 54, "metadata": {}, "outputs": [{"data": {"text/plain": ["(3, 1)"]}, "execution_count": 54, "metadata": {}, "output_type": "execute_result"}], "source": ["divmod(10, 3)"]}, {"cell_type": "code", "execution_count": 55, "metadata": {}, "outputs": [{"ename": "TypeError", "evalue": "divmod() takes no keyword arguments", "output_type": "error", "traceback": ["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[1;31mTypeError\u001b[0m                                 Traceback (most recent call last)", "\u001b[1;32m<ipython-input-55-c637b01eef33>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[1;32m----> 1\u001b[1;33m \u001b[0mdivmod\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mx\u001b[0m\u001b[1;33m=\u001b[0m\u001b[1;36m10\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0my\u001b[0m\u001b[1;33m=\u001b[0m\u001b[1;36m3\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m", "\u001b[1;31mTypeError\u001b[0m: divmod() takes no keyword arguments"]}], "source": ["divmod(x=10, y=3)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Similarly, the string **replace** function also takes positional-only arguments, however, the documentation does not indicate this!"]}, {"cell_type": "code", "execution_count": 56, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Help on method_descriptor:\n", "\n", "replace(...)\n", "    S.replace(old, new[, count]) -> str\n", "    \n", "    Return a copy of S with all occurrences of substring\n", "    old replaced by new.  If the optional argument count is\n", "    given, only the first count occurrences are replaced.\n", "\n"]}], "source": ["help(str.replace)"]}, {"cell_type": "code", "execution_count": 57, "metadata": {}, "outputs": [{"data": {"text/plain": ["'xyzdefg'"]}, "execution_count": 57, "metadata": {}, "output_type": "execute_result"}], "source": ["'abcdefg'.replace('abc', 'xyz')"]}, {"cell_type": "code", "execution_count": 58, "metadata": {}, "outputs": [{"ename": "TypeError", "evalue": "replace() takes no keyword arguments", "output_type": "error", "traceback": ["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[1;31mTypeError\u001b[0m                                 Traceback (most recent call last)", "\u001b[1;32m<ipython-input-58-9d61ac657cae>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[1;32m----> 1\u001b[1;33m \u001b[1;34m'abcdefg'\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mreplace\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mold\u001b[0m\u001b[1;33m=\u001b[0m\u001b[1;34m'abc'\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mnew\u001b[0m\u001b[1;33m=\u001b[0m\u001b[1;34m'xyz'\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m", "\u001b[1;31mTypeError\u001b[0m: replace() takes no keyword arguments"]}], "source": ["'abcdefg'.replace(old='abc', new='xyz')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Callables"]}, {"cell_type": "markdown", "metadata": {}, "source": ["A callable is an object that can be called (using the **()** operator), and always returns a value.\n", "\n", "We can check if an object is callable by using the built-in function **callable**"]}, {"cell_type": "markdown", "metadata": {}, "source": ["##### Functions and Methods are callable"]}, {"cell_type": "code", "execution_count": 1, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 1, "metadata": {}, "output_type": "execute_result"}], "source": ["callable(print)"]}, {"cell_type": "code", "execution_count": 2, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 2, "metadata": {}, "output_type": "execute_result"}], "source": ["callable(len)"]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 3, "metadata": {}, "output_type": "execute_result"}], "source": ["l = [1, 2, 3]\n", "callable(l.append)"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 4, "metadata": {}, "output_type": "execute_result"}], "source": ["s = 'abc'\n", "callable(s.upper)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["##### Callables **always** return a value:"]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["hello\n", "None\n"]}], "source": ["result = print('hello')\n", "print(result)"]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["None\n", "[1, 2, 3, 4]\n"]}], "source": ["l = [1, 2, 3]\n", "result = l.append(4)\n", "print(result)\n", "print(l)"]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["ABC\n"]}], "source": ["s = 'abc'\n", "result = s.upper()\n", "print(result)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["##### Classes are callable:"]}, {"cell_type": "code", "execution_count": 8, "metadata": {"collapsed": true}, "outputs": [], "source": ["from decimal import Decimal"]}, {"cell_type": "code", "execution_count": 9, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 9, "metadata": {}, "output_type": "execute_result"}], "source": ["callable(Decimal)"]}, {"cell_type": "code", "execution_count": 10, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["10.5\n"]}], "source": ["result = Decimal('10.5')\n", "print(result)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["##### Class instances may be callable:"]}, {"cell_type": "code", "execution_count": 11, "metadata": {"collapsed": true}, "outputs": [], "source": ["class MyClass:\n", "    def __init__(self):\n", "        print('initializing...')\n", "        self.counter = 0\n", "    \n", "    def __call__(self, x=1):\n", "        self.counter += x\n", "        print(self.counter)"]}, {"cell_type": "code", "execution_count": 12, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["initializing...\n"]}], "source": ["my_obj = MyClass()"]}, {"cell_type": "code", "execution_count": 13, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 13, "metadata": {}, "output_type": "execute_result"}], "source": ["callable(my_obj.__init__)"]}, {"cell_type": "code", "execution_count": 14, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 14, "metadata": {}, "output_type": "execute_result"}], "source": ["callable(my_obj.__call__)"]}, {"cell_type": "code", "execution_count": 15, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1\n"]}], "source": ["my_obj()"]}, {"cell_type": "code", "execution_count": 16, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["2\n"]}], "source": ["my_obj()"]}, {"cell_type": "code", "execution_count": 17, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["12\n"]}], "source": ["my_obj(10)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Higher-Order Functions: Map and Filter"]}, {"cell_type": "markdown", "metadata": {}, "source": ["**Definition**: A function that takes a function as an argument, and/or returns a function as its return value"]}, {"cell_type": "markdown", "metadata": {}, "source": ["For example, the **sorted** function is a higher-order function as we saw in an earlier video."]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Map"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The **map** built-in function is a higher-order function that applies a function to an iterable type object:"]}, {"cell_type": "code", "execution_count": 1, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Help on class map in module builtins:\n", "\n", "class map(object)\n", " |  map(func, *iterables) --> map object\n", " |  \n", " |  Make an iterator that computes the function using arguments from\n", " |  each of the iterables.  Stops when the shortest iterable is exhausted.\n", " |  \n", " |  Methods defined here:\n", " |  \n", " |  __getattribute__(self, name, /)\n", " |      Return getattr(self, name).\n", " |  \n", " |  __iter__(self, /)\n", " |      Implement iter(self).\n", " |  \n", " |  __new__(*args, **kwargs) from builtins.type\n", " |      Create and return a new object.  See help(type) for accurate signature.\n", " |  \n", " |  __next__(self, /)\n", " |      Implement next(self).\n", " |  \n", " |  __reduce__(...)\n", " |      Return state information for pickling.\n", "\n"]}], "source": ["help(map)"]}, {"cell_type": "code", "execution_count": 2, "metadata": {"collapsed": true}, "outputs": [], "source": ["def fact(n):\n", "    return 1 if n < 2 else n * fact(n-1)"]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [{"data": {"text/plain": ["6"]}, "execution_count": 3, "metadata": {}, "output_type": "execute_result"}], "source": ["fact(3)"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"data": {"text/plain": ["24"]}, "execution_count": 4, "metadata": {}, "output_type": "execute_result"}], "source": ["fact(4)"]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"data": {"text/plain": ["<map at 0x23b123a3978>"]}, "execution_count": 5, "metadata": {}, "output_type": "execute_result"}], "source": ["map(fact, [1, 2, 3, 4, 5])"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The **map** function returns a **map** object, which is an **iterable** - we can either convert that to a list or enumerate it:"]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["[1, 2, 6, 24, 120]\n"]}], "source": ["l = list(map(fact, [1, 2, 3, 4, 5]))\n", "print(l)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can also use it this way:"]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"data": {"text/plain": ["[11, 22, 33, 44, 55]"]}, "execution_count": 7, "metadata": {}, "output_type": "execute_result"}], "source": ["l1 = [1, 2, 3, 4, 5]\n", "l2 = [10, 20, 30, 40, 50]\n", "\n", "f = lambda x, y: x+y\n", "\n", "m = map(f, l1, l2)\n", "list(m)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Filter"]}, {"cell_type": "code", "execution_count": 8, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Help on class filter in module builtins:\n", "\n", "class filter(object)\n", " |  filter(function or None, iterable) --> filter object\n", " |  \n", " |  Return an iterator yielding those items of iterable for which function(item)\n", " |  is true. If function is None, return the items that are true.\n", " |  \n", " |  Methods defined here:\n", " |  \n", " |  __getattribute__(self, name, /)\n", " |      Return getattr(self, name).\n", " |  \n", " |  __iter__(self, /)\n", " |      Implement iter(self).\n", " |  \n", " |  __new__(*args, **kwargs) from builtins.type\n", " |      Create and return a new object.  See help(type) for accurate signature.\n", " |  \n", " |  __next__(self, /)\n", " |      Implement next(self).\n", " |  \n", " |  __reduce__(...)\n", " |      Return state information for pickling.\n", "\n"]}], "source": ["help(filter)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The **filter** function is a function that filters an iterable based on the truthyness of the elements, or the truthyness of the elements after applying a function to them. Like the **map** function, the **filter** function returns an iterable that we can view by generating a list from it, or simply enumerating in a for loop."]}, {"cell_type": "code", "execution_count": 9, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1\n", "2\n", "3\n", "4\n", "5\n", "6\n"]}], "source": ["l = [0, 1, 2, 3, 4, 5, 6]\n", "for e in filter(None, l):\n", "    print(e)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Notice how **0** was eliminated from the list, since **0** is **falsy**."]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can use a function for this filtering.\n", "\n", "Suppose we want to filter out all odd values, only retaining even values:"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We could first define a function to return True if the value is even, and False otherwise:"]}, {"cell_type": "code", "execution_count": 10, "metadata": {"collapsed": true}, "outputs": [], "source": ["def is_even(n):\n", "    return n % 2 == 0"]}, {"cell_type": "code", "execution_count": 11, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["[2, 4, 6, 8]\n"]}], "source": ["l = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n", "result = filter(is_even, l)\n", "print(list(result))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Of course, we could just use a lambda expression instead:"]}, {"cell_type": "code", "execution_count": 12, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["[2, 4, 6, 8]\n"]}], "source": ["l = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n", "result = filter(lambda x: x % 2 == 0, l)\n", "print(list(result))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Alternatives to **map** and **filter** using Comprehensions"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We'll cover comprehensions in much more detail later, but, for now, just be aware that we can use comprehensions instead of the **map** and **filter** functions - you decide which one you find more readable and enjoyable to write."]}, {"cell_type": "markdown", "metadata": {}, "source": ["##### Map using a list comprehension:"]}, {"cell_type": "markdown", "metadata": {}, "source": ["* factorial example"]}, {"cell_type": "code", "execution_count": 13, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["[1, 2, 6, 24, 120]\n"]}], "source": ["l = [1, 2, 3, 4, 5]\n", "result = [fact(i) for i in l]\n", "print(result)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["* two iterables example"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Before we do this example we need to know about the **zip** function.\n", "\n", "The **zip** built-in function will take one or more iterables, and generate an iterable of tuples where each tuple contains one element from each iterable:"]}, {"cell_type": "code", "execution_count": 14, "metadata": {}, "outputs": [{"data": {"text/plain": ["[(1, 'a'), (2, 'b'), (3, 'c')]"]}, "execution_count": 14, "metadata": {}, "output_type": "execute_result"}], "source": ["l1 = 1, 2, 3\n", "l2 = 'a', 'b', 'c'\n", "list(zip(l1, l2))"]}, {"cell_type": "code", "execution_count": 15, "metadata": {}, "outputs": [{"data": {"text/plain": ["[(1, 10, 'a'), (2, 20, 'b'), (3, 30, 'c')]"]}, "execution_count": 15, "metadata": {}, "output_type": "execute_result"}], "source": ["l1 = 1, 2, 3\n", "l2 = [10, 20, 30]\n", "l3 = ('a', 'b', 'c')\n", "list(zip(l1, l2, l3))"]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"data": {"text/plain": ["[(1, 10, 'a'), (2, 20, 'b'), (3, 30, 'c')]"]}, "execution_count": 5, "metadata": {}, "output_type": "execute_result"}], "source": ["l1 = [1, 2, 3]\n", "l2 = (10, 20, 30)\n", "l3 = 'abc'\n", "list(zip(l1, l2, l3))"]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"data": {"text/plain": ["[(0, 'p'), (1, 'y'), (2, 't'), (3, 'h'), (4, 'o'), (5, 'n')]"]}, "execution_count": 7, "metadata": {}, "output_type": "execute_result"}], "source": ["l1 = range(100)\n", "l2 = 'python'\n", "list(zip(l1, l2))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Using the **zip** function we can now add our two lists element by element as follows:"]}, {"cell_type": "code", "execution_count": 16, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["[11, 22, 33, 44, 55]\n"]}], "source": ["l1 = [1, 2, 3, 4, 5]\n", "l2 = [10, 20, 30, 40, 50]\n", "result = [i + j for i,j in zip(l1,l2)]\n", "print(result)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["##### Filtering using a comprehension"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can very easily filter an iterable using a comprehension as follows:"]}, {"cell_type": "code", "execution_count": 17, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["[2, 4, 6, 8]\n"]}], "source": ["l = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n", "\n", "result = [i for i in l if i % 2 == 0]\n", "print(result)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see, we did not even need a lambda expression!"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Combining **map** and **filter**"]}, {"cell_type": "code", "execution_count": 1, "metadata": {}, "outputs": [{"data": {"text/plain": ["[0, 1, 4, 9, 16]"]}, "execution_count": 1, "metadata": {}, "output_type": "execute_result"}], "source": ["list(filter(lambda y: y < 25, map(lambda x: x**2, range(10))))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Alternatively, we can use a list comprehension to do the same thing:"]}, {"cell_type": "code", "execution_count": 2, "metadata": {}, "outputs": [{"data": {"text/plain": ["[0, 1, 4, 9, 16]"]}, "execution_count": 2, "metadata": {}, "output_type": "execute_result"}], "source": ["[x**2 for x in range(10) if x**2 < 25]"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We will come back, in more detail, to comprehensions and generators later in this course."]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Reducing Functions in Python"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Maximum and Minimum"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Suppose we want to find the maximum value in a list:"]}, {"cell_type": "code", "execution_count": 1, "metadata": {"collapsed": true}, "outputs": [], "source": ["l = [5, 8, 6, 10, 9]"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can solve this problem using a **for** loop."]}, {"cell_type": "markdown", "metadata": {}, "source": ["First we define a function that returns the maximum of two arguments:"]}, {"cell_type": "code", "execution_count": 2, "metadata": {"collapsed": true}, "outputs": [], "source": ["_max = lambda a, b: a if a > b else b"]}, {"cell_type": "code", "execution_count": 3, "metadata": {"collapsed": true}, "outputs": [], "source": ["def max_sequence(sequence):\n", "    result = sequence[0]\n", "    for x in sequence[1:]:\n", "        result = _max(result, x)\n", "    return result"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"data": {"text/plain": ["10"]}, "execution_count": 4, "metadata": {}, "output_type": "execute_result"}], "source": ["max_sequence(l)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["To calculate the minimum, all we need to do is to change the function that is repeatedly applied:"]}, {"cell_type": "code", "execution_count": 5, "metadata": {"collapsed": true}, "outputs": [], "source": ["_min = lambda a, b: a if a < b else b"]}, {"cell_type": "code", "execution_count": 6, "metadata": {"collapsed": true}, "outputs": [], "source": ["def min_sequence(sequence):\n", "    result = sequence[0]\n", "    for x in sequence[1:]:\n", "        result = _min(result, x)\n", "    return result"]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["[5, 8, 6, 10, 9]\n", "5\n"]}], "source": ["print(l)\n", "print(min_sequence(l))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["In general we could write it like this:"]}, {"cell_type": "code", "execution_count": 8, "metadata": {"collapsed": true}, "outputs": [], "source": ["def _reduce(fn, sequence):\n", "    result = sequence[0]\n", "    for x in sequence[1:]:\n", "        result = fn(result, x)\n", "    return result"]}, {"cell_type": "code", "execution_count": 9, "metadata": {}, "outputs": [{"data": {"text/plain": ["10"]}, "execution_count": 9, "metadata": {}, "output_type": "execute_result"}], "source": ["_reduce(_max, l)"]}, {"cell_type": "code", "execution_count": 10, "metadata": {}, "outputs": [{"data": {"text/plain": ["5"]}, "execution_count": 10, "metadata": {}, "output_type": "execute_result"}], "source": ["_reduce(_min, l)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We could even just use a lambda directly in the call to **\\_reduce**:"]}, {"cell_type": "code", "execution_count": 11, "metadata": {}, "outputs": [{"data": {"text/plain": ["10"]}, "execution_count": 11, "metadata": {}, "output_type": "execute_result"}], "source": ["_reduce(lambda a, b: a if a > b else b, l)"]}, {"cell_type": "code", "execution_count": 12, "metadata": {}, "outputs": [{"data": {"text/plain": ["5"]}, "execution_count": 12, "metadata": {}, "output_type": "execute_result"}], "source": ["_reduce(lambda a, b: a if a < b else b, l)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Using the same approach, we could even add all the elements of a sequence together:"]}, {"cell_type": "code", "execution_count": 13, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["[5, 8, 6, 10, 9]\n"]}], "source": ["print(l)"]}, {"cell_type": "code", "execution_count": 14, "metadata": {}, "outputs": [{"data": {"text/plain": ["38"]}, "execution_count": 14, "metadata": {}, "output_type": "execute_result"}], "source": ["_reduce(lambda a, b: a + b, l)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Python actually implements a reduce function, which is found in the **functools** module. Unlike our **\\_reduce** function, it can handle any iterable, not just sequences."]}, {"cell_type": "code", "execution_count": 15, "metadata": {"collapsed": true}, "outputs": [], "source": ["from functools import reduce"]}, {"cell_type": "code", "execution_count": 16, "metadata": {}, "outputs": [{"data": {"text/plain": ["[5, 8, 6, 10, 9]"]}, "execution_count": 16, "metadata": {}, "output_type": "execute_result"}], "source": ["l"]}, {"cell_type": "code", "execution_count": 17, "metadata": {}, "outputs": [{"data": {"text/plain": ["10"]}, "execution_count": 17, "metadata": {}, "output_type": "execute_result"}], "source": ["reduce(lambda a, b: a if a > b else b, l)"]}, {"cell_type": "code", "execution_count": 18, "metadata": {}, "outputs": [{"data": {"text/plain": ["5"]}, "execution_count": 18, "metadata": {}, "output_type": "execute_result"}], "source": ["reduce(lambda a, b: a if a < b else b, l)"]}, {"cell_type": "code", "execution_count": 19, "metadata": {}, "outputs": [{"data": {"text/plain": ["38"]}, "execution_count": 19, "metadata": {}, "output_type": "execute_result"}], "source": ["reduce(lambda a, b: a + b, l)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Finding the max and min of an iterable is such a common thing that Python provides a built-in function to do just that:"]}, {"cell_type": "code", "execution_count": 20, "metadata": {"scrolled": true}, "outputs": [{"data": {"text/plain": ["(10, 5)"]}, "execution_count": 20, "metadata": {}, "output_type": "execute_result"}], "source": ["max(l), min(l)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Finding the sum of all the elements in an iterable is also common enough that Python implements the **sum** function:"]}, {"cell_type": "code", "execution_count": 21, "metadata": {}, "outputs": [{"data": {"text/plain": ["38"]}, "execution_count": 21, "metadata": {}, "output_type": "execute_result"}], "source": ["sum(l)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### The **any** and **all** built-ins"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Python provides two additional built-in reducing functions: **any** and **all**."]}, {"cell_type": "markdown", "metadata": {}, "source": ["The **any** function will return **True** if any element in the iterable is truthy:"]}, {"cell_type": "code", "execution_count": 22, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 22, "metadata": {}, "output_type": "execute_result"}], "source": ["l = [0, 1, 2]\n", "any(l)"]}, {"cell_type": "code", "execution_count": 23, "metadata": {}, "outputs": [{"data": {"text/plain": ["False"]}, "execution_count": 23, "metadata": {}, "output_type": "execute_result"}], "source": ["l = [0, 0, 0]\n", "any(l)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["On the other hand, **all** will return True if **every** element of the iterable is truthy:"]}, {"cell_type": "code", "execution_count": 24, "metadata": {}, "outputs": [{"data": {"text/plain": ["False"]}, "execution_count": 24, "metadata": {}, "output_type": "execute_result"}], "source": ["l = [0, 1, 2]\n", "all(l)"]}, {"cell_type": "code", "execution_count": 25, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 25, "metadata": {}, "output_type": "execute_result"}], "source": ["l = [1, 2, 3]\n", "all(l)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can implement these functions ourselves using **reduce** if we choose to - simply use the Boolean **or** or **and** operators as the function passed to **reduce** to implement **any** and **all** respectively."]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### any"]}, {"cell_type": "code", "execution_count": 26, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 26, "metadata": {}, "output_type": "execute_result"}], "source": ["l = [0, 1, 2]\n", "reduce(lambda a, b: bool(a or b), l)"]}, {"cell_type": "code", "execution_count": 27, "metadata": {}, "outputs": [{"data": {"text/plain": ["False"]}, "execution_count": 27, "metadata": {}, "output_type": "execute_result"}], "source": ["l = [0, 0, 0]\n", "reduce(lambda a, b: bool(a or b), l)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### all"]}, {"cell_type": "code", "execution_count": 28, "metadata": {}, "outputs": [{"data": {"text/plain": ["False"]}, "execution_count": 28, "metadata": {}, "output_type": "execute_result"}], "source": ["l = [0, 1, 2]\n", "reduce(lambda a, b: bool(a and b), l)"]}, {"cell_type": "code", "execution_count": 29, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 29, "metadata": {}, "output_type": "execute_result"}], "source": ["l = [1, 2, 3]\n", "reduce(lambda a, b: bool(a and b), l)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Products"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Sometimes we may want to find the product of every element of an iterable.\n", "\n", "Python does not provide us a built-in method to do this, so we have to either use a procedural approach, or we can use the **reduce** function."]}, {"cell_type": "markdown", "metadata": {}, "source": ["We start by defining a function that multiplies two arguments together:"]}, {"cell_type": "code", "execution_count": 30, "metadata": {"collapsed": true}, "outputs": [], "source": ["def mult(a, b):\n", "    return a * b"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Then we can use the **reduce** function:"]}, {"cell_type": "code", "execution_count": 31, "metadata": {}, "outputs": [{"data": {"text/plain": ["24"]}, "execution_count": 31, "metadata": {}, "output_type": "execute_result"}], "source": ["l = [2, 3, 4]\n", "reduce(mult, l)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Remember what this did:\n", "\n", "    step 1: result = 2\n", "    step 2: result = mult(result, 3) = mult(2, 3) = 6\n", "    step 3: result = mult(result, 4) = mult(6, 4) = 24\n", "    step 4: l exhausted, return result --> 24"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Of course, we can also just use a lambda:"]}, {"cell_type": "code", "execution_count": 32, "metadata": {}, "outputs": [{"data": {"text/plain": ["24"]}, "execution_count": 32, "metadata": {}, "output_type": "execute_result"}], "source": ["reduce(lambda a, b: a * b, l)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Factorials"]}, {"cell_type": "markdown", "metadata": {}, "source": ["##### Factorials"]}, {"cell_type": "markdown", "metadata": {}, "source": ["A special case of the product we just did would be calculating the factorial of some number (**n!**):"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Recall:\n", "\n", "    n! = 1 * 2 * 3 * ... * n"]}, {"cell_type": "markdown", "metadata": {}, "source": ["In other words, we are calculating the product of a sequence containing consecutive integers from 1 to n (inclusive)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can easily write this using a simple for loop:"]}, {"cell_type": "code", "execution_count": 33, "metadata": {"collapsed": true}, "outputs": [], "source": ["def fact(n):\n", "    if n <= 1:\n", "        return 1\n", "    else:\n", "        result = 1\n", "        for i in range(2, n+1):\n", "            result *= i\n", "        return result"]}, {"cell_type": "code", "execution_count": 34, "metadata": {}, "outputs": [{"data": {"text/plain": ["(1, 2, 6, 24, 120)"]}, "execution_count": 34, "metadata": {}, "output_type": "execute_result"}], "source": ["fact(1), fact(2), fact(3), fact(4), fact(5)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We could also write this using a recursive function:"]}, {"cell_type": "code", "execution_count": 35, "metadata": {"collapsed": true}, "outputs": [], "source": ["def fact(n):\n", "    if n <=1:\n", "        return 1\n", "    else:\n", "        return n * fact(n-1)"]}, {"cell_type": "code", "execution_count": 36, "metadata": {}, "outputs": [{"data": {"text/plain": ["(1, 2, 6, 24, 120)"]}, "execution_count": 36, "metadata": {}, "output_type": "execute_result"}], "source": ["fact(1), fact(2), fact(3), fact(4), fact(5)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Finally we can also write this using **reduce** as follows:"]}, {"cell_type": "code", "execution_count": 37, "metadata": {}, "outputs": [{"data": {"text/plain": ["120"]}, "execution_count": 37, "metadata": {}, "output_type": "execute_result"}], "source": ["n = 5\n", "reduce(lambda a, b: a * b, range(1, n+1))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see, the **reduce** approach, although concise, is sometimes more difficult to understand than the plain loop or recursive approach."]}, {"cell_type": "markdown", "metadata": {"collapsed": true}, "source": ["#### **reduce** initializer"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Suppose we want to provide some sort of default when we claculate the product of the elements of an iterable if that iterable is empty:"]}, {"cell_type": "code", "execution_count": 38, "metadata": {}, "outputs": [{"data": {"text/plain": ["6"]}, "execution_count": 38, "metadata": {}, "output_type": "execute_result"}], "source": ["l = [1, 2, 3]\n", "reduce(lambda x, y: x*y, l)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["but if **l** is empty:"]}, {"cell_type": "code", "execution_count": 39, "metadata": {}, "outputs": [{"ename": "TypeError", "evalue": "reduce() of empty sequence with no initial value", "output_type": "error", "traceback": ["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[1;31mTypeError\u001b[0m                                 Traceback (most recent call last)", "\u001b[1;32m<ipython-input-39-09fa1e2b48dc>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[0;32m      1\u001b[0m \u001b[0ml\u001b[0m \u001b[1;33m=\u001b[0m \u001b[1;33m[\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m----> 2\u001b[1;33m \u001b[0mreduce\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;32mlambda\u001b[0m \u001b[0mx\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0my\u001b[0m\u001b[1;33m:\u001b[0m \u001b[0mx\u001b[0m\u001b[1;33m*\u001b[0m\u001b[0my\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0ml\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m", "\u001b[1;31mTypeError\u001b[0m: reduce() of empty sequence with no initial value"]}], "source": ["l = []\n", "reduce(lambda x, y: x*y, l)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["To fix this, we can provide an initializer. In this case, we will use **1** since that will not affect the result of the product, and still allow us to return a value for an empty iterable."]}, {"cell_type": "code", "execution_count": 40, "metadata": {}, "outputs": [{"data": {"text/plain": ["1"]}, "execution_count": 40, "metadata": {}, "output_type": "execute_result"}], "source": ["l = []\n", "reduce(lambda x, y: x*y, l, 1)"]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": []}, {"cell_type": "markdown", "metadata": {}, "source": ["### Partial Functions"]}, {"cell_type": "code", "execution_count": 1, "metadata": {"collapsed": true}, "outputs": [], "source": ["from functools import partial"]}, {"cell_type": "code", "execution_count": 2, "metadata": {"collapsed": true}, "outputs": [], "source": ["def my_func(a, b, c):\n", "    print(a, b, c)"]}, {"cell_type": "code", "execution_count": 3, "metadata": {"collapsed": true}, "outputs": [], "source": ["f = partial(my_func, 10)"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["10 20 30\n"]}], "source": ["f(20, 30)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We could have done this using another function (or a lambda) as well:"]}, {"cell_type": "code", "execution_count": 5, "metadata": {"collapsed": true}, "outputs": [], "source": ["def partial_func(b, c):\n", "    return my_func(10, b, c)"]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["10 20 30\n"]}], "source": ["partial_func(20, 30)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["or, using a lambda:"]}, {"cell_type": "code", "execution_count": 7, "metadata": {"collapsed": true}, "outputs": [], "source": ["fn = lambda b, c: my_func(10, b, c)"]}, {"cell_type": "code", "execution_count": 8, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["10 20 30\n"]}], "source": ["fn(20, 30)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Any of these ways is fine, but sometimes partial is just a cleaner more consise way to do it.\n", "\n", "Also, it is quite flexible with parameters:"]}, {"cell_type": "code", "execution_count": 9, "metadata": {"collapsed": true}, "outputs": [], "source": ["def my_func(a, b, *args, k1, k2, **kwargs):\n", "    print(a, b, args, k1, k2, kwargs)"]}, {"cell_type": "code", "execution_count": 10, "metadata": {"collapsed": true}, "outputs": [], "source": ["f = partial(my_func, 10, k1='a')"]}, {"cell_type": "code", "execution_count": 11, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["10 20 (30, 40) a b {'k3': 'c'}\n"]}], "source": ["f(20, 30, 40, k2='b', k3='c')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can of course do the same thing using a regular function too:"]}, {"cell_type": "code", "execution_count": 12, "metadata": {"collapsed": true}, "outputs": [], "source": ["def f(b, *args, k2, **kwargs):\n", "    return my_func(10, b, *args, k1='a', k2=k2, **kwargs)"]}, {"cell_type": "code", "execution_count": 13, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["10 20 (30, 40) a b {'k3': 'c'}\n"]}], "source": ["f(20, 30, 40, k2='b', k3='c')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see in this case, using **partial** seems a lot simpler."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Also, you are not stuck having to specify the first argument in your partial:"]}, {"cell_type": "code", "execution_count": 14, "metadata": {"collapsed": true}, "outputs": [], "source": ["def power(base, exponent):\n", "    return base ** exponent"]}, {"cell_type": "code", "execution_count": 15, "metadata": {}, "outputs": [{"data": {"text/plain": ["8"]}, "execution_count": 15, "metadata": {}, "output_type": "execute_result"}], "source": ["power(2, 3)"]}, {"cell_type": "code", "execution_count": 16, "metadata": {"collapsed": true}, "outputs": [], "source": ["square = partial(power, exponent=2)"]}, {"cell_type": "code", "execution_count": 17, "metadata": {}, "outputs": [{"data": {"text/plain": ["16"]}, "execution_count": 17, "metadata": {}, "output_type": "execute_result"}], "source": ["square(4)"]}, {"cell_type": "code", "execution_count": 18, "metadata": {"collapsed": true}, "outputs": [], "source": ["cube = partial(power, exponent=3)"]}, {"cell_type": "code", "execution_count": 19, "metadata": {}, "outputs": [{"data": {"text/plain": ["8"]}, "execution_count": 19, "metadata": {}, "output_type": "execute_result"}], "source": ["cube(2)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["You can even call it this way:"]}, {"cell_type": "code", "execution_count": 20, "metadata": {}, "outputs": [{"data": {"text/plain": ["27"]}, "execution_count": 20, "metadata": {}, "output_type": "execute_result"}], "source": ["cube(base=3)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Caveat"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can certainly use variables instead of literals when creating partials, but we have to be careful."]}, {"cell_type": "code", "execution_count": 21, "metadata": {"collapsed": true}, "outputs": [], "source": ["def my_func(a, b, c):\n", "    print(a, b, c)"]}, {"cell_type": "code", "execution_count": 22, "metadata": {"collapsed": true}, "outputs": [], "source": ["a = 10\n", "f = partial(my_func, a)"]}, {"cell_type": "code", "execution_count": 23, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["10 20 30\n"]}], "source": ["f(20, 30)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now let's change the value of the variable **a** and see what happens:"]}, {"cell_type": "code", "execution_count": 24, "metadata": {"collapsed": true}, "outputs": [], "source": ["a = 100"]}, {"cell_type": "code", "execution_count": 25, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["10 20 30\n"]}], "source": ["f(20, 30)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see, the value for **a** is fixed once the partial has been created.\n", "\n", "In fact, the memory address of **a** is baked in to the partial, and **a** is immutable."]}, {"cell_type": "markdown", "metadata": {}, "source": ["If we use a mutable object, things are different:"]}, {"cell_type": "code", "execution_count": 26, "metadata": {"collapsed": true}, "outputs": [], "source": ["a = [10, 20]\n", "f = partial(my_func, a)"]}, {"cell_type": "code", "execution_count": 27, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["[10, 20] 100 200\n"]}], "source": ["f(100, 200)"]}, {"cell_type": "code", "execution_count": 28, "metadata": {"collapsed": true}, "outputs": [], "source": ["a.append(30)"]}, {"cell_type": "code", "execution_count": 29, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["[10, 20, 30] 100 200\n"]}], "source": ["f(100, 200)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Use Cases"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We tend to use partials in situation where we need to call a function that actually requires more parameters than we can supply.\n", "\n", "Often this is because we are working with exiting libraries or code, and we have a special case."]}, {"cell_type": "markdown", "metadata": {}, "source": ["For example, suppose we have points (represented as tuples), and we want to sort them based on the distance of the point from some other fixed point:"]}, {"cell_type": "code", "execution_count": 30, "metadata": {"collapsed": true}, "outputs": [], "source": ["origin = (0, 0)"]}, {"cell_type": "code", "execution_count": 31, "metadata": {"collapsed": true}, "outputs": [], "source": ["l = [(1,1), (0, 2), (-3, 2), (0,0), (10, 10)]"]}, {"cell_type": "code", "execution_count": 32, "metadata": {"collapsed": true}, "outputs": [], "source": ["dist2 = lambda x, y: (x[0]-y[0])**2 + (x[1]-y[1])**2"]}, {"cell_type": "code", "execution_count": 33, "metadata": {}, "outputs": [{"data": {"text/plain": ["2"]}, "execution_count": 33, "metadata": {}, "output_type": "execute_result"}], "source": ["dist2((0,0), (1,1))"]}, {"cell_type": "code", "execution_count": 34, "metadata": {}, "outputs": [{"data": {"text/plain": ["[(0, 0), (1, 1), (0, 2), (-3, 2), (10, 10)]"]}, "execution_count": 34, "metadata": {}, "output_type": "execute_result"}], "source": ["sorted(l, key = lambda x: dist2((0,0), x))"]}, {"cell_type": "code", "execution_count": 35, "metadata": {}, "outputs": [{"data": {"text/plain": ["[(0, 0), (1, 1), (0, 2), (-3, 2), (10, 10)]"]}, "execution_count": 35, "metadata": {}, "output_type": "execute_result"}], "source": ["sorted(l, key=partial(dist2, (0,0)))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Another use case is when using **callback** functions. Usually these are used when running asynchronous operations, and you provide a callable to another callable which will be called when the first callable completes its execution.\n", "\n", "Very often, the asynchronous callable will specify the number of variables that the callback function must have - this may not be what we want, maybe we want to add some additional info."]}, {"cell_type": "markdown", "metadata": {}, "source": ["We'll look at asynchronous processing later in this course."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Often we can also use partial functions to make our life a bit easier.\n", "\n", "Consider a situation where we have some generic `email()` function that can be used to notify someone when various things happen in our application. But depending on what is happening we may want to notify different people. Let's see how we may do this:"]}, {"cell_type": "code", "execution_count": 36, "metadata": {"collapsed": true}, "outputs": [], "source": ["def sendmail(to, subject, body):\n", "    # code to send email\n", "    print('To:{0}, Subject:{1}, Body:{2}'.format(to, subject, body))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now, we may haver different email adresses we want to send notifications to, maybe defined in a config file in our app. Here, I'll just use hardcoded variables:"]}, {"cell_type": "code", "execution_count": 37, "metadata": {"collapsed": true}, "outputs": [], "source": ["email_admin = 'palin@python.edu'\n", "email_devteam = 'idle@python.edu;cleese@python.edu'"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now when we want to send emails we would have to write things like:"]}, {"cell_type": "code", "execution_count": 38, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["To:palin@python.edu, Subject:My App Notification, Body:the parrot is dead.\n", "To:palin@python.edu;idle@python.edu;cleese@python.edu, Subject:My App Notification, Body:the ministry is closed until further notice.\n"]}], "source": ["sendmail(email_admin, 'My App Notification', 'the parrot is dead.')\n", "sendmail(';'.join((email_admin, email_devteam)), 'My App Notification', 'the ministry is closed until further notice.')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We could simply our life a little using partials this way:"]}, {"cell_type": "code", "execution_count": 39, "metadata": {"collapsed": true}, "outputs": [], "source": ["send_admin = partial(sendmail, email_admin, 'For you eyes only')\n", "send_dev = partial(sendmail, email_devteam, 'Dear IT:')\n", "send_all = partial(sendmail, ';'.join((email_admin, email_devteam)), 'Loyal Subjects')"]}, {"cell_type": "code", "execution_count": 40, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["To:palin@python.edu, Subject:For you eyes only, Body:the parrot is dead.\n", "To:palin@python.edu;idle@python.edu;cleese@python.edu, Subject:Loyal Subjects, Body:the ministry is closed until further notice.\n"]}], "source": ["send_admin('the parrot is dead.')\n", "send_all('the ministry is closed until further notice.')"]}, {"cell_type": "markdown", "metadata": {"collapsed": true}, "source": ["Finally, let's make this a little more complex, with a mixture of positional and keyword-only arguments:"]}, {"cell_type": "code", "execution_count": 41, "metadata": {}, "outputs": [], "source": ["def sendmail(to, subject, body, *, cc=None, bcc=email_devteam):\n", "    # code to send email\n", "    print('To:{0}, Subject:{1}, Body:{2}, CC:{3}, BCC:{4}'.format(to, \n", "                                                                  subject, \n", "                                                                  body, \n", "                                                                  cc, \n", "                                                                  bcc))"]}, {"cell_type": "code", "execution_count": 42, "metadata": {"collapsed": true}, "outputs": [], "source": ["send_admin = partial(sendmail, email_admin, 'General Admin')\n", "send_admin_secret = partial(sendmail, email_admin, 'For your eyes only', cc=None, bcc=None)"]}, {"cell_type": "code", "execution_count": 43, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["To:palin@python.edu, Subject:General Admin, Body:and now for something completely different, CC:None, BCC:idle@python.edu;cleese@python.edu\n"]}], "source": ["send_admin('and now for something completely different')"]}, {"cell_type": "code", "execution_count": 44, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["To:palin@python.edu, Subject:For your eyes only, Body:the parrot is dead!, CC:None, BCC:None\n"]}], "source": ["send_admin_secret('the parrot is dead!')"]}, {"cell_type": "code", "execution_count": 45, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["To:palin@python.edu, Subject:For your eyes only, Body:the parrot is no more!, CC:None, BCC:idle@python.edu;cleese@python.edu\n"]}], "source": ["send_admin_secret('the parrot is no more!', bcc=email_devteam)"]}, {"cell_type": "code", "execution_count": 49, "metadata": {}, "outputs": [], "source": ["def pow(base, exponent):\n", "    return base ** exponent"]}, {"cell_type": "code", "execution_count": 52, "metadata": {}, "outputs": [], "source": ["cube = partial(pow, exponent=3)"]}, {"cell_type": "code", "execution_count": 53, "metadata": {}, "outputs": [{"data": {"text/plain": ["8"]}, "execution_count": 53, "metadata": {}, "output_type": "execute_result"}], "source": ["cube(2)"]}, {"cell_type": "code", "execution_count": 54, "metadata": {}, "outputs": [{"ename": "TypeError", "evalue": "pow() got multiple values for argument 'exponent'", "output_type": "error", "traceback": ["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[1;31mTypeError\u001b[0m                                 Traceback (most recent call last)", "\u001b[1;32m<ipython-input-54-725d549b8104>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[1;32m----> 1\u001b[1;33m \u001b[0mcube\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;36m2\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;36m4\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m", "\u001b[1;31mTypeError\u001b[0m: pow() got multiple values for argument 'exponent'"]}], "source": ["cube(2, 4)"]}, {"cell_type": "code", "execution_count": 55, "metadata": {}, "outputs": [{"data": {"text/plain": ["16"]}, "execution_count": 55, "metadata": {}, "output_type": "execute_result"}], "source": ["cube(2, exponent=4)"]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": []}, {"cell_type": "markdown", "metadata": {}, "source": ["### The **operator** Module"]}, {"cell_type": "code", "execution_count": 1, "metadata": {"collapsed": true}, "outputs": [], "source": ["import operator"]}, {"cell_type": "code", "execution_count": 2, "metadata": {}, "outputs": [{"data": {"text/plain": ["['__abs__',\n", " '__add__',\n", " '__all__',\n", " '__and__',\n", " '__builtins__',\n", " '__cached__',\n", " '__concat__',\n", " '__contains__',\n", " '__delitem__',\n", " '__doc__',\n", " '__eq__',\n", " '__file__',\n", " '__floordiv__',\n", " '__ge__',\n", " '__getitem__',\n", " '__gt__',\n", " '__iadd__',\n", " '__iand__',\n", " '__iconcat__',\n", " '__ifloordiv__',\n", " '__ilshift__',\n", " '__imatmul__',\n", " '__imod__',\n", " '__imul__',\n", " '__index__',\n", " '__inv__',\n", " '__invert__',\n", " '__ior__',\n", " '__ipow__',\n", " '__irshift__',\n", " '__isub__',\n", " '__itruediv__',\n", " '__ixor__',\n", " '__le__',\n", " '__loader__',\n", " '__lshift__',\n", " '__lt__',\n", " '__matmul__',\n", " '__mod__',\n", " '__mul__',\n", " '__name__',\n", " '__ne__',\n", " '__neg__',\n", " '__not__',\n", " '__or__',\n", " '__package__',\n", " '__pos__',\n", " '__pow__',\n", " '__rshift__',\n", " '__setitem__',\n", " '__spec__',\n", " '__sub__',\n", " '__truediv__',\n", " '__xor__',\n", " '_abs',\n", " 'abs',\n", " 'add',\n", " 'and_',\n", " 'attrgetter',\n", " 'concat',\n", " 'contains',\n", " 'countOf',\n", " 'delitem',\n", " 'eq',\n", " 'floordiv',\n", " 'ge',\n", " 'getitem',\n", " 'gt',\n", " 'iadd',\n", " 'iand',\n", " 'iconcat',\n", " 'ifloordiv',\n", " 'ilshift',\n", " 'imatmul',\n", " 'imod',\n", " 'imul',\n", " 'index',\n", " 'indexOf',\n", " 'inv',\n", " 'invert',\n", " 'ior',\n", " 'ipow',\n", " 'irshift',\n", " 'is_',\n", " 'is_not',\n", " 'isub',\n", " 'itemgetter',\n", " 'itruediv',\n", " 'ixor',\n", " 'le',\n", " 'length_hint',\n", " 'lshift',\n", " 'lt',\n", " 'matmul',\n", " 'methodcaller',\n", " 'mod',\n", " 'mul',\n", " 'ne',\n", " 'neg',\n", " 'not_',\n", " 'or_',\n", " 'pos',\n", " 'pow',\n", " 'rshift',\n", " 'setitem',\n", " 'sub',\n", " 'truediv',\n", " 'truth',\n", " 'xor']"]}, "execution_count": 2, "metadata": {}, "output_type": "execute_result"}], "source": ["dir(operator)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Arithmetic Operators"]}, {"cell_type": "markdown", "metadata": {}, "source": ["A variety of arithmetic operators are implemented."]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [{"data": {"text/plain": ["3"]}, "execution_count": 3, "metadata": {}, "output_type": "execute_result"}], "source": ["operator.add(1, 2)"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"data": {"text/plain": ["6"]}, "execution_count": 4, "metadata": {}, "output_type": "execute_result"}], "source": ["operator.mul(2, 3)"]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"data": {"text/plain": ["8"]}, "execution_count": 5, "metadata": {}, "output_type": "execute_result"}], "source": ["operator.pow(2, 3)"]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [{"data": {"text/plain": ["1"]}, "execution_count": 6, "metadata": {}, "output_type": "execute_result"}], "source": ["operator.mod(13, 2)"]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"data": {"text/plain": ["6"]}, "execution_count": 7, "metadata": {}, "output_type": "execute_result"}], "source": ["operator.floordiv(13, 2)"]}, {"cell_type": "code", "execution_count": 8, "metadata": {}, "outputs": [{"data": {"text/plain": ["1.5"]}, "execution_count": 8, "metadata": {}, "output_type": "execute_result"}], "source": ["operator.truediv(3, 2)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["These would have been very handy in our previous section:"]}, {"cell_type": "code", "execution_count": 9, "metadata": {"collapsed": true}, "outputs": [], "source": ["from functools import reduce"]}, {"cell_type": "code", "execution_count": 10, "metadata": {}, "outputs": [{"data": {"text/plain": ["24"]}, "execution_count": 10, "metadata": {}, "output_type": "execute_result"}], "source": ["reduce(lambda x, y: x*y, [1, 2, 3, 4])"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Instead of defining a lambda, we could simply use **operator.mul**:"]}, {"cell_type": "code", "execution_count": 11, "metadata": {}, "outputs": [{"data": {"text/plain": ["24"]}, "execution_count": 11, "metadata": {}, "output_type": "execute_result"}], "source": ["reduce(operator.mul, [1, 2, 3, 4])"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Comparison and Boolean Operators"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Comparison and Boolean operators are also implemented as functions:"]}, {"cell_type": "code", "execution_count": 12, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 12, "metadata": {}, "output_type": "execute_result"}], "source": ["operator.lt(10, 100)"]}, {"cell_type": "code", "execution_count": 13, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 13, "metadata": {}, "output_type": "execute_result"}], "source": ["operator.le(10, 10)"]}, {"cell_type": "code", "execution_count": 14, "metadata": {}, "outputs": [{"data": {"text/plain": ["False"]}, "execution_count": 14, "metadata": {}, "output_type": "execute_result"}], "source": ["operator.is_('abc', 'def')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can even get the truthyness of an object:"]}, {"cell_type": "code", "execution_count": 15, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 15, "metadata": {}, "output_type": "execute_result"}], "source": ["operator.truth([1,2])"]}, {"cell_type": "code", "execution_count": 16, "metadata": {}, "outputs": [{"data": {"text/plain": ["False"]}, "execution_count": 16, "metadata": {}, "output_type": "execute_result"}], "source": ["operator.truth([])"]}, {"cell_type": "code", "execution_count": 17, "metadata": {}, "outputs": [{"data": {"text/plain": ["False"]}, "execution_count": 17, "metadata": {}, "output_type": "execute_result"}], "source": ["operator.and_(True, False)"]}, {"cell_type": "code", "execution_count": 18, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 18, "metadata": {}, "output_type": "execute_result"}], "source": ["operator.or_(True, False)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Element and Attribute Getters and Setters"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We generally select an item by index from a sequence by using **[n]**:"]}, {"cell_type": "code", "execution_count": 19, "metadata": {}, "outputs": [{"data": {"text/plain": ["2"]}, "execution_count": 19, "metadata": {}, "output_type": "execute_result"}], "source": ["my_list = [1, 2, 3, 4]\n", "my_list[1]"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can do the same thing using:"]}, {"cell_type": "code", "execution_count": 20, "metadata": {}, "outputs": [{"data": {"text/plain": ["2"]}, "execution_count": 20, "metadata": {}, "output_type": "execute_result"}], "source": ["operator.getitem(my_list, 1)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["If the sequence is mutable, we can also set or remove items:"]}, {"cell_type": "code", "execution_count": 21, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["[1, 100, 3]\n"]}], "source": ["my_list = [1, 2, 3, 4]\n", "my_list[1] = 100\n", "del my_list[3]\n", "print(my_list)"]}, {"cell_type": "code", "execution_count": 22, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["[1, 100, 3]\n"]}], "source": ["my_list = [1, 2, 3, 4]\n", "operator.setitem(my_list, 1, 100)\n", "operator.delitem(my_list, 3)\n", "print(my_list)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can also do the same thing using the **operator** module's **itemgetter** function.\n", "\n", "The difference is that this returns a callable:"]}, {"cell_type": "code", "execution_count": 23, "metadata": {"collapsed": true}, "outputs": [], "source": ["f = operator.itemgetter(2)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now, **f(my_list)** will return **my_list[2]**"]}, {"cell_type": "code", "execution_count": 24, "metadata": {}, "outputs": [{"data": {"text/plain": ["3"]}, "execution_count": 24, "metadata": {}, "output_type": "execute_result"}], "source": ["f(my_list)"]}, {"cell_type": "code", "execution_count": 25, "metadata": {}, "outputs": [{"data": {"text/plain": ["'t'"]}, "execution_count": 25, "metadata": {}, "output_type": "execute_result"}], "source": ["x = 'python'\n", "f(x)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Furthermore, we can pass more than one index to **itemgetter**:"]}, {"cell_type": "code", "execution_count": 26, "metadata": {"collapsed": true}, "outputs": [], "source": ["f = operator.itemgetter(2, 3)"]}, {"cell_type": "code", "execution_count": 27, "metadata": {}, "outputs": [{"data": {"text/plain": ["(3, 4)"]}, "execution_count": 27, "metadata": {}, "output_type": "execute_result"}], "source": ["my_list = [1, 2, 3, 4]\n", "f(my_list)"]}, {"cell_type": "code", "execution_count": 28, "metadata": {}, "outputs": [{"data": {"text/plain": ["('t', 'y')"]}, "execution_count": 28, "metadata": {}, "output_type": "execute_result"}], "source": ["x = 'pytyhon'\n", "f(x)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Similarly, **operator.attrgetter** does the same thing, but with object attributes."]}, {"cell_type": "code", "execution_count": 29, "metadata": {"collapsed": true}, "outputs": [], "source": ["class MyClass:\n", "    def __init__(self):\n", "        self.a = 10\n", "        self.b = 20\n", "        self.c = 30\n", "        \n", "    def test(self):\n", "        print('test method running...')"]}, {"cell_type": "code", "execution_count": 30, "metadata": {"collapsed": true}, "outputs": [], "source": ["obj = MyClass()"]}, {"cell_type": "code", "execution_count": 31, "metadata": {}, "outputs": [{"data": {"text/plain": ["(10, 20, 30)"]}, "execution_count": 31, "metadata": {}, "output_type": "execute_result"}], "source": ["obj.a, obj.b, obj.c"]}, {"cell_type": "code", "execution_count": 32, "metadata": {"collapsed": true}, "outputs": [], "source": ["f = operator.attrgetter('a')"]}, {"cell_type": "code", "execution_count": 33, "metadata": {}, "outputs": [{"data": {"text/plain": ["10"]}, "execution_count": 33, "metadata": {}, "output_type": "execute_result"}], "source": ["f(obj)"]}, {"cell_type": "code", "execution_count": 34, "metadata": {}, "outputs": [{"data": {"text/plain": ["20"]}, "execution_count": 34, "metadata": {}, "output_type": "execute_result"}], "source": ["my_var = 'b'\n", "operator.attrgetter(my_var)(obj)"]}, {"cell_type": "code", "execution_count": 35, "metadata": {}, "outputs": [{"data": {"text/plain": ["30"]}, "execution_count": 35, "metadata": {}, "output_type": "execute_result"}], "source": ["my_var = 'c'\n", "operator.attrgetter(my_var)(obj)"]}, {"cell_type": "code", "execution_count": 36, "metadata": {"collapsed": true}, "outputs": [], "source": ["f = operator.attrgetter('a', 'b', 'c')"]}, {"cell_type": "code", "execution_count": 37, "metadata": {}, "outputs": [{"data": {"text/plain": ["(10, 20, 30)"]}, "execution_count": 37, "metadata": {}, "output_type": "execute_result"}], "source": ["f(obj)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Of course, attributes can also be methods.\n", "\n", "In this case, **attrgetter** will return the object's **test** method - a callable that can then be called using **()**:"]}, {"cell_type": "code", "execution_count": 38, "metadata": {"collapsed": true}, "outputs": [], "source": ["f = operator.attrgetter('test')"]}, {"cell_type": "code", "execution_count": 39, "metadata": {}, "outputs": [], "source": ["obj_test_method = f(obj)"]}, {"cell_type": "code", "execution_count": 40, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["test method running...\n"]}], "source": ["obj_test_method()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Just like lambdas, we do not need to assign them to a variable name in order to use them:"]}, {"cell_type": "code", "execution_count": 41, "metadata": {}, "outputs": [{"data": {"text/plain": ["(10, 20)"]}, "execution_count": 41, "metadata": {}, "output_type": "execute_result"}], "source": ["operator.attrgetter('a', 'b')(obj)"]}, {"cell_type": "code", "execution_count": 42, "metadata": {}, "outputs": [{"data": {"text/plain": ["('t', 'h')"]}, "execution_count": 42, "metadata": {}, "output_type": "execute_result"}], "source": ["operator.itemgetter(2, 3)('python')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Of course, we can achieve the same thing using functions or lambdas:"]}, {"cell_type": "code", "execution_count": 43, "metadata": {"collapsed": true}, "outputs": [], "source": ["f = lambda x: (x.a, x.b, x.c)"]}, {"cell_type": "code", "execution_count": 44, "metadata": {}, "outputs": [{"data": {"text/plain": ["(10, 20, 30)"]}, "execution_count": 44, "metadata": {}, "output_type": "execute_result"}], "source": ["f(obj)"]}, {"cell_type": "code", "execution_count": 45, "metadata": {"collapsed": true}, "outputs": [], "source": ["f = lambda x: (x[2], x[3])"]}, {"cell_type": "code", "execution_count": 46, "metadata": {}, "outputs": [{"data": {"text/plain": ["(3, 4)"]}, "execution_count": 46, "metadata": {}, "output_type": "execute_result"}], "source": ["f([1, 2, 3, 4])"]}, {"cell_type": "code", "execution_count": 47, "metadata": {}, "outputs": [{"data": {"text/plain": ["('t', 'h')"]}, "execution_count": 47, "metadata": {}, "output_type": "execute_result"}], "source": ["f('python')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["##### Use Case Example: Sorting"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Suppose we want to sort a list of complex numbers based on the real part of the numbers:"]}, {"cell_type": "code", "execution_count": 48, "metadata": {}, "outputs": [{"data": {"text/plain": ["2.0"]}, "execution_count": 48, "metadata": {}, "output_type": "execute_result"}], "source": ["a = 2 + 5j\n", "a.real"]}, {"cell_type": "code", "execution_count": 49, "metadata": {}, "outputs": [{"data": {"text/plain": ["[(5+3j), (8+2j), (10+1j)]"]}, "execution_count": 49, "metadata": {}, "output_type": "execute_result"}], "source": ["l = [10+1j, 8+2j, 5+3j]\n", "sorted(l, key=operator.attrgetter('real'))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Or if we want to sort a list of string based on the last character of the strings:"]}, {"cell_type": "code", "execution_count": 50, "metadata": {}, "outputs": [{"data": {"text/plain": ["['aaa', 'aac', 'aad', 'aaz']"]}, "execution_count": 50, "metadata": {}, "output_type": "execute_result"}], "source": ["l = ['aaz', 'aad', 'aaa', 'aac']\n", "sorted(l, key=operator.itemgetter(-1))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Or maybe we want to sort a list of tuples based on the first item of each tuple:"]}, {"cell_type": "code", "execution_count": 51, "metadata": {}, "outputs": [{"data": {"text/plain": ["[(1, 2, 3), (2, 3, 4), (3, 4), (4,)]"]}, "execution_count": 51, "metadata": {}, "output_type": "execute_result"}], "source": ["l = [(2, 3, 4), (1, 2, 3), (4, ), (3, 4)]\n", "sorted(l, key=operator.itemgetter(0))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Slicing"]}, {"cell_type": "code", "execution_count": 52, "metadata": {"collapsed": true}, "outputs": [], "source": ["l = [1, 2, 3, 4]"]}, {"cell_type": "code", "execution_count": 53, "metadata": {}, "outputs": [{"data": {"text/plain": ["[1, 2]"]}, "execution_count": 53, "metadata": {}, "output_type": "execute_result"}], "source": ["l[0:2]"]}, {"cell_type": "code", "execution_count": 54, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["['a', 'b', 'c', 3, 4]\n"]}], "source": ["l[0:2] = ['a', 'b', 'c']\n", "print(l)"]}, {"cell_type": "code", "execution_count": 55, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["['a', 'b', 'c']\n"]}], "source": ["del l[3:5]\n", "print(l)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can do the same thing this way:"]}, {"cell_type": "code", "execution_count": 56, "metadata": {"collapsed": true}, "outputs": [], "source": ["l = [1, 2, 3, 4]"]}, {"cell_type": "code", "execution_count": 57, "metadata": {}, "outputs": [{"data": {"text/plain": ["[1, 2]"]}, "execution_count": 57, "metadata": {}, "output_type": "execute_result"}], "source": ["operator.getitem(l, slice(0,2))"]}, {"cell_type": "code", "execution_count": 58, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["['a', 'b', 'c', 3, 4]\n"]}], "source": ["operator.setitem(l, slice(0,2), ['a', 'b', 'c'])\n", "print(l)"]}, {"cell_type": "code", "execution_count": 59, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["['a', 'b', 'c']\n"]}], "source": ["operator.delitem(l, slice(3, 5))\n", "print(l)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Calling another Callable"]}, {"cell_type": "code", "execution_count": 60, "metadata": {}, "outputs": [{"data": {"text/plain": ["'PYTHON'"]}, "execution_count": 60, "metadata": {}, "output_type": "execute_result"}], "source": ["x = 'python'\n", "x.upper()"]}, {"cell_type": "code", "execution_count": 61, "metadata": {}, "outputs": [{"data": {"text/plain": ["'PYTHON'"]}, "execution_count": 61, "metadata": {}, "output_type": "execute_result"}], "source": ["operator.methodcaller('upper')('python')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Of course, since **upper** is just an attribute of the string object **x**, we could also have used:"]}, {"cell_type": "code", "execution_count": 62, "metadata": {}, "outputs": [{"data": {"text/plain": ["'PYTHON'"]}, "execution_count": 62, "metadata": {}, "output_type": "execute_result"}], "source": ["operator.attrgetter('upper')(x)()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["If the callable takes in more than one parameter, they can be specified as additional arguments in **methodcaller**:"]}, {"cell_type": "code", "execution_count": 63, "metadata": {"collapsed": true}, "outputs": [], "source": ["class MyClass:\n", "    def __init__(self):\n", "        self.a = 10\n", "        self.b = 20\n", "    \n", "    def do_something(self, c):\n", "        print(self.a, self.b, c)"]}, {"cell_type": "code", "execution_count": 64, "metadata": {"collapsed": true}, "outputs": [], "source": ["obj = MyClass()"]}, {"cell_type": "code", "execution_count": 65, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["10 20 100\n"]}], "source": ["obj.do_something(100)"]}, {"cell_type": "code", "execution_count": 66, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["10 20 100\n"]}], "source": ["operator.methodcaller('do_something', 100)(obj)"]}, {"cell_type": "code", "execution_count": 67, "metadata": {"collapsed": true}, "outputs": [], "source": ["class MyClass:\n", "    def __init__(self):\n", "        self.a = 10\n", "        self.b = 20\n", "    \n", "    def do_something(self, *, c):\n", "        print(self.a, self.b, c)"]}, {"cell_type": "code", "execution_count": 68, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["10 20 100\n"]}], "source": ["obj.do_something(c=100)"]}, {"cell_type": "code", "execution_count": 69, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["10 20 100\n"]}], "source": ["operator.methodcaller('do_something', c=100)(obj)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["More information on the **operator** module can be found here:\n", "\n", "https://docs.python.org/3/library/operator.html"]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Global and Local Scopes"]}, {"cell_type": "markdown", "metadata": {}, "source": ["In Python the **global** scope refers to the **module** scope.\n", "\n", "The scope of a variable is normally defined by **where** it is (lexically) defined in the code."]}, {"cell_type": "code", "execution_count": 1, "metadata": {"collapsed": true}, "outputs": [], "source": ["a = 10"]}, {"cell_type": "markdown", "metadata": {}, "source": ["In this case, **a** is defined inside the main module, so it is a global variable."]}, {"cell_type": "code", "execution_count": 2, "metadata": {"collapsed": true}, "outputs": [], "source": ["def my_func(n):\n", "    c = n ** 2\n", "    return c"]}, {"cell_type": "markdown", "metadata": {}, "source": ["In this case, **c** was defined inside the function **my_func**, so it is **local** to the function **my_func**. In this example, **n** is also **local** to **my_func**"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Global variables can be accessed from any inner scope in the module, for example:"]}, {"cell_type": "code", "execution_count": 3, "metadata": {"collapsed": true}, "outputs": [], "source": ["def my_func(n):\n", "    print('global:', a)\n", "    c = a ** n\n", "    return c"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["global: 10\n"]}, {"data": {"text/plain": ["100"]}, "execution_count": 4, "metadata": {}, "output_type": "execute_result"}], "source": ["my_func(2)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see, **my_func** was able to reference the global variable **a**."]}, {"cell_type": "markdown", "metadata": {}, "source": ["But remember that the scope of a variable is determined by where it is assigned. In particular, any variable defined (i.e. assigned a value) inside a function is local to that function, even if the variable name happens to be global too!"]}, {"cell_type": "code", "execution_count": 5, "metadata": {"collapsed": true}, "outputs": [], "source": ["def my_func(n):\n", "    a = 2\n", "    c = a ** 2\n", "    return c"]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["10\n", "4\n", "10\n"]}], "source": ["print(a)\n", "print(my_func(3))\n", "print(a)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["In order to change the value of a global variable within an inner scope, we can use the **global** keyword as follows:"]}, {"cell_type": "code", "execution_count": 7, "metadata": {"collapsed": true}, "outputs": [], "source": ["def my_func(n):\n", "    global a\n", "    a = 2\n", "    c = a ** 2\n", "    return c"]}, {"cell_type": "code", "execution_count": 8, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["10\n", "4\n", "2\n"]}], "source": ["print(a)\n", "print(my_func(3))\n", "print(a)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see, the value of the global variable **a** was changed from within **my_func**."]}, {"cell_type": "markdown", "metadata": {}, "source": ["In fact, we can **create** global variables from within an inner function - Python will simply create the variable and place it in the **global** scope instead of the **local scope**:"]}, {"cell_type": "code", "execution_count": 9, "metadata": {"collapsed": true}, "outputs": [], "source": ["def my_func(n):\n", "    global var\n", "    var = 'hello world'\n", "    return n ** 2"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now, **var** does not exist yet, since the function has not run:"]}, {"cell_type": "code", "execution_count": 10, "metadata": {}, "outputs": [{"ename": "NameError", "evalue": "name 'var' is not defined", "output_type": "error", "traceback": ["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[1;31mNameError\u001b[0m                                 Traceback (most recent call last)", "\u001b[1;32m<ipython-input-10-571cba235a7f>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[1;32m----> 1\u001b[1;33m \u001b[0mprint\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mvar\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m", "\u001b[1;31mNameError\u001b[0m: name 'var' is not defined"]}], "source": ["print(var)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Once we call the function though, it will create that global **var**:"]}, {"cell_type": "code", "execution_count": 11, "metadata": {}, "outputs": [{"data": {"text/plain": ["4"]}, "execution_count": 11, "metadata": {}, "output_type": "execute_result"}], "source": ["my_func(2)"]}, {"cell_type": "code", "execution_count": 12, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["hello world\n"]}], "source": ["print(var)"]}, {"cell_type": "markdown", "metadata": {"collapsed": true}, "source": ["#### Beware!!"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Remember that whenever you assign a value to a variable without having specified the variable as **global**, it is **local** in the current scope. **Moreover**, it does not matter **where** the assignment in the code takes place, the variable is considered local in the **entire** scope - Python determines the scope of objects at compile-time, not at run-time."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's see an example of this:"]}, {"cell_type": "code", "execution_count": 13, "metadata": {"collapsed": true}, "outputs": [], "source": ["a = 10\n", "b = 100"]}, {"cell_type": "code", "execution_count": 14, "metadata": {"collapsed": true}, "outputs": [], "source": ["def my_func():\n", "    print(a)\n", "    print(b)\n", "    "]}, {"cell_type": "code", "execution_count": 15, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["10\n", "100\n"]}], "source": ["my_func()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["So, this works as expected - **a** and **b** are taken from the global scope since they are referenced **before** being assigned a value in the local scope.\n", "\n", "But now consider the following example:"]}, {"cell_type": "code", "execution_count": 16, "metadata": {"collapsed": true}, "outputs": [], "source": ["a = 10\n", "b = 100\n", "\n", "def my_func():\n", "    print(a)\n", "    print(b)\n", "    b = 1000"]}, {"cell_type": "code", "execution_count": 17, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["10\n"]}, {"ename": "UnboundLocalError", "evalue": "local variable 'b' referenced before assignment", "output_type": "error", "traceback": ["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[1;31mUnboundLocalError\u001b[0m                         Traceback (most recent call last)", "\u001b[1;32m<ipython-input-17-d82eda95de40>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[1;32m----> 1\u001b[1;33m \u001b[0mmy_func\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m", "\u001b[1;32m<ipython-input-16-a2b60f95cac1>\u001b[0m in \u001b[0;36mmy_func\u001b[1;34m()\u001b[0m\n\u001b[0;32m      4\u001b[0m \u001b[1;32mdef\u001b[0m \u001b[0mmy_func\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m      5\u001b[0m     \u001b[0mprint\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0ma\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m----> 6\u001b[1;33m     \u001b[0mprint\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mb\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m      7\u001b[0m     \u001b[0mb\u001b[0m \u001b[1;33m=\u001b[0m \u001b[1;36m1000\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n", "\u001b[1;31mUnboundLocalError\u001b[0m: local variable 'b' referenced before assignment"]}], "source": ["my_func()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see, **b** in the line ``print(b)`` is considered a **local** variable - that's because the **next** line **assigns** a value to **b** - hence **b** is scoped as local by Python for the **entire** function."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Of course, functions are also objects, and scoping applies equally to function objects too. For example, we can \"mask\" the built-in `print` Python function:"]}, {"cell_type": "code", "execution_count": 18, "metadata": {"scrolled": false}, "outputs": [{"data": {"text/plain": ["'hello world!'"]}, "execution_count": 18, "metadata": {}, "output_type": "execute_result"}], "source": ["print = lambda x: 'hello {0}!'.format(x)\n", "\n", "def my_func(name):\n", "\treturn print(name)\n", "\n", "my_func('world')\n"]}, {"cell_type": "markdown", "metadata": {}, "source": ["You may be wondering how we get our **real** ``print`` function back!"]}, {"cell_type": "code", "execution_count": 19, "metadata": {"collapsed": true}, "outputs": [], "source": ["del print"]}, {"cell_type": "code", "execution_count": 20, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["hello\n"]}], "source": ["print('hello')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Yay!!"]}, {"cell_type": "markdown", "metadata": {"collapsed": true}, "source": ["If you have experience in some other programming languages you may be wondering if loops and other code \"blocks\" have their own local scope too. For example in Java, the following would not work:"]}, {"cell_type": "markdown", "metadata": {}, "source": ["``for (int i=0; i<10; i++) {\n", "    int x = 2 * i;\n", "}\n", "system.out.println(x);\n", "``"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But in Python it works perfectly fine:"]}, {"cell_type": "code", "execution_count": 21, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["18\n"]}], "source": ["for i in range(10):\n", "    x = 2 * i\n", "print(x)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["In this case, when we assigned a value to `x`, Python put it in the global (module) scope, so we can reference it after the `for` loop has finished running."]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Nonlocal Scopes"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Functions defined inside anther function can reference variables from that enclosing scope, just like functions can reference variables from the global scope."]}, {"cell_type": "code", "execution_count": 1, "metadata": {"collapsed": true}, "outputs": [], "source": ["def outer_func():\n", "    x = 'hello'\n", "    \n", "    def inner_func():\n", "        print(x)\n", "    \n", "    inner_func()"]}, {"cell_type": "code", "execution_count": 2, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["hello\n"]}], "source": ["outer_func()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["In fact, any level of nesting is supported since Python just keeps looking in enclosing scopes until it finds what it needs (or fails to find it by the time it finishes looking in the built-in scope, in which case a runtime error occurrs.)"]}, {"cell_type": "code", "execution_count": 3, "metadata": {"collapsed": true}, "outputs": [], "source": ["def outer_func():\n", "    x = 'hello'\n", "    def inner1():\n", "        def inner2():\n", "            print(x)\n", "        inner2()\n", "    inner1()"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["hello\n"]}], "source": ["outer_func()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But if we **assign** a value to a variable, it is considered part of the local scope, and potentially **masks** enclsogin scope variable names:"]}, {"cell_type": "code", "execution_count": 5, "metadata": {"collapsed": true}, "outputs": [], "source": ["def outer():\n", "    x = 'hello'\n", "    def inner():\n", "        x = 'python'\n", "    inner()\n", "    print(x)"]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["hello\n"]}], "source": ["outer()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see, **x** in **outer** was not changed."]}, {"cell_type": "markdown", "metadata": {}, "source": ["To achieve this, we can use the **nonlocal** keyword:"]}, {"cell_type": "code", "execution_count": 7, "metadata": {"collapsed": true}, "outputs": [], "source": ["def outer():\n", "    x = 'hello'\n", "    def inner():\n", "        nonlocal x\n", "        x = 'python'\n", "    inner()\n", "    print(x)"]}, {"cell_type": "code", "execution_count": 8, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["python\n"]}], "source": ["outer()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Of course, this can work at any level as well:"]}, {"cell_type": "code", "execution_count": 9, "metadata": {"collapsed": true}, "outputs": [], "source": ["def outer():\n", "    x = 'hello'\n", "    \n", "    def inner1():\n", "        def inner2():\n", "            nonlocal x\n", "            x = 'python'\n", "        inner2()\n", "    inner1()\n", "    print(x)"]}, {"cell_type": "code", "execution_count": 10, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["python\n"]}], "source": ["outer()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["How far Python looks up the chain depends on the first occurrence of the variable name in an enclosing scope.\n", "\n", "Consider the following example:"]}, {"cell_type": "code", "execution_count": 11, "metadata": {"collapsed": true}, "outputs": [], "source": ["def outer():\n", "    x = 'hello'\n", "    def inner1():\n", "        x = 'python'\n", "        def inner2():\n", "            nonlocal x\n", "            x = 'monty'\n", "        print('inner1 (before):', x)\n", "        inner2()\n", "        print('inner1 (after):', x)\n", "    inner1()\n", "    print('outer:', x)"]}, {"cell_type": "code", "execution_count": 12, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["inner1 (before): python\n", "inner1 (after): monty\n", "outer: hello\n"]}], "source": ["outer()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["What happened here, is that `x` in `inner1` **masked** `x` in `outer`. But `inner2` indicated to Python that `x` was nonlocal, so the first local variable up in the enclosing scope chain Python found was the one in `inner1`, hence `x` in `inner2` is actually referencing `x` that is local to `inner1`"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can change this behavior by making the variable `x` in `inner` nonlocal as well:"]}, {"cell_type": "code", "execution_count": 13, "metadata": {"collapsed": true}, "outputs": [], "source": ["def outer():\n", "    x = 'hello'\n", "    def inner1():\n", "        nonlocal x\n", "        x = 'python'\n", "        def inner2():\n", "            nonlocal x\n", "            x = 'monty'\n", "        print('inner1 (before):', x)\n", "        inner2()\n", "        print('inner1 (after):', x)\n", "    inner1()\n", "    print('outer:', x)"]}, {"cell_type": "code", "execution_count": 14, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["inner1 (before): python\n", "inner1 (after): monty\n", "outer: monty\n"]}], "source": ["outer()"]}, {"cell_type": "code", "execution_count": 15, "metadata": {"collapsed": true}, "outputs": [], "source": ["x = 100\n", "def outer():\n", "    x = 'python'  # masks global x\n", "    def inner1():\n", "        nonlocal x  # refers to x in outer\n", "        x = 'monty' # changed x in outer scope\n", "        def inner2():\n", "            global x  # refers to x in global scope\n", "            x = 'hello'\n", "        print('inner1 (before):', x)\n", "        inner2()\n", "        print('inner1 (after):', x)\n", "    inner1()\n", "    print('outer', x)    "]}, {"cell_type": "code", "execution_count": 16, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["inner1 (after): monty\n", "outer monty\n", "100\n"]}], "source": ["outer()\n", "print(x)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But this will not work. In `inner` Python is looking for a local variable called `x`. `outer` has a label called `x`, but it is a global variable, not a local one - hence Python does not find a local variable in the scope chain."]}, {"cell_type": "code", "execution_count": 17, "metadata": {}, "outputs": [{"ename": "SyntaxError", "evalue": "no binding for nonlocal 'x' found (<ipython-input-17-3ccaec905318>, line 7)", "output_type": "error", "traceback": ["\u001b[1;36m  File \u001b[1;32m\"<ipython-input-17-3ccaec905318>\"\u001b[1;36m, line \u001b[1;32m7\u001b[0m\n\u001b[1;33m    nonlocal x\u001b[0m\n\u001b[1;37m    ^\u001b[0m\n\u001b[1;31mSyntaxError\u001b[0m\u001b[1;31m:\u001b[0m no binding for nonlocal 'x' found\n"]}], "source": ["x = 100\n", "def outer():\n", "    global x\n", "    x = 'python'\n", "    \n", "    def inner():\n", "        nonlocal x\n", "        x = 'monty'\n", "    inner()"]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": []}, {"cell_type": "markdown", "metadata": {}, "source": ["### Closures"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's examine that concept of a cell to create an indirect reference for variables that are in multiple scopes."]}, {"cell_type": "code", "execution_count": 1, "metadata": {"collapsed": true}, "outputs": [], "source": ["def outer():\n", "    x = 'python'\n", "    def inner():\n", "        print(x)\n", "    return inner"]}, {"cell_type": "code", "execution_count": 2, "metadata": {"collapsed": true}, "outputs": [], "source": ["fn = outer()"]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [{"data": {"text/plain": ["('x',)"]}, "execution_count": 3, "metadata": {}, "output_type": "execute_result"}], "source": ["fn.__code__.co_freevars"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As we can see, `x` is a free variable in the closure."]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"data": {"text/plain": ["(<cell at 0x0000015F5299B4C8: str object at 0x0000015F51092068>,)"]}, "execution_count": 4, "metadata": {}, "output_type": "execute_result"}], "source": ["fn.__closure__"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Here we see that the free variable x is actually a reference to a cell object that is itself a reference to a string object."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's see what the memory address of `x` is in the outer function and the inner function. To be sure string interning does not play a role, I am going to use an object that we know Python will not automatically intern, like a list."]}, {"cell_type": "code", "execution_count": 5, "metadata": {"collapsed": true}, "outputs": [], "source": ["def outer():\n", "    x = [1, 2, 3]\n", "    print('outer:', hex(id(x)))\n", "    def inner():\n", "        print('inner:', hex(id(x)))\n", "        print(x)\n", "    return inner"]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["outer: 0x15f52907988\n"]}], "source": ["fn = outer()"]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"data": {"text/plain": ["(<cell at 0x0000015F5299B768: list object at 0x0000015F52907988>,)"]}, "execution_count": 7, "metadata": {}, "output_type": "execute_result"}], "source": ["fn.__closure__"]}, {"cell_type": "code", "execution_count": 8, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["inner: 0x15f52907988\n", "[1, 2, 3]\n"]}], "source": ["fn()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see, each the memory address of `x` in `outer`, `inner` and the cell all point to the same object."]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Modifying the Free Variable"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We know we can modify nonlocal variables by using the `nonlocal` keyword. So the following will work:"]}, {"cell_type": "code", "execution_count": 9, "metadata": {"collapsed": true}, "outputs": [], "source": ["def counter():\n", "    count = 0 # local variable\n", "    \n", "    def inc():\n", "        nonlocal count  # this is the count variable in counter\n", "        count += 1\n", "        return count\n", "    return inc"]}, {"cell_type": "code", "execution_count": 10, "metadata": {"collapsed": true}, "outputs": [], "source": ["c = counter()"]}, {"cell_type": "code", "execution_count": 11, "metadata": {}, "outputs": [{"data": {"text/plain": ["1"]}, "execution_count": 11, "metadata": {}, "output_type": "execute_result"}], "source": ["c()"]}, {"cell_type": "code", "execution_count": 12, "metadata": {}, "outputs": [{"data": {"text/plain": ["2"]}, "execution_count": 12, "metadata": {}, "output_type": "execute_result"}], "source": ["c()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["##### Shared Extended Scopes"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As we saw in the lecture, we can set up nonlocal variables in different inner functionsd that reference the same outer scope variable, i.e. we have a free variable that is shared between two closures. This works because both non local variables and the outer local variable all point back to the same cell object."]}, {"cell_type": "code", "execution_count": 13, "metadata": {"collapsed": true}, "outputs": [], "source": ["def outer():\n", "    count = 0\n", "    def inc1():\n", "        nonlocal count\n", "        count += 1\n", "        return count\n", "    \n", "    def inc2():\n", "        nonlocal count\n", "        count += 1\n", "        return count\n", "    \n", "    return inc1, inc2"]}, {"cell_type": "code", "execution_count": 14, "metadata": {}, "outputs": [], "source": ["fn1, fn2 = outer()"]}, {"cell_type": "code", "execution_count": 15, "metadata": {}, "outputs": [{"data": {"text/plain": ["((<cell at 0x0000015F5299B738: int object at 0x00000000506FEC50>,),\n", " (<cell at 0x0000015F5299B738: int object at 0x00000000506FEC50>,))"]}, "execution_count": 15, "metadata": {}, "output_type": "execute_result"}], "source": ["fn1.__closure__, fn2.__closure__"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see here, the `count` label points to the same cell."]}, {"cell_type": "code", "execution_count": 16, "metadata": {}, "outputs": [{"data": {"text/plain": ["1"]}, "execution_count": 16, "metadata": {}, "output_type": "execute_result"}], "source": ["fn1()"]}, {"cell_type": "code", "execution_count": 17, "metadata": {}, "outputs": [{"data": {"text/plain": ["2"]}, "execution_count": 17, "metadata": {}, "output_type": "execute_result"}], "source": ["fn1()"]}, {"cell_type": "code", "execution_count": 18, "metadata": {}, "outputs": [{"data": {"text/plain": ["3"]}, "execution_count": 18, "metadata": {}, "output_type": "execute_result"}], "source": ["fn2()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Multiple Instances of Closures"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Recall that **every** time a function is called, a **new** local scope is created."]}, {"cell_type": "code", "execution_count": 19, "metadata": {"collapsed": true}, "outputs": [], "source": ["from time import perf_counter\n", "\n", "def func():\n", "    x = perf_counter()\n", "    print(x, id(x))"]}, {"cell_type": "code", "execution_count": 20, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["2.7089464582150425e-07 1508916709680\n"]}], "source": ["func()"]}, {"cell_type": "code", "execution_count": 21, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["0.011222623387093279 1508916709680\n"]}], "source": ["func()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The same thing happens with closures, they have their own extended scope every time the closure is created:"]}, {"cell_type": "code", "execution_count": 22, "metadata": {"collapsed": true}, "outputs": [], "source": ["def pow(n):\n", "    # n is local to pow\n", "    def inner(x):\n", "        # x is local to inner\n", "        return x ** n\n", "    return inner"]}, {"cell_type": "markdown", "metadata": {}, "source": ["In this example, `n`, in the function `inner` is a free variable, so we have a closure that contains `inner` and the free variable `n`"]}, {"cell_type": "code", "execution_count": 23, "metadata": {"collapsed": true}, "outputs": [], "source": ["square = pow(2)"]}, {"cell_type": "code", "execution_count": 24, "metadata": {}, "outputs": [{"data": {"text/plain": ["25"]}, "execution_count": 24, "metadata": {}, "output_type": "execute_result"}], "source": ["square(5)"]}, {"cell_type": "code", "execution_count": 25, "metadata": {"collapsed": true}, "outputs": [], "source": ["cube = pow(3)"]}, {"cell_type": "code", "execution_count": 26, "metadata": {}, "outputs": [{"data": {"text/plain": ["125"]}, "execution_count": 26, "metadata": {}, "output_type": "execute_result"}], "source": ["cube(5)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can see that the cell used for the free variable in both cases is **different**:"]}, {"cell_type": "code", "execution_count": 27, "metadata": {}, "outputs": [{"data": {"text/plain": ["(<cell at 0x0000015F5299B8B8: int object at 0x00000000506FEC90>,)"]}, "execution_count": 27, "metadata": {}, "output_type": "execute_result"}], "source": ["square.__closure__"]}, {"cell_type": "code", "execution_count": 28, "metadata": {}, "outputs": [{"data": {"text/plain": ["(<cell at 0x0000015F5299BAC8: int object at 0x00000000506FECB0>,)"]}, "execution_count": 28, "metadata": {}, "output_type": "execute_result"}], "source": ["cube.__closure__"]}, {"cell_type": "markdown", "metadata": {}, "source": ["In fact, these functions (`square` and `cube`) are **not** the same functions, even though they were \"created\" from the same `power` function:"]}, {"cell_type": "code", "execution_count": 29, "metadata": {}, "outputs": [{"data": {"text/plain": ["(1508919294560, 1508919295784)"]}, "execution_count": 29, "metadata": {}, "output_type": "execute_result"}], "source": ["id(square), id(cube)"]}, {"cell_type": "markdown", "metadata": {"collapsed": true}, "source": ["### Beware!"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Remember when I said the captured variable is a reference established when the closure is created, but the value is looked up only once the function is called?"]}, {"cell_type": "markdown", "metadata": {}, "source": ["This can create very subtle bugs in your program."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Consider the following example where we want to create some functions that can add 1, 2, 3, 4 and to whatever is passed to them."]}, {"cell_type": "markdown", "metadata": {}, "source": ["We could do the following:"]}, {"cell_type": "code", "execution_count": 30, "metadata": {"collapsed": true}, "outputs": [], "source": ["def adder(n):\n", "    def inner(x):\n", "        return x + n\n", "    return inner"]}, {"cell_type": "code", "execution_count": 31, "metadata": {"collapsed": true}, "outputs": [], "source": ["add_1 = adder(1)\n", "add_2 = adder(2)\n", "add_3 = adder(3)\n", "add_4 = adder(4)"]}, {"cell_type": "code", "execution_count": 32, "metadata": {}, "outputs": [{"data": {"text/plain": ["(11, 12, 13, 14)"]}, "execution_count": 32, "metadata": {}, "output_type": "execute_result"}], "source": ["add_1(10), add_2(10), add_3(10), add_4(10)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But suppose we want to get a little fancier and do it as follows:"]}, {"cell_type": "code", "execution_count": 33, "metadata": {"collapsed": true}, "outputs": [], "source": ["def create_adders():\n", "    adders = []\n", "    for n in range(1, 5):\n", "        adders.append(lambda x: x + n)\n", "    return adders"]}, {"cell_type": "code", "execution_count": 34, "metadata": {"collapsed": true}, "outputs": [], "source": ["adders = create_adders()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now technically we have 4 functions in the `adders` list:"]}, {"cell_type": "code", "execution_count": 35, "metadata": {}, "outputs": [{"data": {"text/plain": ["[<function __main__.create_adders.<locals>.<lambda>>,\n", " <function __main__.create_adders.<locals>.<lambda>>,\n", " <function __main__.create_adders.<locals>.<lambda>>,\n", " <function __main__.create_adders.<locals>.<lambda>>]"]}, "execution_count": 35, "metadata": {}, "output_type": "execute_result"}], "source": ["adders"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The first one should add 1 to the value we pass it, the second should add 2, and so on."]}, {"cell_type": "code", "execution_count": 36, "metadata": {}, "outputs": [{"data": {"text/plain": ["14"]}, "execution_count": 36, "metadata": {}, "output_type": "execute_result"}], "source": ["adders[3](10)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Yep, that works for the 4th function."]}, {"cell_type": "code", "execution_count": 37, "metadata": {}, "outputs": [{"data": {"text/plain": ["14"]}, "execution_count": 37, "metadata": {}, "output_type": "execute_result"}], "source": ["adders[0](10)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Uh Oh - what happened? In fact we get the same behavior from every one of those functions:"]}, {"cell_type": "code", "execution_count": 38, "metadata": {}, "outputs": [{"data": {"text/plain": ["(14, 14, 14, 14)"]}, "execution_count": 38, "metadata": {}, "output_type": "execute_result"}], "source": ["adders[0](10), adders[1](10), adders[2](10), adders[3](10)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Remember what I said about when the variable is captured and when the value is looked up?"]}, {"cell_type": "markdown", "metadata": {}, "source": ["When the lambdas are **created** their `n` is the `n` used in the loop - the **same** `n`!!"]}, {"cell_type": "code", "execution_count": 39, "metadata": {}, "outputs": [{"data": {"text/plain": ["('n',)"]}, "execution_count": 39, "metadata": {}, "output_type": "execute_result"}], "source": ["adders[0].__code__.co_freevars"]}, {"cell_type": "code", "execution_count": 40, "metadata": {}, "outputs": [{"data": {"text/plain": ["(<cell at 0x0000015F5299B3D8: int object at 0x00000000506FECD0>,)"]}, "execution_count": 40, "metadata": {}, "output_type": "execute_result"}], "source": ["adders[0].__closure__"]}, {"cell_type": "code", "execution_count": 41, "metadata": {}, "outputs": [{"data": {"text/plain": ["(<cell at 0x0000015F5299B3D8: int object at 0x00000000506FECD0>,)"]}, "execution_count": 41, "metadata": {}, "output_type": "execute_result"}], "source": ["adders[1].__closure__"]}, {"cell_type": "code", "execution_count": 42, "metadata": {}, "outputs": [{"data": {"text/plain": ["(<cell at 0x0000015F5299B3D8: int object at 0x00000000506FECD0>,)"]}, "execution_count": 42, "metadata": {}, "output_type": "execute_result"}], "source": ["adders[2].__closure__"]}, {"cell_type": "code", "execution_count": 43, "metadata": {}, "outputs": [{"data": {"text/plain": ["(<cell at 0x0000015F5299B3D8: int object at 0x00000000506FECD0>,)"]}, "execution_count": 43, "metadata": {}, "output_type": "execute_result"}], "source": ["adders[3].__closure__"]}, {"cell_type": "markdown", "metadata": {}, "source": ["So, by the time we call `adder[i]`, the free variable `n` (shared between all adders) is set to 4."]}, {"cell_type": "code", "execution_count": 44, "metadata": {}, "outputs": [{"data": {"text/plain": ["'0x506fecd0'"]}, "execution_count": 44, "metadata": {}, "output_type": "execute_result"}], "source": ["hex(id(4))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As we can see the memory address of the singleton integer 4, is what that cell is pointint to."]}, {"cell_type": "markdown", "metadata": {}, "source": ["If you want to use a loop to do this and not end up using the same cell for each of the free variables, we can use a simple trick that forces the evaluation of `n` at the time the closure is **created**, instead of when the closure function is evaluated.\n", "\n", "We can do this by creating a parameter for `n` in our lambda whose default value is the current value of `n` - remember from an earlier video that parameter defaults are avaluated when the function is created, not called."]}, {"cell_type": "code", "execution_count": 45, "metadata": {"collapsed": true}, "outputs": [], "source": ["def create_adders():\n", "    adders = []\n", "    for n in range(1, 5):\n", "        adders.append(lambda x, step=n: x + step)\n", "    return adders"]}, {"cell_type": "code", "execution_count": 46, "metadata": {"collapsed": true}, "outputs": [], "source": ["adders = create_adders()"]}, {"cell_type": "code", "execution_count": 47, "metadata": {"collapsed": true}, "outputs": [], "source": ["adders[0].__closure__"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Why aren't we getting anything in the closure? What about free variables?"]}, {"cell_type": "code", "execution_count": 48, "metadata": {}, "outputs": [{"data": {"text/plain": ["()"]}, "execution_count": 48, "metadata": {}, "output_type": "execute_result"}], "source": ["adders[0].__code__.co_freevars"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Hmm, nothing either... Why?\n", "\n", "Well, look at the lambda in that loop. Does it reference the variable `n` (other than in the default value)? No. Hence, `n` is **not** a free variable in this case, and our lambda is just a plain lambda, not a closure."]}, {"cell_type": "markdown", "metadata": {}, "source": ["And this code will now work as expected:"]}, {"cell_type": "code", "execution_count": 49, "metadata": {}, "outputs": [{"data": {"text/plain": ["11"]}, "execution_count": 49, "metadata": {}, "output_type": "execute_result"}], "source": ["adders[0](10)"]}, {"cell_type": "code", "execution_count": 50, "metadata": {}, "outputs": [{"data": {"text/plain": ["12"]}, "execution_count": 50, "metadata": {}, "output_type": "execute_result"}], "source": ["adders[1](10)"]}, {"cell_type": "code", "execution_count": 51, "metadata": {}, "outputs": [{"data": {"text/plain": ["13"]}, "execution_count": 51, "metadata": {}, "output_type": "execute_result"}], "source": ["adders[2](10)"]}, {"cell_type": "code", "execution_count": 52, "metadata": {}, "outputs": [{"data": {"text/plain": ["14"]}, "execution_count": 52, "metadata": {}, "output_type": "execute_result"}], "source": ["adders[3](10)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["You just need to understand that since the default values are evaluated when the function (lambda in this case) is **created**, the then-current `n` value is assigned to the local variable `step`. So `step` will not change every time the lambda is called, and since n is not referenced inside the function (and therefore evaluated when the lambda is called), `n` is not a free variable."]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Nested Closures"]}, {"cell_type": "markdown", "metadata": {"collapsed": true}, "source": ["We can also nest closures, as can be seen in this example:"]}, {"cell_type": "code", "execution_count": 53, "metadata": {"collapsed": true}, "outputs": [], "source": ["def incrementer(n):\n", "    def inner(start):\n", "        current = start\n", "        def inc():\n", "            a = 10  # local var\n", "            nonlocal current\n", "            current += n\n", "            return current\n", "        return inc\n", "    return inner\n", "        "]}, {"cell_type": "code", "execution_count": 54, "metadata": {"collapsed": true}, "outputs": [], "source": ["fn = incrementer(2)"]}, {"cell_type": "code", "execution_count": 55, "metadata": {}, "outputs": [{"data": {"text/plain": ["<function __main__.incrementer.<locals>.inner>"]}, "execution_count": 55, "metadata": {}, "output_type": "execute_result"}], "source": ["fn"]}, {"cell_type": "code", "execution_count": 56, "metadata": {}, "outputs": [{"data": {"text/plain": ["('n',)"]}, "execution_count": 56, "metadata": {}, "output_type": "execute_result"}], "source": ["fn.__code__.co_freevars"]}, {"cell_type": "code", "execution_count": 57, "metadata": {}, "outputs": [{"data": {"text/plain": ["(<cell at 0x0000015F5299B798: int object at 0x00000000506FEC90>,)"]}, "execution_count": 57, "metadata": {}, "output_type": "execute_result"}], "source": ["fn.__closure__"]}, {"cell_type": "code", "execution_count": 58, "metadata": {"collapsed": true}, "outputs": [], "source": ["inc_2 = fn(100)"]}, {"cell_type": "code", "execution_count": 59, "metadata": {}, "outputs": [{"data": {"text/plain": ["<function __main__.incrementer.<locals>.inner.<locals>.inc>"]}, "execution_count": 59, "metadata": {}, "output_type": "execute_result"}], "source": ["inc_2"]}, {"cell_type": "code", "execution_count": 60, "metadata": {}, "outputs": [{"data": {"text/plain": ["('current', 'n')"]}, "execution_count": 60, "metadata": {}, "output_type": "execute_result"}], "source": ["inc_2.__code__.co_freevars"]}, {"cell_type": "code", "execution_count": 61, "metadata": {}, "outputs": [{"data": {"text/plain": ["(<cell at 0x0000015F5299B318: int object at 0x00000000506FF8D0>,\n", " <cell at 0x0000015F5299B798: int object at 0x00000000506FEC90>)"]}, "execution_count": 61, "metadata": {}, "output_type": "execute_result"}], "source": ["inc_2.__closure__"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Here you can see that the second free variable `n`, is pointing to the same cell as the free variable in `fn`."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Note that **a** is a local variable, and is not considered a free variable."]}, {"cell_type": "markdown", "metadata": {}, "source": ["And we can call the closures as follows:"]}, {"cell_type": "code", "execution_count": 62, "metadata": {}, "outputs": [{"data": {"text/plain": ["102"]}, "execution_count": 62, "metadata": {}, "output_type": "execute_result"}], "source": ["inc_2()"]}, {"cell_type": "code", "execution_count": 63, "metadata": {}, "outputs": [{"data": {"text/plain": ["104"]}, "execution_count": 63, "metadata": {}, "output_type": "execute_result"}], "source": ["inc_2()"]}, {"cell_type": "code", "execution_count": 64, "metadata": {"collapsed": true}, "outputs": [], "source": ["inc_3 = incrementer(3)(200)"]}, {"cell_type": "code", "execution_count": 65, "metadata": {}, "outputs": [{"data": {"text/plain": ["203"]}, "execution_count": 65, "metadata": {}, "output_type": "execute_result"}], "source": ["inc_3()"]}, {"cell_type": "code", "execution_count": 66, "metadata": {}, "outputs": [{"data": {"text/plain": ["206"]}, "execution_count": 66, "metadata": {}, "output_type": "execute_result"}], "source": ["inc_3()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Closure Applications (Part 1)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["In this example we are going to build an averager function that can average multiple values.\n", "\n", "The twist is that we want to simply be able to feed numbers to that function and get a running average over time, not average a list which requires performing the same calculations (sum and count) over and over again."]}, {"cell_type": "code", "execution_count": 1, "metadata": {}, "outputs": [], "source": ["class Averager:\n", "    def __init__(self):\n", "        self.numbers = []\n", "    \n", "    def add(self, number):\n", "        self.numbers.append(number)\n", "        total = sum(self.numbers)\n", "        count = len(self.numbers)\n", "        return total / count"]}, {"cell_type": "code", "execution_count": 2, "metadata": {"collapsed": true}, "outputs": [], "source": ["a = Averager()"]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [{"data": {"text/plain": ["10.0"]}, "execution_count": 3, "metadata": {}, "output_type": "execute_result"}], "source": ["a.add(10)"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"data": {"text/plain": ["15.0"]}, "execution_count": 4, "metadata": {}, "output_type": "execute_result"}], "source": ["a.add(20)"]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"data": {"text/plain": ["20.0"]}, "execution_count": 5, "metadata": {}, "output_type": "execute_result"}], "source": ["a.add(30)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can do this using a closure as follows:"]}, {"cell_type": "code", "execution_count": 6, "metadata": {"collapsed": true}, "outputs": [], "source": ["def averager():\n", "    numbers = []\n", "    def add(number):\n", "        numbers.append(number)\n", "        total = sum(numbers)\n", "        count = len(numbers)\n", "        return total / count\n", "    return add"]}, {"cell_type": "code", "execution_count": 7, "metadata": {"collapsed": true}, "outputs": [], "source": ["a = averager()"]}, {"cell_type": "code", "execution_count": 8, "metadata": {}, "outputs": [{"data": {"text/plain": ["10.0"]}, "execution_count": 8, "metadata": {}, "output_type": "execute_result"}], "source": ["a(10)"]}, {"cell_type": "code", "execution_count": 9, "metadata": {}, "outputs": [{"data": {"text/plain": ["15.0"]}, "execution_count": 9, "metadata": {}, "output_type": "execute_result"}], "source": ["a(20)"]}, {"cell_type": "code", "execution_count": 10, "metadata": {}, "outputs": [{"data": {"text/plain": ["20.0"]}, "execution_count": 10, "metadata": {}, "output_type": "execute_result"}], "source": ["a(30)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now, instead of storing a list and reclaculating `total` and `count` every time wer need the new average, we are going to store the running total and count and update each value each time a new value is added to the running average, and then return `total / count`.\n", "\n", "Let's start with a class approach first, where we will use instance variables to store the running total and count and provide an instance method to add a new number and return the current average."]}, {"cell_type": "code", "execution_count": 11, "metadata": {"collapsed": true}, "outputs": [], "source": ["class Averager:\n", "    def __init__(self):\n", "        self._count = 0\n", "        self._total = 0\n", "    \n", "    def add(self, value):\n", "        self._total += value\n", "        self._count += 1\n", "        return self._total / self._count"]}, {"cell_type": "code", "execution_count": 12, "metadata": {"collapsed": true}, "outputs": [], "source": ["a = Averager()"]}, {"cell_type": "code", "execution_count": 13, "metadata": {}, "outputs": [{"data": {"text/plain": ["10.0"]}, "execution_count": 13, "metadata": {}, "output_type": "execute_result"}], "source": ["a.add(10)"]}, {"cell_type": "code", "execution_count": 14, "metadata": {}, "outputs": [{"data": {"text/plain": ["15.0"]}, "execution_count": 14, "metadata": {}, "output_type": "execute_result"}], "source": ["a.add(20)"]}, {"cell_type": "code", "execution_count": 15, "metadata": {}, "outputs": [{"data": {"text/plain": ["20.0"]}, "execution_count": 15, "metadata": {}, "output_type": "execute_result"}], "source": ["a.add(30)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now, let's see how we might use a closure to achieve the same thing."]}, {"cell_type": "code", "execution_count": 16, "metadata": {"collapsed": true}, "outputs": [], "source": ["def averager():\n", "    total = 0\n", "    count = 0\n", "    \n", "    def add(value):\n", "        nonlocal total, count\n", "        total += value\n", "        count += 1\n", "        return 0 if count == 0 else total / count\n", "    \n", "    return add\n", "        "]}, {"cell_type": "code", "execution_count": 17, "metadata": {"collapsed": true}, "outputs": [], "source": ["a = averager()"]}, {"cell_type": "code", "execution_count": 18, "metadata": {}, "outputs": [{"data": {"text/plain": ["10.0"]}, "execution_count": 18, "metadata": {}, "output_type": "execute_result"}], "source": ["a(10)"]}, {"cell_type": "code", "execution_count": 19, "metadata": {}, "outputs": [{"data": {"text/plain": ["15.0"]}, "execution_count": 19, "metadata": {}, "output_type": "execute_result"}], "source": ["a(20)"]}, {"cell_type": "code", "execution_count": 20, "metadata": {}, "outputs": [{"data": {"text/plain": ["20.0"]}, "execution_count": 20, "metadata": {}, "output_type": "execute_result"}], "source": ["a(30)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Generalizing this example"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We saw that we were essentially able to convert a class to an equivalent functionality using closures. This is actually true in a much more general sense - very often, classes that define a single method (other than initializers) can be implemented using a closure instead.\n", "\n", "Let's look at another example of this."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Suppose we want something that can keep track of the running elapsed time in seconds."]}, {"cell_type": "code", "execution_count": 21, "metadata": {"collapsed": true}, "outputs": [], "source": ["from time import perf_counter"]}, {"cell_type": "code", "execution_count": 22, "metadata": {"collapsed": true}, "outputs": [], "source": ["class Timer:\n", "    def __init__(self):\n", "        self._start = perf_counter()\n", "    \n", "    def __call__(self):\n", "        return (perf_counter() - self._start)"]}, {"cell_type": "code", "execution_count": 23, "metadata": {"collapsed": true}, "outputs": [], "source": ["a = Timer()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now wait a bit before running the next line of code:"]}, {"cell_type": "code", "execution_count": 24, "metadata": {}, "outputs": [{"data": {"text/plain": ["0.011695334544051804"]}, "execution_count": 24, "metadata": {}, "output_type": "execute_result"}], "source": ["a()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's start another \"timer\":"]}, {"cell_type": "code", "execution_count": 25, "metadata": {"collapsed": true}, "outputs": [], "source": ["b = Timer()"]}, {"cell_type": "code", "execution_count": 26, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["0.03528294403966765\n", "0.011656054820407689\n"]}], "source": ["print(a())\n", "print(b())"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now let's rewrite this using a closure instead:"]}, {"cell_type": "code", "execution_count": 27, "metadata": {"collapsed": true}, "outputs": [], "source": ["def timer():\n", "    start = perf_counter()\n", "    \n", "    def elapsed():\n", "        # we don't even need to make start nonlocal \n", "        # since we are only reading it\n", "        return perf_counter() - start\n", "    \n", "    return elapsed"]}, {"cell_type": "code", "execution_count": 28, "metadata": {"collapsed": true}, "outputs": [], "source": ["x = timer()"]}, {"cell_type": "code", "execution_count": 29, "metadata": {}, "outputs": [{"data": {"text/plain": ["0.011068213438975016"]}, "execution_count": 29, "metadata": {}, "output_type": "execute_result"}], "source": ["x()"]}, {"cell_type": "code", "execution_count": 30, "metadata": {"collapsed": true}, "outputs": [], "source": ["y = timer()"]}, {"cell_type": "code", "execution_count": 31, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["0.03419096772236116\n", "0.01164738619174141\n"]}], "source": ["print(x())\n", "print(y())"]}, {"cell_type": "code", "execution_count": 32, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["0.10822159832175349\n", "0.08475345336494494\n", "0.0462381944113351\n", "0.023573252079387305\n"]}], "source": ["print(a())\n", "print(b())\n", "print(x())\n", "print(y())"]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": []}, {"cell_type": "markdown", "metadata": {}, "source": ["### Closure Applications (Part 2)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Example 1"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's write a small function that can increment a counter for us - we don't have an incrementor in Python (the ++ operator in Java or C++ for example):"]}, {"cell_type": "code", "execution_count": 2, "metadata": {"collapsed": true}, "outputs": [], "source": ["def counter(initial_value):\n", "    # initial_value is a local variable here\n", "    \n", "    def inc(increment=1):\n", "        nonlocal initial_value\n", "        # initial_value is a nonlocal (captured) variable here\n", "        initial_value += increment\n", "        return initial_value\n", "    \n", "    return inc"]}, {"cell_type": "code", "execution_count": 3, "metadata": {"collapsed": true}, "outputs": [], "source": ["counter1 = counter(0)"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["0\n"]}], "source": ["print(counter1(0))"]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1\n"]}], "source": ["print(counter1())"]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["2\n"]}], "source": ["print(counter1())"]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["10\n"]}], "source": ["print(counter1(8))"]}, {"cell_type": "code", "execution_count": 8, "metadata": {"collapsed": true}, "outputs": [], "source": ["counter2 = counter(1000)"]}, {"cell_type": "code", "execution_count": 9, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1000\n"]}], "source": ["print(counter2(0))"]}, {"cell_type": "code", "execution_count": 10, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1001\n"]}], "source": ["print(counter2(1))"]}, {"cell_type": "code", "execution_count": 11, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1002\n"]}], "source": ["print(counter2())"]}, {"cell_type": "code", "execution_count": 12, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1222\n"]}], "source": ["print(counter2(220))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see, each closure maintains a reference to the **initial_value** variable that was created when the **counter** function was **called** - each time that function was called, a new local variable **initial_value** was created (with a value assigned from the argument), and it became a nonlocal (captured) variable in the inner scope."]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Example 2"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's modify this example to now build something that can run, and maintain a count of how many times we have run some function."]}, {"cell_type": "code", "execution_count": 13, "metadata": {"collapsed": true}, "outputs": [], "source": ["def counter(fn):\n", "    cnt = 0  # initially fn has been run zero times\n", "    \n", "    def inner(*args, **kwargs):\n", "        nonlocal cnt\n", "        cnt = cnt + 1\n", "        print('{0} has been called {1} times'.format(fn.__name__, cnt))\n", "        return fn(*args, **kwargs)\n", "    \n", "    return inner"]}, {"cell_type": "code", "execution_count": 14, "metadata": {"collapsed": true}, "outputs": [], "source": ["def add(a, b):\n", "    return a + b"]}, {"cell_type": "code", "execution_count": 15, "metadata": {"collapsed": true}, "outputs": [], "source": ["counted_add = counter(add)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["And the free variables are:"]}, {"cell_type": "code", "execution_count": 16, "metadata": {}, "outputs": [{"data": {"text/plain": ["('cnt', 'fn')"]}, "execution_count": 16, "metadata": {}, "output_type": "execute_result"}], "source": ["counted_add.__code__.co_freevars"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can now call the `counted_add` function:"]}, {"cell_type": "code", "execution_count": 17, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["add has been called 1 times\n"]}, {"data": {"text/plain": ["3"]}, "execution_count": 17, "metadata": {}, "output_type": "execute_result"}], "source": ["counted_add(1, 2)"]}, {"cell_type": "code", "execution_count": 18, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["add has been called 2 times\n"]}, {"data": {"text/plain": ["5"]}, "execution_count": 18, "metadata": {}, "output_type": "execute_result"}], "source": ["counted_add(2, 3)"]}, {"cell_type": "code", "execution_count": 19, "metadata": {"collapsed": true}, "outputs": [], "source": ["def mult(a, b, c):\n", "    return a * b * c"]}, {"cell_type": "code", "execution_count": 20, "metadata": {"collapsed": true}, "outputs": [], "source": ["counted_mult = counter(mult)"]}, {"cell_type": "code", "execution_count": 21, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["mult has been called 1 times\n"]}, {"data": {"text/plain": ["6"]}, "execution_count": 21, "metadata": {}, "output_type": "execute_result"}], "source": ["counted_mult(1, 2, 3)"]}, {"cell_type": "code", "execution_count": 22, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["mult has been called 2 times\n"]}, {"data": {"text/plain": ["24"]}, "execution_count": 22, "metadata": {}, "output_type": "execute_result"}], "source": ["counted_mult(2, 3, 4)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Example 3"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's take this one step further, and actually store the function name and the number of calls in a global dictionary instead of just printing it out all the time."]}, {"cell_type": "code", "execution_count": 35, "metadata": {"collapsed": true}, "outputs": [], "source": ["counters = dict()\n", "\n", "def counter(fn):\n", "    cnt = 0  # initially fn has been run zero times\n", "    \n", "    def inner(*args, **kwargs):\n", "        nonlocal cnt\n", "        cnt = cnt + 1\n", "        counters[fn.__name__] = cnt  # counters is global\n", "        return fn(*args, **kwargs)\n", "    \n", "    return inner"]}, {"cell_type": "code", "execution_count": 26, "metadata": {"collapsed": true}, "outputs": [], "source": ["counted_add = counter(add)\n", "counted_mult = counter(mult)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Note that `counters` is a **global** variable, and therefore **not** a free variable:"]}, {"cell_type": "code", "execution_count": 27, "metadata": {}, "outputs": [{"data": {"text/plain": ["('cnt', 'fn')"]}, "execution_count": 27, "metadata": {}, "output_type": "execute_result"}], "source": ["counted_add.__code__.co_freevars"]}, {"cell_type": "code", "execution_count": 28, "metadata": {}, "outputs": [{"data": {"text/plain": ["('cnt', 'fn')"]}, "execution_count": 28, "metadata": {}, "output_type": "execute_result"}], "source": ["counted_mult.__code__.co_freevars"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can now call out functions:"]}, {"cell_type": "code", "execution_count": 29, "metadata": {}, "outputs": [{"data": {"text/plain": ["3"]}, "execution_count": 29, "metadata": {}, "output_type": "execute_result"}], "source": ["counted_add(1, 2)"]}, {"cell_type": "code", "execution_count": 30, "metadata": {}, "outputs": [{"data": {"text/plain": ["5"]}, "execution_count": 30, "metadata": {}, "output_type": "execute_result"}], "source": ["counted_add(2, 3)"]}, {"cell_type": "code", "execution_count": 31, "metadata": {}, "outputs": [{"data": {"text/plain": ["'aa'"]}, "execution_count": 31, "metadata": {}, "output_type": "execute_result"}], "source": ["counted_mult(1, 2, 'a')"]}, {"cell_type": "code", "execution_count": 32, "metadata": {}, "outputs": [{"data": {"text/plain": ["'bbbbbb'"]}, "execution_count": 32, "metadata": {}, "output_type": "execute_result"}], "source": ["counted_mult(2, 3, 'b')"]}, {"cell_type": "code", "execution_count": 33, "metadata": {}, "outputs": [{"data": {"text/plain": ["'abc'"]}, "execution_count": 33, "metadata": {}, "output_type": "execute_result"}], "source": ["counted_mult(1, 1, 'abc')"]}, {"cell_type": "code", "execution_count": 34, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["{'add': 2, 'mult': 3}\n"]}], "source": ["print(counters)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Of course this relies on us creating the **counters** global variable first and making sure we are naming it that way, so instead, we're going to pass it as an argument to the **counter** function:"]}, {"cell_type": "code", "execution_count": 36, "metadata": {"collapsed": true}, "outputs": [], "source": ["def counter(fn, counters):\n", "    cnt = 0  # initially fn has been run zero times\n", "    \n", "    def inner(*args, **kwargs):\n", "        nonlocal cnt\n", "        cnt = cnt + 1\n", "        counters[fn.__name__] = cnt  # counters is nonlocal\n", "        return fn(*args, **kwargs)\n", "    \n", "    return inner"]}, {"cell_type": "code", "execution_count": 33, "metadata": {"collapsed": true}, "outputs": [], "source": ["func_counters = dict()\n", "counted_add = counter(add, func_counters)\n", "counted_mult = counter(mult, func_counters)"]}, {"cell_type": "code", "execution_count": 34, "metadata": {}, "outputs": [{"data": {"text/plain": ["('cnt', 'counters', 'fn')"]}, "execution_count": 34, "metadata": {}, "output_type": "execute_result"}], "source": ["counted_add.__code__.co_freevars"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see, `counters` is now a free variable."]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can now call our functions:"]}, {"cell_type": "code", "execution_count": 35, "metadata": {"collapsed": true}, "outputs": [], "source": ["for i in range(5):\n", "    counted_add(i, i)\n", "\n", "for i in range(10):\n", "    counted_mult(i, i, i)"]}, {"cell_type": "code", "execution_count": 36, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["{'add': 5, 'mult': 10}\n"]}], "source": ["print(func_counters)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Of course, we don't have to assign the \"counted\" version of our functions a new name - we can simply assign it to the same name!"]}, {"cell_type": "code", "execution_count": 37, "metadata": {"collapsed": true}, "outputs": [], "source": ["def fact(n):\n", "    product = 1\n", "    for i in range(2, n+1):\n", "        product *= i\n", "    return product"]}, {"cell_type": "code", "execution_count": 38, "metadata": {"collapsed": true}, "outputs": [], "source": ["fact = counter(fact, func_counters)"]}, {"cell_type": "code", "execution_count": 39, "metadata": {}, "outputs": [{"data": {"text/plain": ["1"]}, "execution_count": 39, "metadata": {}, "output_type": "execute_result"}], "source": ["fact(0)"]}, {"cell_type": "code", "execution_count": 40, "metadata": {}, "outputs": [{"data": {"text/plain": ["6"]}, "execution_count": 40, "metadata": {}, "output_type": "execute_result"}], "source": ["fact(3)"]}, {"cell_type": "code", "execution_count": 41, "metadata": {}, "outputs": [{"data": {"text/plain": ["24"]}, "execution_count": 41, "metadata": {}, "output_type": "execute_result"}], "source": ["fact(4)"]}, {"cell_type": "code", "execution_count": 42, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["{'add': 5, 'mult': 10, 'fact': 3}\n"]}], "source": ["print(func_counters)"]}, {"cell_type": "markdown", "metadata": {"collapsed": true}, "source": ["Notice, how we essentially **added** some functionality to our `fact` function, without modifying what the `fact` function actually returns.\n", "\n", "This leads us straight into our next topic: decorators!"]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": []}, {"cell_type": "markdown", "metadata": {}, "source": ["### Decorators (Part 1)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Recall the example in the last section where we wrote a simple closure to count how many times a function had been run:"]}, {"cell_type": "code", "execution_count": 1, "metadata": {"collapsed": true}, "outputs": [], "source": ["def counter(fn):\n", "    count = 0\n", "    \n", "    def inner(*args, **kwargs):\n", "        nonlocal count\n", "        count += 1\n", "        print('Function {0} was called {1} times'.format(fn.__name__, count))\n", "        return fn(*args, **kwargs)\n", "    return inner"]}, {"cell_type": "code", "execution_count": 2, "metadata": {"collapsed": true}, "outputs": [], "source": ["def add(a, b=0):\n", "    \"\"\"\n", "    returns the sum of a and b\n", "    \"\"\"\n", "    return a + b"]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Help on function add in module __main__:\n", "\n", "add(a, b=0)\n", "    returns the sum of a and b\n", "\n"]}], "source": ["help(add)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Here's the memory address that `add` points to:"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"data": {"text/plain": ["2352389334696"]}, "execution_count": 4, "metadata": {}, "output_type": "execute_result"}], "source": ["id(add)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now we create a closure using the `add` function as an argument to the `counter` function:"]}, {"cell_type": "code", "execution_count": 5, "metadata": {"collapsed": true}, "outputs": [], "source": ["add = counter(add)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["And you'll note that `add` is no longer the same function as before. Indeed the memory address `add` points to is no longer the same:"]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [{"data": {"text/plain": ["2352404346128"]}, "execution_count": 6, "metadata": {}, "output_type": "execute_result"}], "source": ["id(add)"]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Function add was called 1 times\n"]}, {"data": {"text/plain": ["3"]}, "execution_count": 7, "metadata": {}, "output_type": "execute_result"}], "source": ["add(1, 2)"]}, {"cell_type": "code", "execution_count": 8, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Function add was called 2 times\n"]}, {"data": {"text/plain": ["4"]}, "execution_count": 8, "metadata": {}, "output_type": "execute_result"}], "source": ["add(2, 2)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["What happened is that we put our **add** function 'through' the **counter** function - we usually say that we **decorated** our function **add**.\n", "\n", "And we call that **counter** function a **decorator**.\n", "\n", "There is a shorthand way of decorating our function without having to type:\n", "\n", "``func = counter(func)``"]}, {"cell_type": "code", "execution_count": 9, "metadata": {"collapsed": true}, "outputs": [], "source": ["@counter\n", "def mult(a: float, b: float=1, c: float=1) -> float:\n", "    \"\"\"\n", "    returns the product of a, b, and c\n", "    \"\"\"\n", "    return a * b * c"]}, {"cell_type": "code", "execution_count": 10, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Function mult was called 1 times\n"]}, {"data": {"text/plain": ["6"]}, "execution_count": 10, "metadata": {}, "output_type": "execute_result"}], "source": ["mult(1, 2, 3)"]}, {"cell_type": "code", "execution_count": 11, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Function mult was called 2 times\n"]}, {"data": {"text/plain": ["8"]}, "execution_count": 11, "metadata": {}, "output_type": "execute_result"}], "source": ["mult(2, 2, 2)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's do a little bit of introspection on our two decorated functions:"]}, {"cell_type": "code", "execution_count": 12, "metadata": {}, "outputs": [{"data": {"text/plain": ["'inner'"]}, "execution_count": 12, "metadata": {}, "output_type": "execute_result"}], "source": ["add.__name__"]}, {"cell_type": "code", "execution_count": 13, "metadata": {}, "outputs": [{"data": {"text/plain": ["'inner'"]}, "execution_count": 13, "metadata": {}, "output_type": "execute_result"}], "source": ["mult.__name__"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see, the name of the function is no longer **add** or **mult**, but instead it is the name of that **inner** function in our decorator."]}, {"cell_type": "code", "execution_count": 14, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Help on function inner in module __main__:\n", "\n", "inner(*args, **kwargs)\n", "\n"]}], "source": ["help(add)"]}, {"cell_type": "code", "execution_count": 15, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Help on function inner in module __main__:\n", "\n", "inner(*args, **kwargs)\n", "\n"]}], "source": ["help(mult)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see, we've also lost our docstring and parameter annotations!"]}, {"cell_type": "markdown", "metadata": {}, "source": ["What about introspecting the parameters of **add** and **mult**:"]}, {"cell_type": "code", "execution_count": 16, "metadata": {"collapsed": true}, "outputs": [], "source": ["import inspect"]}, {"cell_type": "code", "execution_count": 17, "metadata": {}, "outputs": [{"data": {"text/plain": ["\"    def inner(*args, **kwargs):\\n        nonlocal count\\n        count += 1\\n        print('Function {0} was called {1} times'.format(fn.__name__, count))\\n        return fn(*args, **kwargs)\\n\""]}, "execution_count": 17, "metadata": {}, "output_type": "execute_result"}], "source": ["inspect.getsource(add)"]}, {"cell_type": "code", "execution_count": 18, "metadata": {}, "outputs": [{"data": {"text/plain": ["\"    def inner(*args, **kwargs):\\n        nonlocal count\\n        count += 1\\n        print('Function {0} was called {1} times'.format(fn.__name__, count))\\n        return fn(*args, **kwargs)\\n\""]}, "execution_count": 18, "metadata": {}, "output_type": "execute_result"}], "source": ["inspect.getsource(mult)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Even the signature is gone:"]}, {"cell_type": "code", "execution_count": 19, "metadata": {}, "outputs": [{"data": {"text/plain": ["<Signature (*args, **kwargs)>"]}, "execution_count": 19, "metadata": {}, "output_type": "execute_result"}], "source": ["inspect.signature(add)"]}, {"cell_type": "code", "execution_count": 20, "metadata": {}, "outputs": [{"data": {"text/plain": ["<Signature (*args, **kwargs)>"]}, "execution_count": 20, "metadata": {}, "output_type": "execute_result"}], "source": ["inspect.signature(mult)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Even the parameter defaults documentation is are gone:"]}, {"cell_type": "code", "execution_count": 21, "metadata": {}, "outputs": [{"data": {"text/plain": ["mappingproxy({'args': <Parameter \"*args\">, 'kwargs': <Parameter \"**kwargs\">})"]}, "execution_count": 21, "metadata": {}, "output_type": "execute_result"}], "source": ["inspect.signature(add).parameters"]}, {"cell_type": "markdown", "metadata": {}, "source": ["In general, when we create decorated functions, we end up \"losing\" a lot of the metadata of our original function!"]}, {"cell_type": "markdown", "metadata": {}, "source": ["However, we **can** put that information back in - it can get quite complicated.\n", "\n", "Let's see how we might be able to do that for some simple things, like the docstring and the function name."]}, {"cell_type": "code", "execution_count": 22, "metadata": {"collapsed": true}, "outputs": [], "source": ["def counter(fn):\n", "    count = 0\n", "    \n", "    def inner(*args, **kwargs):\n", "        nonlocal count\n", "        count += 1\n", "        print(\"{0} was called {1} times\".format(fn.__name__, count))\n", "    inner.__name__ = fn.__name__\n", "    inner.__doc__ = fn.__doc__\n", "    return inner"]}, {"cell_type": "code", "execution_count": 23, "metadata": {"collapsed": true}, "outputs": [], "source": ["@counter\n", "def add(a: int, b: int=10) -> int:\n", "    \"\"\"\n", "    returns sum of two integers\n", "    \"\"\"\n", "    return a + b"]}, {"cell_type": "code", "execution_count": 24, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Help on function add in module __main__:\n", "\n", "add(*args, **kwargs)\n", "    returns sum of two integers\n", "\n"]}], "source": ["help(add)"]}, {"cell_type": "code", "execution_count": 25, "metadata": {}, "outputs": [{"data": {"text/plain": ["'add'"]}, "execution_count": 25, "metadata": {}, "output_type": "execute_result"}], "source": ["add.__name__"]}, {"cell_type": "markdown", "metadata": {}, "source": ["At least we have the docstring and function name back... But what about the parameters? Our real **add** function takes two positional parameters, but because the closure used a generic way of accepting **\\*args** and **\\*\\*kwargs**, we lose this information"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can use a special function in the **functools** module, called **wraps**. In fact, that function is a decorator itself!"]}, {"cell_type": "code", "execution_count": 26, "metadata": {"collapsed": true}, "outputs": [], "source": ["from functools import wraps"]}, {"cell_type": "code", "execution_count": 27, "metadata": {"collapsed": true}, "outputs": [], "source": ["def counter(fn):\n", "    count = 0\n", "    \n", "    @wraps(fn)\n", "    def inner(*args, **kwargs):\n", "        nonlocal count\n", "        count += 1\n", "        print(\"{0} was called {1} times\".format(fn.__name__, count))\n", "\n", "    return inner"]}, {"cell_type": "code", "execution_count": 28, "metadata": {"collapsed": true}, "outputs": [], "source": ["@counter\n", "def add(a: int, b: int=10) -> int:\n", "    \"\"\"\n", "    returns sum of two integers\n", "    \"\"\"\n", "    return a + b"]}, {"cell_type": "code", "execution_count": 29, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Help on function add in module __main__:\n", "\n", "add(a:int, b:int=10) -> int\n", "    returns sum of two integers\n", "\n"]}], "source": ["help(add)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Yay!!! Everything is back to normal."]}, {"cell_type": "code", "execution_count": 30, "metadata": {}, "outputs": [{"data": {"text/plain": ["'@counter\\ndef add(a: int, b: int=10) -> int:\\n    \"\"\"\\n    returns sum of two integers\\n    \"\"\"\\n    return a + b\\n'"]}, "execution_count": 30, "metadata": {}, "output_type": "execute_result"}], "source": ["inspect.getsource(add)"]}, {"cell_type": "code", "execution_count": 31, "metadata": {}, "outputs": [{"data": {"text/plain": ["<Signature (a:int, b:int=10) -> int>"]}, "execution_count": 31, "metadata": {}, "output_type": "execute_result"}], "source": ["inspect.signature(add)"]}, {"cell_type": "code", "execution_count": 32, "metadata": {}, "outputs": [{"data": {"text/plain": ["mappingproxy({'a': <Parameter \"a:int\">, 'b': <Parameter \"b:int=10\">})"]}, "execution_count": 32, "metadata": {}, "output_type": "execute_result"}], "source": ["inspect.signature(add).parameters"]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Decorators Application (Timing)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Here we go back to an example we have seen in the past - timing how long it takes to run a certain function."]}, {"cell_type": "code", "execution_count": 2, "metadata": {"collapsed": true}, "outputs": [], "source": ["def timed(fn):\n", "    from time import perf_counter\n", "    from functools import wraps\n", "    \n", "    @wraps(fn)\n", "    def inner(*args, **kwargs):\n", "        start = perf_counter()\n", "        result = fn(*args, **kwargs)\n", "        end = perf_counter()\n", "        elapsed = end - start\n", "        \n", "        args_ = [str(a) for a in args]\n", "        kwargs_ = ['{0}={1}'.format(k, v) for (k, v) in kwargs.items()]\n", "        all_args = args_ + kwargs_\n", "        args_str = ','.join(all_args)\n", "        print('{0}({1}) took {2:.6f}s to run.'.format(fn.__name__, \n", "                                                         args_str,\n", "                                                         elapsed))\n", "        return result\n", "    \n", "    return inner"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's write a function that calculates the n-th Fibonacci number:\n", "\n", "`1, 1, 2, 3, 5, 8, ...`\n", "\n", "We will implement this using three different methods:\n", "1. recursion\n", "2. a loop\n", "3. functional programming (reduce)\n", "\n", "We use a 1-based system, e.g. first Fibonnaci number has index 1, etc."]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Using Recursion\n"]}, {"cell_type": "code", "execution_count": 3, "metadata": {"collapsed": true}, "outputs": [], "source": ["def calc_recursive_fib(n):\n", "    if n <=2:\n", "        return 1\n", "    else:\n", "        return calc_recursive_fib(n-1) + calc_recursive_fib(n-2)"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"data": {"text/plain": ["2"]}, "execution_count": 4, "metadata": {}, "output_type": "execute_result"}], "source": ["calc_recursive_fib(3)"]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"data": {"text/plain": ["8"]}, "execution_count": 5, "metadata": {}, "output_type": "execute_result"}], "source": ["calc_recursive_fib(6)"]}, {"cell_type": "code", "execution_count": 6, "metadata": {"collapsed": true}, "outputs": [], "source": ["@timed\n", "def fib_recursed(n):\n", "    return calc_recursive_fib(n)"]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["fib_recursed(33) took 1.060477s to run.\n"]}, {"data": {"text/plain": ["3524578"]}, "execution_count": 7, "metadata": {}, "output_type": "execute_result"}], "source": ["fib_recursed(33)"]}, {"cell_type": "code", "execution_count": 8, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["fib_recursed(34) took 1.715229s to run.\n"]}, {"data": {"text/plain": ["5702887"]}, "execution_count": 8, "metadata": {}, "output_type": "execute_result"}], "source": ["fib_recursed(34)"]}, {"cell_type": "code", "execution_count": 9, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["fib_recursed(35) took 2.773638s to run.\n"]}, {"data": {"text/plain": ["9227465"]}, "execution_count": 9, "metadata": {}, "output_type": "execute_result"}], "source": ["fib_recursed(35)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["There's a reason we did not decorate our recursive function directly!"]}, {"cell_type": "code", "execution_count": 10, "metadata": {"collapsed": true}, "outputs": [], "source": ["@timed\n", "def fib_recursed_2(n):\n", "    if n <=2:\n", "        return 1\n", "    else:\n", "        return fib_recursed_2(n-1) + fib_recursed_2(n-2)"]}, {"cell_type": "code", "execution_count": 11, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["fib_recursed_2(2) took 0.000000s to run.\n", "fib_recursed_2(1) took 0.000001s to run.\n", "fib_recursed_2(3) took 0.000409s to run.\n", "fib_recursed_2(2) took 0.000001s to run.\n", "fib_recursed_2(4) took 0.000460s to run.\n", "fib_recursed_2(2) took 0.000000s to run.\n", "fib_recursed_2(1) took 0.000000s to run.\n", "fib_recursed_2(3) took 0.000038s to run.\n", "fib_recursed_2(5) took 0.000535s to run.\n", "fib_recursed_2(2) took 0.000000s to run.\n", "fib_recursed_2(1) took 0.000000s to run.\n", "fib_recursed_2(3) took 0.000038s to run.\n", "fib_recursed_2(2) took 0.000000s to run.\n", "fib_recursed_2(4) took 0.000075s to run.\n", "fib_recursed_2(6) took 0.000646s to run.\n", "fib_recursed_2(2) took 0.000000s to run.\n", "fib_recursed_2(1) took 0.000000s to run.\n", "fib_recursed_2(3) took 0.000036s to run.\n", "fib_recursed_2(2) took 0.000001s to run.\n", "fib_recursed_2(4) took 0.000071s to run.\n", "fib_recursed_2(2) took 0.000000s to run.\n", "fib_recursed_2(1) took 0.000000s to run.\n", "fib_recursed_2(3) took 0.000035s to run.\n", "fib_recursed_2(5) took 0.000143s to run.\n", "fib_recursed_2(7) took 0.000837s to run.\n", "fib_recursed_2(2) took 0.000000s to run.\n", "fib_recursed_2(1) took 0.000001s to run.\n", "fib_recursed_2(3) took 0.000036s to run.\n", "fib_recursed_2(2) took 0.000000s to run.\n", "fib_recursed_2(4) took 0.000072s to run.\n", "fib_recursed_2(2) took 0.000000s to run.\n", "fib_recursed_2(1) took 0.000000s to run.\n", "fib_recursed_2(3) took 0.000036s to run.\n", "fib_recursed_2(5) took 0.000142s to run.\n", "fib_recursed_2(2) took 0.000000s to run.\n", "fib_recursed_2(1) took 0.000000s to run.\n", "fib_recursed_2(3) took 0.000037s to run.\n", "fib_recursed_2(2) took 0.000000s to run.\n", "fib_recursed_2(4) took 0.000073s to run.\n", "fib_recursed_2(6) took 0.000251s to run.\n", "fib_recursed_2(8) took 0.001125s to run.\n", "fib_recursed_2(2) took 0.000000s to run.\n", "fib_recursed_2(1) took 0.000000s to run.\n", "fib_recursed_2(3) took 0.000041s to run.\n", "fib_recursed_2(2) took 0.000000s to run.\n", "fib_recursed_2(4) took 0.000076s to run.\n", "fib_recursed_2(2) took 0.000000s to run.\n", "fib_recursed_2(1) took 0.000000s to run.\n", "fib_recursed_2(3) took 0.000035s to run.\n", "fib_recursed_2(5) took 0.000146s to run.\n", "fib_recursed_2(2) took 0.000000s to run.\n", "fib_recursed_2(1) took 0.000001s to run.\n", "fib_recursed_2(3) took 0.000036s to run.\n", "fib_recursed_2(2) took 0.000000s to run.\n", "fib_recursed_2(4) took 0.000072s to run.\n", "fib_recursed_2(6) took 0.000253s to run.\n", "fib_recursed_2(2) took 0.000000s to run.\n", "fib_recursed_2(1) took 0.000001s to run.\n", "fib_recursed_2(3) took 0.000048s to run.\n", "fib_recursed_2(2) took 0.000001s to run.\n", "fib_recursed_2(4) took 0.000085s to run.\n", "fib_recursed_2(2) took 0.000000s to run.\n", "fib_recursed_2(1) took 0.000000s to run.\n", "fib_recursed_2(3) took 0.000036s to run.\n", "fib_recursed_2(5) took 0.000156s to run.\n", "fib_recursed_2(7) took 0.000444s to run.\n", "fib_recursed_2(9) took 0.001604s to run.\n", "fib_recursed_2(2) took 0.000000s to run.\n", "fib_recursed_2(1) took 0.000001s to run.\n", "fib_recursed_2(3) took 0.000036s to run.\n", "fib_recursed_2(2) took 0.000001s to run.\n", "fib_recursed_2(4) took 0.000071s to run.\n", "fib_recursed_2(2) took 0.000000s to run.\n", "fib_recursed_2(1) took 0.000000s to run.\n", "fib_recursed_2(3) took 0.000036s to run.\n", "fib_recursed_2(5) took 0.000142s to run.\n", "fib_recursed_2(2) took 0.000000s to run.\n", "fib_recursed_2(1) took 0.000000s to run.\n", "fib_recursed_2(3) took 0.000036s to run.\n", "fib_recursed_2(2) took 0.000000s to run.\n", "fib_recursed_2(4) took 0.000071s to run.\n", "fib_recursed_2(6) took 0.000248s to run.\n", "fib_recursed_2(2) took 0.000000s to run.\n", "fib_recursed_2(1) took 0.000000s to run.\n", "fib_recursed_2(3) took 0.000040s to run.\n", "fib_recursed_2(2) took 0.000000s to run.\n", "fib_recursed_2(4) took 0.000075s to run.\n", "fib_recursed_2(2) took 0.000000s to run.\n", "fib_recursed_2(1) took 0.000000s to run.\n", "fib_recursed_2(3) took 0.000036s to run.\n", "fib_recursed_2(5) took 0.000145s to run.\n", "fib_recursed_2(7) took 0.000429s to run.\n", "fib_recursed_2(2) took 0.000000s to run.\n", "fib_recursed_2(1) took 0.000000s to run.\n", "fib_recursed_2(3) took 0.000035s to run.\n", "fib_recursed_2(2) took 0.000001s to run.\n", "fib_recursed_2(4) took 0.000075s to run.\n", "fib_recursed_2(2) took 0.000000s to run.\n", "fib_recursed_2(1) took 0.000000s to run.\n", "fib_recursed_2(3) took 0.000035s to run.\n", "fib_recursed_2(5) took 0.000145s to run.\n", "fib_recursed_2(2) took 0.000000s to run.\n", "fib_recursed_2(1) took 0.000000s to run.\n", "fib_recursed_2(3) took 0.000041s to run.\n", "fib_recursed_2(2) took 0.000000s to run.\n", "fib_recursed_2(4) took 0.000076s to run.\n", "fib_recursed_2(6) took 0.000256s to run.\n", "fib_recursed_2(8) took 0.000720s to run.\n", "fib_recursed_2(10) took 0.002367s to run.\n"]}, {"data": {"text/plain": ["55"]}, "execution_count": 11, "metadata": {}, "output_type": "execute_result"}], "source": ["fib_recursed_2(10)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Since we are calling the function recursively, we are actually calling the **decorated** function recursively. In this case I wanted the total time to calculate the n-th number, not the time for each recursion.\n", "\n", "You will notice from the above how inefficient the recursive method is: the same fibonacci numbers are calculated repeatedly! This is why as the value of `n` start increasing beyond 30 we start seeing considerable slow downs."]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Using a Loop"]}, {"cell_type": "code", "execution_count": 12, "metadata": {"collapsed": true}, "outputs": [], "source": ["@timed\n", "def fib_loop(n):\n", "    fib_1 = 1\n", "    fib_2 = 1\n", "    for i in range(3, n+1):\n", "        fib_1, fib_2 = fib_2, fib_1 + fib_2\n", "    return fib_2               "]}, {"cell_type": "code", "execution_count": 13, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["fib_loop(3) took 0.000003s to run.\n"]}, {"data": {"text/plain": ["2"]}, "execution_count": 13, "metadata": {}, "output_type": "execute_result"}], "source": ["fib_loop(3)"]}, {"cell_type": "code", "execution_count": 14, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["fib_loop(6) took 0.000002s to run.\n"]}, {"data": {"text/plain": ["8"]}, "execution_count": 14, "metadata": {}, "output_type": "execute_result"}], "source": ["fib_loop(6)"]}, {"cell_type": "code", "execution_count": 15, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["fib_loop(34) took 0.000004s to run.\n"]}, {"data": {"text/plain": ["5702887"]}, "execution_count": 15, "metadata": {}, "output_type": "execute_result"}], "source": ["fib_loop(34)"]}, {"cell_type": "code", "execution_count": 16, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["fib_loop(35) took 0.000005s to run.\n"]}, {"data": {"text/plain": ["9227465"]}, "execution_count": 16, "metadata": {}, "output_type": "execute_result"}], "source": ["fib_loop(35)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see this method is much more efficient!"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Using  Reduce"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We first need to understand how we are going to calculate the Fibonnaci sequence using reduce: \n", "\n", "<pre>\n", "n=1:\n", "(1, 0) --> (1, 1)\n", "\n", "n=2:\n", "(1, 0) --> (1, 1) --> (1 + 1, 1) = (2, 1)  : result = 2 \n", "\n", "n=3\n", "(1, 0) --> (1, 1) --> (2, 1) --> (2+1, 2) = (3, 2)  : result = 3\n", "\n", "n=4\n", "(1, 0) --> (1, 1) --> (2, 1) --> (3, 2) --> (5, 3)  : result = 5\n", "</pre>\n", "\n", "In general each step in the reduction is as follows:\n", "\n", "<pre>\n", "previous value = (a, b)\n", "new value = (a+b, a)\n", "</pre>\n", "\n", "If we start our reduction with an initial value of `(1, 0)`, we need to run our \"loop\" n times.\n", "\n", "We therefore use a \"dummy\" sequence of length `n` to create `n` steps in our reduce.\n"]}, {"cell_type": "code", "execution_count": 33, "metadata": {"collapsed": true}, "outputs": [], "source": ["from functools import reduce\n", "\n", "@timed\n", "def fib_reduce(n):\n", "    initial = (1, 0)\n", "    dummy = range(n-1)\n", "    fib_n = reduce(lambda prev, n: (prev[0] + prev[1], prev[0]), \n", "                   dummy, \n", "                   initial)\n", "    return fib_n[0]                  "]}, {"cell_type": "code", "execution_count": 34, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["fib_reduce(3) took 0.000004s to run.\n"]}, {"data": {"text/plain": ["2"]}, "execution_count": 34, "metadata": {}, "output_type": "execute_result"}], "source": ["fib_reduce(3)"]}, {"cell_type": "code", "execution_count": 35, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["fib_reduce(6) took 0.000005s to run.\n"]}, {"data": {"text/plain": ["8"]}, "execution_count": 35, "metadata": {}, "output_type": "execute_result"}], "source": ["fib_reduce(6)"]}, {"cell_type": "code", "execution_count": 36, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["fib_reduce(34) took 0.000013s to run.\n"]}, {"data": {"text/plain": ["5702887"]}, "execution_count": 36, "metadata": {}, "output_type": "execute_result"}], "source": ["fib_reduce(34)"]}, {"cell_type": "code", "execution_count": 37, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["fib_reduce(35) took 0.000014s to run.\n"]}, {"data": {"text/plain": ["9227465"]}, "execution_count": 37, "metadata": {}, "output_type": "execute_result"}], "source": ["fib_reduce(35)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now we can run a quick comparison between the various timed implementations:"]}, {"cell_type": "code", "execution_count": 22, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["fib_recursed(35) took 2.771373s to run.\n", "fib_loop(35) took 0.000007s to run.\n", "fib_reduce(35) took 0.000013s to run.\n"]}, {"data": {"text/plain": ["9227465"]}, "execution_count": 22, "metadata": {}, "output_type": "execute_result"}], "source": ["fib_recursed(35)\n", "fib_loop(35)\n", "fib_reduce(35)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Even though the recursive algorithm is by far the easiest to understand, it is also the slowest. We'll see how to fix this in an upcoming video using a technique called **memoization**."]}, {"cell_type": "markdown", "metadata": {}, "source": ["First let's focus on the loop and reduce variants. Our timing is not very effective since we only time a single calculation for each - there could be some variance if we run these tests multiple times:"]}, {"cell_type": "code", "execution_count": 23, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["fib_loop(10000) took 0.002114s to run.\n", "fib_loop(10000) took 0.002109s to run.\n", "fib_loop(10000) took 0.002072s to run.\n", "fib_loop(10000) took 0.002072s to run.\n", "fib_loop(10000) took 0.002075s to run.\n", "fib_loop(10000) took 0.002078s to run.\n", "fib_loop(10000) took 0.002049s to run.\n", "fib_loop(10000) took 0.002064s to run.\n", "fib_loop(10000) took 0.002533s to run.\n", "fib_loop(10000) took 0.002109s to run.\n"]}], "source": ["for i in range(10):\n", "    result =  fib_loop(10000)"]}, {"cell_type": "code", "execution_count": 24, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["fib_reduce(10000) took 0.004234s to run.\n", "fib_reduce(10000) took 0.003961s to run.\n", "fib_reduce(10000) took 0.004363s to run.\n", "fib_reduce(10000) took 0.004459s to run.\n", "fib_reduce(10000) took 0.003895s to run.\n", "fib_reduce(10000) took 0.003847s to run.\n", "fib_reduce(10000) took 0.004342s to run.\n", "fib_reduce(10000) took 0.003908s to run.\n", "fib_reduce(10000) took 0.003970s to run.\n", "fib_reduce(10000) took 0.003970s to run.\n"]}], "source": ["for i in range(10):\n", "    result = fib_reduce(10000)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["In general it is better to time the same function call multiple times and generate and average of the run times.\n", "\n", "We'll see in an upcoming video how we can do this from within our decorator."]}, {"cell_type": "markdown", "metadata": {}, "source": ["In the meantime observe that the simple loop approach seems to perform about twice as fast as the reduce approach!!\n", "\n", "The moral of this side note is that simply because you **can** do something in  Python using some fancy or cool technique does not mean you **should**!"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We technically could write our reduce-based function as a one liner:"]}, {"cell_type": "code", "execution_count": 25, "metadata": {"collapsed": true}, "outputs": [], "source": ["from functools import reduce \n", "\n", "fib_1 = timed(lambda n: reduce(lambda prev, n: (prev[0] + prev[1], prev[0]),\n", "                               range(n), \n", "                               (0, 1))[0])"]}, {"cell_type": "code", "execution_count": 26, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["fib_loop(100) took 0.000009s to run.\n"]}, {"data": {"text/plain": ["354224848179261915075"]}, "execution_count": 26, "metadata": {}, "output_type": "execute_result"}], "source": ["fib_loop(100)"]}, {"cell_type": "code", "execution_count": 27, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["<lambda>(100) took 0.000031s to run.\n"]}, {"data": {"text/plain": ["354224848179261915075"]}, "execution_count": 27, "metadata": {}, "output_type": "execute_result"}], "source": ["fib_1(100)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["So yes, it's cool that you can write this using a single line of code, but consider two things here:\n", "1. Is it as efficient as another method?\n", "2. Is the code **readable**?\n", "\n", "Code readability is something I cannot emphasize enough. Given similar efficiencies (cpu / memory), give preference to code that is more easily understandable!\n", "\n", "Sometimes, if the efficiency is not greatly impacted (or does not matter in absolute terms), I might even give preference to less efficient, but more readable (i.e. understanbdable), code.\n", "\n", "But enough of the soapbox already :-)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Decorators Application (Logger, Stacked Decorators)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["In this example we're going to create a utility decorator that will log function calls (to the console, but in practice you would be writing your logs to a file (e.g. using Python's built-in logger), or to a database, etc."]}, {"cell_type": "code", "execution_count": 1, "metadata": {"collapsed": true}, "outputs": [], "source": ["def logged(fn):\n", "    from functools import wraps\n", "    from datetime import datetime, timezone\n", "    \n", "    @wraps(fn)\n", "    def inner(*args, **kwargs):\n", "        run_dt = datetime.now(timezone.utc)\n", "        result = fn(*args, **kwargs)\n", "        print('{0}: called {1}'.format(fn.__name__, run_dt))\n", "        return result\n", "        \n", "    return inner"]}, {"cell_type": "code", "execution_count": 2, "metadata": {"collapsed": true}, "outputs": [], "source": ["@logged\n", "def func_1():\n", "    pass"]}, {"cell_type": "code", "execution_count": 3, "metadata": {"collapsed": true}, "outputs": [], "source": ["@logged\n", "def func_2():\n", "    pass"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["func_1: called 2017-12-10 00:09:19.443657+00:00\n"]}], "source": ["func_1()"]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["func_2: called 2017-12-10 00:09:19.460691+00:00\n"]}], "source": ["func_2()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now we may additionaly also want to time the function. We can certainly include the code to do so in our `logged` decorator, but we could also just use the `@timed` decorator we already wrote by **stacking** our decorators."]}, {"cell_type": "code", "execution_count": 6, "metadata": {"collapsed": true}, "outputs": [], "source": ["def timed(fn):\n", "    from functools import wraps\n", "    from time import perf_counter\n", "    \n", "    @wraps(fn)\n", "    def inner(*args, **kwargs):\n", "        start = perf_counter()\n", "        result = fn(*args, **kwargs)\n", "        end = perf_counter()\n", "        print('{0} ran for {1:.6f}s'.format(fn.__name__, end-start))\n", "        return result\n", "    \n", "    return inner"]}, {"cell_type": "code", "execution_count": 7, "metadata": {"collapsed": true}, "outputs": [], "source": ["@timed\n", "@logged\n", "def factorial(n):\n", "    from operator import mul\n", "    from functools import reduce\n", "    \n", "    return reduce(mul, range(1, n+1))"]}, {"cell_type": "code", "execution_count": 8, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["factorial: called 2017-12-10 00:09:19.496762+00:00\n", "factorial ran for 0.000130s\n"]}, {"data": {"text/plain": ["3628800"]}, "execution_count": 8, "metadata": {}, "output_type": "execute_result"}], "source": ["factorial(10)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Note that the order in which we stack the decorators can make a difference!"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Remember that this is because our stacked decorators essentially amounted to:"]}, {"cell_type": "code", "execution_count": 9, "metadata": {"collapsed": true}, "outputs": [], "source": ["def factorial(n):\n", "    from operator import mul\n", "    from functools import reduce\n", "    \n", "    return reduce(mul, range(1, n+1))\n", "\n", "factorial = timed(logged(factorial))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["So in this case the `timed` decorator will be called first, followed by the `logged` decorator.\n", "\n", "You may wonder why the printed output seems reversed. Look at how the decorators were defined - they first ran the function passed in, and **then** printed the result.\n", "\n", "So in the above example, a simplified look at what happens in each decorator:\n", "\n", "* `timed(fn)(*args, **kwargs)`:\n", "    1. calls `fn(*args, **kwargs)`\n", "    2. prints timing\n", "    \n", "    \n", "* `logged(fn)(*args, **kwargs)`:\n", "    1. calls `fn(*args, **kwargs)`\n", "    2. prints log info\n", "\n", "So, calling\n", "`factorial = timed(logged(factorial))`\n", "\n", "is equivalent to:\n", "\n", "<pre>\n", "fn = logged(factorial)\n", "factorial = timed(fn)\n", "\n", "factorial(n) --> call timed(fn)(n)\n", "             --> call fn(n), then print timing\n", "             --> call logged(original_factorial)(n), then print timing\n", "             --> call original_factorial(n), then log, then print timing\n", "</pre>\n", "\n", "So as you can see, the `timed` decorator ran first, but it called the logged decorated function first, then printed the result - hence why the print output seems reversed."]}, {"cell_type": "code", "execution_count": 10, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["factorial: called 2017-12-10 00:09:19.525820+00:00\n", "factorial ran for 0.000147s\n"]}, {"data": {"text/plain": ["3628800"]}, "execution_count": 10, "metadata": {}, "output_type": "execute_result"}], "source": ["factorial(10)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But in the following case, the `logged` decorator will run first, followed by the `timed` decorator:"]}, {"cell_type": "code", "execution_count": 11, "metadata": {"collapsed": true}, "outputs": [], "source": ["def factorial(n):\n", "    from operator import mul\n", "    from functools import reduce\n", "    \n", "    return reduce(mul, range(1, n+1))\n", "\n", "factorial = logged(timed(factorial))"]}, {"cell_type": "code", "execution_count": 12, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["factorial ran for 0.000015s\n", "factorial: called 2017-12-10 00:09:19.547866+00:00\n"]}, {"data": {"text/plain": ["3628800"]}, "execution_count": 12, "metadata": {}, "output_type": "execute_result"}], "source": ["factorial(10)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Or, using the **@** notation:"]}, {"cell_type": "code", "execution_count": 13, "metadata": {"collapsed": true}, "outputs": [], "source": ["@logged\n", "@timed\n", "def factorial(n):\n", "    from operator import mul\n", "    from functools import reduce\n", "    \n", "    return reduce(mul, range(1, n+1))"]}, {"cell_type": "code", "execution_count": 14, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["factorial ran for 0.000016s\n", "factorial: called 2017-12-10 00:09:19.572914+00:00\n"]}, {"data": {"text/plain": ["3628800"]}, "execution_count": 14, "metadata": {}, "output_type": "execute_result"}], "source": ["factorial(10)"]}, {"cell_type": "code", "execution_count": 15, "metadata": {"collapsed": true}, "outputs": [], "source": ["@timed\n", "@logged\n", "def factorial(n):\n", "    from operator import mul\n", "    from functools import reduce\n", "    \n", "    return reduce(mul, range(1, n+1))"]}, {"cell_type": "code", "execution_count": 16, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["factorial: called 2017-12-10 00:09:19.608237+00:00\n", "factorial ran for 0.000153s\n"]}, {"data": {"text/plain": ["3628800"]}, "execution_count": 16, "metadata": {}, "output_type": "execute_result"}], "source": ["factorial(10)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["To make this clearer, let's write two very simple decorators as follows:"]}, {"cell_type": "code", "execution_count": 17, "metadata": {"collapsed": true}, "outputs": [], "source": ["def dec_1(fn):\n", "    def inner():\n", "        print('running dec_1')\n", "        return fn()\n", "    return inner"]}, {"cell_type": "code", "execution_count": 18, "metadata": {"collapsed": true}, "outputs": [], "source": ["def dec_2(fn):\n", "    def inner():\n", "        print('running dec_2')\n", "        return fn()\n", "    return inner"]}, {"cell_type": "code", "execution_count": 19, "metadata": {"collapsed": true}, "outputs": [], "source": ["@dec_1\n", "@dec_2\n", "def my_func():\n", "    print('running my_func')"]}, {"cell_type": "code", "execution_count": 20, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["running dec_1\n", "running dec_2\n", "running my_func\n"]}], "source": ["my_func()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But if we change the order of the decorators:"]}, {"cell_type": "code", "execution_count": 21, "metadata": {"collapsed": true}, "outputs": [], "source": ["@dec_2\n", "@dec_1\n", "def my_func():\n", "    print('running my_func')"]}, {"cell_type": "code", "execution_count": 22, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["running dec_2\n", "running dec_1\n", "running my_func\n"]}], "source": ["my_func()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["You may wonder whether this really matters in practice. And yes, it can.\n", "\n", "Consider an API that contains various functions that can be called. However, endpoints are secured and can only be run by authenticated users who have some specific role(s). If they do not have the role you want to return an unauthorized error. But if they do, then you want to log that they called the endpoint.\n", "\n", "In this case you may have one decorator that is used to check authentication and permissions (and immediately return an unauthorized error from the API if applicable), and the other to log the call. \n", "\n", "If you decorated it this way:\n", "\n", "<pre>\n", "@log\n", "@authorize\n", "def my_endpoint():\n", "    pass\n", "</pre>\n", "\n", "then the call would always be logged.\n", "\n", "But, in this instance:\n", "\n", "<pre>\n", "@authorize\n", "@log\n", "def my_endpoint():\n", "    pass\n", "</pre>\n", "\n", "your endpoint would only get logged if the user passed the `authorize` test."]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Decorators Application (Memoization)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's go back to our Fibonacci example:"]}, {"cell_type": "code", "execution_count": 1, "metadata": {"collapsed": true}, "outputs": [], "source": ["def fib(n):\n", "    print ('Calculating fib({0})'.format(n))\n", "    return 1 if n < 3 else fib(n-1) + fib(n-2)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["When we run this, we see that it is quite inefficient, as the same Fibonacci numbers get calculated multiple times:"]}, {"cell_type": "code", "execution_count": 2, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Calculating fib(6)\n", "Calculating fib(5)\n", "Calculating fib(4)\n", "Calculating fib(3)\n", "Calculating fib(2)\n", "Calculating fib(1)\n", "Calculating fib(2)\n", "Calculating fib(3)\n", "Calculating fib(2)\n", "Calculating fib(1)\n", "Calculating fib(4)\n", "Calculating fib(3)\n", "Calculating fib(2)\n", "Calculating fib(1)\n", "Calculating fib(2)\n"]}, {"data": {"text/plain": ["8"]}, "execution_count": 2, "metadata": {}, "output_type": "execute_result"}], "source": ["fib(6)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["It would be better if we could somehow \"store\" these results, so if we have calculated `fib(4)` and `fib(3)` before, we could simply recall the these values when calculating `fib(5) = fib(4) + fib(3)` instead of recalculating them.\n", "\n", "This concept of improving the efficiency of our code by caching pre-calculated values so they do not need to be re-calcualted every time, is called \"memoization\""]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can approach this using a simple class and a dictionary that stores any Fibonacci number that's already been calculated:"]}, {"cell_type": "code", "execution_count": 3, "metadata": {"collapsed": true}, "outputs": [], "source": ["class Fib:\n", "    def __init__(self):\n", "        self.cache = {1: 1, 2: 1}\n", "    \n", "    def fib(self, n):\n", "        if n not in self.cache:\n", "            print('Calculating fib({0})'.format(n))\n", "            self.cache[n] = self.fib(n-1) + self.fib(n-2)\n", "        return self.cache[n]"]}, {"cell_type": "code", "execution_count": 4, "metadata": {"collapsed": true}, "outputs": [], "source": ["f = Fib()"]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"data": {"text/plain": ["1"]}, "execution_count": 5, "metadata": {}, "output_type": "execute_result"}], "source": ["f.fib(1)"]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Calculating fib(6)\n", "Calculating fib(5)\n", "Calculating fib(4)\n", "Calculating fib(3)\n"]}, {"data": {"text/plain": ["8"]}, "execution_count": 6, "metadata": {}, "output_type": "execute_result"}], "source": ["f.fib(6)"]}, {"cell_type": "code", "execution_count": 7, "metadata": {"scrolled": true}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Calculating fib(7)\n"]}, {"data": {"text/plain": ["13"]}, "execution_count": 7, "metadata": {}, "output_type": "execute_result"}], "source": ["f.fib(7)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's see how we could rewrite this using a closure:"]}, {"cell_type": "code", "execution_count": 8, "metadata": {"collapsed": true}, "outputs": [], "source": ["def fib():\n", "    cache = {1: 1, 2: 2}\n", "    \n", "    def calc_fib(n):\n", "        if n not in cache:\n", "            print('Calculating fib({0})'.format(n))\n", "            cache[n] = calc_fib(n-1) + calc_fib(n-2)\n", "        return cache[n]\n", "    \n", "    return calc_fib"]}, {"cell_type": "code", "execution_count": 9, "metadata": {}, "outputs": [], "source": ["f = fib()"]}, {"cell_type": "code", "execution_count": 10, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Calculating fib(10)\n", "Calculating fib(9)\n", "Calculating fib(8)\n", "Calculating fib(7)\n", "Calculating fib(6)\n", "Calculating fib(5)\n", "Calculating fib(4)\n", "Calculating fib(3)\n"]}, {"data": {"text/plain": ["89"]}, "execution_count": 10, "metadata": {}, "output_type": "execute_result"}], "source": ["f(10)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now let's see how we would implement this using a decorator:"]}, {"cell_type": "code", "execution_count": 11, "metadata": {"collapsed": true}, "outputs": [], "source": ["from functools import wraps\n", "\n", "def memoize_fib(fn):\n", "    cache = dict()\n", "    \n", "    @wraps(fn)\n", "    def inner(n):\n", "        if n not in cache:\n", "            cache[n] = fn(n)\n", "        return cache[n]\n", "    \n", "    return inner"]}, {"cell_type": "code", "execution_count": 12, "metadata": {"collapsed": true}, "outputs": [], "source": ["@memoize_fib\n", "def fib(n):\n", "    print ('Calculating fib({0})'.format(n))\n", "    return 1 if n < 3 else fib(n-1) + fib(n-2)"]}, {"cell_type": "code", "execution_count": 13, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Calculating fib(3)\n", "Calculating fib(2)\n", "Calculating fib(1)\n"]}, {"data": {"text/plain": ["2"]}, "execution_count": 13, "metadata": {}, "output_type": "execute_result"}], "source": ["fib(3)"]}, {"cell_type": "code", "execution_count": 14, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Calculating fib(10)\n", "Calculating fib(9)\n", "Calculating fib(8)\n", "Calculating fib(7)\n", "Calculating fib(6)\n", "Calculating fib(5)\n", "Calculating fib(4)\n"]}, {"data": {"text/plain": ["55"]}, "execution_count": 14, "metadata": {}, "output_type": "execute_result"}], "source": ["fib(10)"]}, {"cell_type": "code", "execution_count": 15, "metadata": {}, "outputs": [{"data": {"text/plain": ["8"]}, "execution_count": 15, "metadata": {}, "output_type": "execute_result"}], "source": ["fib(6)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see, we are hitting the cache when the values are available.\n", "\n", "Now, we made our memoization decorator \"hardcoded\" to single argument functions - we could make it more generic.\n", "\n", "For example, to handle an arbitrary number of positional arguments and keyword-only arguments we could do the following:"]}, {"cell_type": "code", "execution_count": 44, "metadata": {"collapsed": true}, "outputs": [], "source": ["def memoize(fn):\n", "    cache = dict()\n", "    \n", "    @wraps(fn)\n", "    def inner(*args):\n", "        if args not in cache:\n", "            cache[args] = fn(*args)\n", "        return cache[args]\n", "    \n", "    return inner"]}, {"cell_type": "code", "execution_count": 17, "metadata": {"collapsed": true}, "outputs": [], "source": ["@memoize\n", "def fib(n):\n", "    print ('Calculating fib({0})'.format(n))\n", "    return 1 if n < 3 else fib(n-1) + fib(n-2)"]}, {"cell_type": "code", "execution_count": 18, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Calculating fib(6)\n", "Calculating fib(5)\n", "Calculating fib(4)\n", "Calculating fib(3)\n", "Calculating fib(2)\n", "Calculating fib(1)\n"]}, {"data": {"text/plain": ["8"]}, "execution_count": 18, "metadata": {}, "output_type": "execute_result"}], "source": ["fib(6)"]}, {"cell_type": "code", "execution_count": 19, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Calculating fib(7)\n"]}, {"data": {"text/plain": ["13"]}, "execution_count": 19, "metadata": {}, "output_type": "execute_result"}], "source": ["fib(7)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Of course, with this rather generic memoization decorator we can memoize other functions too:"]}, {"cell_type": "code", "execution_count": 20, "metadata": {"collapsed": true}, "outputs": [], "source": ["def fact(n):\n", "    print('Calculating {0}!'.format(n))\n", "    return 1 if n < 2 else n * fact(n-1)"]}, {"cell_type": "code", "execution_count": 21, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Calculating 5!\n", "Calculating 4!\n", "Calculating 3!\n", "Calculating 2!\n", "Calculating 1!\n"]}, {"data": {"text/plain": ["120"]}, "execution_count": 21, "metadata": {}, "output_type": "execute_result"}], "source": ["fact(5)"]}, {"cell_type": "code", "execution_count": 22, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Calculating 5!\n", "Calculating 4!\n", "Calculating 3!\n", "Calculating 2!\n", "Calculating 1!\n"]}, {"data": {"text/plain": ["120"]}, "execution_count": 22, "metadata": {}, "output_type": "execute_result"}], "source": ["fact(5)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["And memoizing it:"]}, {"cell_type": "code", "execution_count": 23, "metadata": {"collapsed": true}, "outputs": [], "source": ["@memoize\n", "def fact(n):\n", "    print('Calculating {0}!'.format(n))\n", "    return 1 if n < 2 else n * fact(n-1)"]}, {"cell_type": "code", "execution_count": 24, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Calculating 6!\n", "Calculating 5!\n", "Calculating 4!\n", "Calculating 3!\n", "Calculating 2!\n", "Calculating 1!\n"]}, {"data": {"text/plain": ["720"]}, "execution_count": 24, "metadata": {}, "output_type": "execute_result"}], "source": ["fact(6)"]}, {"cell_type": "code", "execution_count": 25, "metadata": {}, "outputs": [{"data": {"text/plain": ["720"]}, "execution_count": 25, "metadata": {}, "output_type": "execute_result"}], "source": ["fact(6)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Our simple memoizer has a drawback however:\n", "* the cache size is unbounded - probably not a good thing! In general we want to limit the cache to a certain number of entries, balancing computational efficiency vs memory utilization.\n", "* we are not handling **kwargs"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Memoization is such a common thing to do that Python actually has a memoization decorator built for us!\n", "\n", "It's in the, you guessed it, **functools** module, and is called **lru_cache** and is going to be quite a bit more efficient compared to the rudimentary memoization example we did above.\n", "\n", "[LRU Cache = Least Recently Used caching: since the cache is not unlimited, at some point cached entries need to be discarded, and the least recently used entries are discarded first]"]}, {"cell_type": "code", "execution_count": 26, "metadata": {"collapsed": true}, "outputs": [], "source": ["from functools import lru_cache"]}, {"cell_type": "code", "execution_count": 27, "metadata": {"collapsed": true}, "outputs": [], "source": ["@lru_cache()\n", "def fact(n):\n", "    print(\"Calculating fact({0})\".format(n))\n", "    return 1 if n < 2 else n * fact(n-1)"]}, {"cell_type": "code", "execution_count": 28, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Calculating fact(5)\n", "Calculating fact(4)\n", "Calculating fact(3)\n", "Calculating fact(2)\n", "Calculating fact(1)\n"]}, {"data": {"text/plain": ["120"]}, "execution_count": 28, "metadata": {}, "output_type": "execute_result"}], "source": ["fact(5)"]}, {"cell_type": "code", "execution_count": 29, "metadata": {}, "outputs": [{"data": {"text/plain": ["24"]}, "execution_count": 29, "metadata": {}, "output_type": "execute_result"}], "source": ["fact(4)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see, `fact(4)` was returned via a cached entry!"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Same thing with our Fibonacci function:"]}, {"cell_type": "code", "execution_count": 30, "metadata": {}, "outputs": [], "source": ["@lru_cache()\n", "def fib(n):\n", "    print(\"Calculating fib({0})\".format(n))\n", "    return 1 if n < 3 else fib(n-1) + fib(n-2)"]}, {"cell_type": "code", "execution_count": 31, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Calculating fib(6)\n", "Calculating fib(5)\n", "Calculating fib(4)\n", "Calculating fib(3)\n", "Calculating fib(2)\n", "Calculating fib(1)\n"]}, {"data": {"text/plain": ["8"]}, "execution_count": 31, "metadata": {}, "output_type": "execute_result"}], "source": ["fib(6)"]}, {"cell_type": "code", "execution_count": 32, "metadata": {}, "outputs": [{"data": {"text/plain": ["5"]}, "execution_count": 32, "metadata": {}, "output_type": "execute_result"}], "source": ["fib(5)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Recall from a few videos back that we timed the calculation for Fibonacci numbers. Calculating fib(35) took several seconds - every time..."]}, {"cell_type": "code", "execution_count": 33, "metadata": {"collapsed": true}, "outputs": [], "source": ["from time import perf_counter"]}, {"cell_type": "code", "execution_count": 34, "metadata": {"collapsed": true}, "outputs": [], "source": ["def fib_no_memo(n):\n", "    return 1 if n < 3 else fib_no_memo(n-1) + fib_no_memo(n-2)"]}, {"cell_type": "code", "execution_count": 35, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["result=9227465, elapsed: 2.939012289158911s\n"]}], "source": ["start = perf_counter()\n", "result = fib_no_memo(35)\n", "print(\"result={0}, elapsed: {1}s\".format(result, perf_counter() - start))"]}, {"cell_type": "code", "execution_count": 36, "metadata": {"collapsed": true}, "outputs": [], "source": ["@lru_cache()\n", "def fib_memo(n):\n", "    return 1 if n < 3 else fib_memo(n-1) + fib_memo(n-2)"]}, {"cell_type": "code", "execution_count": 37, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["result=9227465, elapsed: 9.83349429017899e-05s\n"]}], "source": ["start = perf_counter()\n", "result = fib_memo(35)\n", "print(\"result={0}, elapsed: {1}s\".format(result, perf_counter() - start))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["And if we make the calls again:"]}, {"cell_type": "code", "execution_count": 38, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["result=9227465, elapsed: 2.782454120518548s\n"]}], "source": ["start = perf_counter()\n", "result = fib_no_memo(35)\n", "print(\"result={0}, elapsed: {1}s\".format(result, perf_counter() - start))"]}, {"cell_type": "code", "execution_count": 39, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["result=9227465, elapsed: 5.6617088337596044e-05s\n"]}], "source": ["start = perf_counter()\n", "result = fib_memo(35)\n", "print(\"result={0}, elapsed: {1}s\".format(result, perf_counter() - start))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["You may have noticed that the `lru_cache` decorator was implemented using `()` - we'll see more on this later, but that's because decorators can themselves have parameters (beyond the function being decorated)."]}, {"cell_type": "markdown", "metadata": {}, "source": ["One of the arguments to the `lru_cache` decorator is the size of the cache - it defaults to 128 items, but we can easily change this - for performance reasons use powers of 2 for the cache size (or None for unbounded cache):"]}, {"cell_type": "code", "execution_count": 40, "metadata": {}, "outputs": [], "source": ["@lru_cache(maxsize=8)\n", "def fib(n):\n", "    print(\"Calculating fib({0})\".format(n))\n", "    return 1 if n < 3 else fib(n-1) + fib(n-2)"]}, {"cell_type": "code", "execution_count": 41, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Calculating fib(10)\n", "Calculating fib(9)\n", "Calculating fib(8)\n", "Calculating fib(7)\n", "Calculating fib(6)\n", "Calculating fib(5)\n", "Calculating fib(4)\n", "Calculating fib(3)\n", "Calculating fib(2)\n", "Calculating fib(1)\n"]}, {"data": {"text/plain": ["55"]}, "execution_count": 41, "metadata": {}, "output_type": "execute_result"}], "source": ["fib(10)"]}, {"cell_type": "code", "execution_count": 42, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Calculating fib(20)\n", "Calculating fib(19)\n", "Calculating fib(18)\n", "Calculating fib(17)\n", "Calculating fib(16)\n", "Calculating fib(15)\n", "Calculating fib(14)\n", "Calculating fib(13)\n", "Calculating fib(12)\n", "Calculating fib(11)\n"]}, {"data": {"text/plain": ["6765"]}, "execution_count": 42, "metadata": {}, "output_type": "execute_result"}], "source": ["fib(20)"]}, {"cell_type": "code", "execution_count": 43, "metadata": {"scrolled": true}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Calculating fib(10)\n", "Calculating fib(9)\n", "Calculating fib(8)\n", "Calculating fib(7)\n", "Calculating fib(6)\n", "Calculating fib(5)\n", "Calculating fib(4)\n", "Calculating fib(3)\n", "Calculating fib(2)\n", "Calculating fib(1)\n"]}, {"data": {"text/plain": ["55"]}, "execution_count": 43, "metadata": {}, "output_type": "execute_result"}], "source": ["fib(10)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["You'll not how Python had to recalculate `fib` for `10, 9,` etc. This is because the cache can only contain 10 items, so when we calculated `fib(20)`, it stored fib for `20, 19, ..., 11` (10 items) and therefore the oldest items fib `10, 9, ..., 1` were removed from the cache to make space."]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": []}, {"cell_type": "markdown", "metadata": {}, "source": ["### Decorators 2"]}, {"cell_type": "markdown", "metadata": {"collapsed": true}, "source": ["We have seen how to create some simple and not so simple decorators.\n", "\n", "However we have also been using built-in decorators that can accept parameters, such as `wraps` and `lru_cache`.\n", "\n", "This can be quite useful and we can accomplish the same thing ourselves."]}, {"cell_type": "markdown", "metadata": {}, "source": ["First recall our original timer decorator from an earlier video (Decorator Application - Timer):"]}, {"cell_type": "code", "execution_count": 1, "metadata": {"collapsed": true}, "outputs": [], "source": ["def timed(fn):\n", "    from time import perf_counter\n", "    \n", "    def inner(*args, **kwargs):\n", "        start = perf_counter()\n", "        result = fn(*args, **kwargs)\n", "        end = perf_counter()\n", "        elapsed = end - start\n", "        print('Run time: {0:.6f}s'.format(elapsed))\n", "        return result\n", "    \n", "    return inner"]}, {"cell_type": "code", "execution_count": 2, "metadata": {"collapsed": true}, "outputs": [], "source": ["def calc_fib_recurse(n):\n", "    return 1 if n < 3 else calc_fib_recurse(n-1) + calc_fib_recurse(n-2)\n", "\n", "def fib(n):\n", "    return calc_fib_recurse(n)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can decorate our Fibonacci function using the **@** syntax, or the longer syntax as follows:"]}, {"cell_type": "code", "execution_count": 3, "metadata": {"collapsed": true}, "outputs": [], "source": ["fib = timed(fib)"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Run time: 0.255260s\n"]}, {"data": {"text/plain": ["832040"]}, "execution_count": 4, "metadata": {}, "output_type": "execute_result"}], "source": ["fib(30)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's modify this so the timer runs the function multiple times and calculates the average run time:"]}, {"cell_type": "code", "execution_count": 5, "metadata": {"collapsed": true}, "outputs": [], "source": ["def timed(fn):\n", "    from time import perf_counter\n", "\n", "    def inner(*args, **kwargs):\n", "        total_elapsed = 0\n", "        for i in range(10):\n", "            start = perf_counter()\n", "            result = fn(*args, **kwargs)\n", "            end = perf_counter()\n", "            total_elapsed += (perf_counter() - start)\n", "        avg_elapsed = total_elapsed / 10\n", "        print('Avg Run time: {0:.6f}s'.format(avg_elapsed))\n", "        return result\n", "    \n", "    return inner"]}, {"cell_type": "markdown", "metadata": {}, "source": ["And again we decorate it using the long syntax:"]}, {"cell_type": "code", "execution_count": 6, "metadata": {"collapsed": true}, "outputs": [], "source": ["def fib(n):\n", "    return calc_fib_recurse(n)\n", "\n", "fib = timed(fib)"]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Avg Run time: 0.098860s\n"]}, {"data": {"text/plain": ["317811"]}, "execution_count": 7, "metadata": {}, "output_type": "execute_result"}], "source": ["fib(28)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But that value of 10 has been hardcoded. Let's make it a parameter instead."]}, {"cell_type": "code", "execution_count": 8, "metadata": {"collapsed": true}, "outputs": [], "source": ["def timed(fn, num_reps):\n", "    from time import perf_counter\n", "    \n", "    def inner(*args, **kwargs):\n", "        total_elapsed = 0\n", "        for i in range(num_reps):\n", "            start = perf_counter()\n", "            result = fn(*args, **kwargs)\n", "            end = perf_counter()\n", "            total_elapsed += (perf_counter() - start)\n", "        avg_elapsed = total_elapsed / num_reps\n", "        print('Avg Run time: {0:.6f}s ({1} reps)'.format(avg_elapsed,\n", "                                                        num_reps))\n", "        return result\n", "    \n", "    return inner"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now to decorate our Fibonacci function we **have** to use the long syntax (as we saw in the lecture, the **@** syntax will not work):"]}, {"cell_type": "code", "execution_count": 9, "metadata": {"collapsed": true}, "outputs": [], "source": ["def fib(n):\n", "    return calc_fib_recurse(n)\n", "\n", "fib = timed(fib, 5)"]}, {"cell_type": "code", "execution_count": 10, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Avg Run time: 0.095708s (5 reps)\n"]}, {"data": {"text/plain": ["317811"]}, "execution_count": 10, "metadata": {}, "output_type": "execute_result"}], "source": ["fib(28)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The problem is that we cannot use the `@` decorator syntax because when using that syntax Python passes a **single** argument to the decorator: the function we are decorating - nothing else."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Of course we could just use what we did above, but the decorator syntax is kind of neat, so it would be nice to retain the ability to use it."]}, {"cell_type": "markdown", "metadata": {}, "source": ["We just need to change our thinking a little bit to do this:\n", "\n", "First, when we see the following syntax:\n", "\n", "`\n", "@dec\n", "def my_func():\n", "    pass\n", "`\n", "\n", "we see that `dec` must be a function that takes a single argument, the function being decorated.\n", "\n", "You'll note that `dec` is just a function, but we do not **call** `dec` when we decorate `my_func`, we simply use the label `dec`.\n", "\n", "Then Python does:\n", "\n", "`\n", "my_func = dec(my_func)\n", "`"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's try a concrete example:"]}, {"cell_type": "code", "execution_count": 11, "metadata": {"collapsed": true}, "outputs": [], "source": ["def dec(fn):\n", "    print (\"running dec\")\n", "    \n", "    def inner(*args, **kwargs):\n", "        print(\"running inner\")\n", "        return fn(*args, **kwargs)\n", "              \n", "    return inner"]}, {"cell_type": "code", "execution_count": 12, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["running dec\n"]}], "source": ["@dec\n", "def my_func():\n", "    print('running my_func')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As we can see, when we decorated `my_func`, the `dec` function was **called** at that time.\n", "\n", "(Because Python did this: \n", "\n", "`my_func = dec(my_func)` \n", "\n", "so `dec` was called)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["And when we now call `my_func`, we see that the `inner` function is called, followed by the original `my_func`"]}, {"cell_type": "code", "execution_count": 13, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["running inner\n", "running my_func\n"]}], "source": ["my_func()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But what if `dec` was not the decorator itself, but instead created and returned a decorator?\n", "\n", "Let's see how we might do this:"]}, {"cell_type": "code", "execution_count": 14, "metadata": {"collapsed": true}, "outputs": [], "source": ["def dec_factory():\n", "    print('running dec_factory')\n", "    def dec(fn):\n", "        print('running dec')\n", "        def inner(*args, **kwargs):\n", "            print('running inner')\n", "            return fn(*args, **kwargs)\n", "        return inner\n", "    return dec"]}, {"cell_type": "markdown", "metadata": {}, "source": ["So as you can see, calling `dec_generator()` will return that `dec` function which is our decorator:"]}, {"cell_type": "code", "execution_count": 15, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["running dec_factory\n", "running dec\n"]}], "source": ["@dec_factory()\n", "def my_func(a, b):\n", "    print(a, b)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["You can see that both `dec_generator` and `dec` were already called."]}, {"cell_type": "code", "execution_count": 16, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["running inner\n", "10 20\n"]}], "source": ["my_func(10, 20)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["And there you go, all we did is basically create a decorator by calling a function (`dec_factory`) and use the return value of that call (the `dec` function) as our actual decorator."]}, {"cell_type": "markdown", "metadata": {}, "source": ["We could have done the decoration this way too:"]}, {"cell_type": "code", "execution_count": 17, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["running dec_factory\n"]}], "source": ["dec = dec_factory()"]}, {"cell_type": "code", "execution_count": 18, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["running dec\n"]}], "source": ["@dec\n", "def my_func():\n", "    print('running my_func')"]}, {"cell_type": "code", "execution_count": 19, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["running inner\n", "running my_func\n"]}], "source": ["my_func()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Or even this way:"]}, {"cell_type": "code", "execution_count": 20, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["running dec_factory\n", "running dec\n"]}], "source": ["dec = dec_factory()\n", "\n", "def my_func():\n", "    print('running my_func')\n", "\n", "my_func = dec(my_func)"]}, {"cell_type": "code", "execution_count": 21, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["running inner\n", "running my_func\n"]}], "source": ["my_func()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Of course we could even decorate it this way using a single statement:"]}, {"cell_type": "code", "execution_count": 22, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["running dec_factory\n", "running dec\n"]}], "source": ["def my_func():\n", "    print('running my_func')\n", "\n", "my_func = dec_factory()(my_func)"]}, {"cell_type": "code", "execution_count": 23, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["running inner\n", "running my_func\n"]}], "source": ["my_func()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["OK, so now we have decorated our function using, not a decorator, but a decorator factory as follows:"]}, {"cell_type": "code", "execution_count": 24, "metadata": {"collapsed": true}, "outputs": [], "source": ["def dec_factory():\n", "    def dec(fn):\n", "        def inner(*args, **kwargs):\n", "            print('running decorator inner')\n", "            return fn(*args, **kwargs)\n", "        return inner\n", "    return dec"]}, {"cell_type": "code", "execution_count": 25, "metadata": {"collapsed": true}, "outputs": [], "source": ["@dec_factory()\n", "def my_func(a, b):\n", "    return a + b"]}, {"cell_type": "code", "execution_count": 26, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["running decorator inner\n"]}, {"data": {"text/plain": ["30"]}, "execution_count": 26, "metadata": {}, "output_type": "execute_result"}], "source": ["my_func(10, 20)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["You should note that in this approach, we are **calling** `dec_factory()`, [note the parentheses `()`], and **then** using the return value (a decorator) to decorate our function."]}, {"cell_type": "markdown", "metadata": {}, "source": ["So, we could pass arguments as we do so without affecting the final outcome. In fact we can even access them from anywhere inside `dec_factory`, including any of the nested functions! \n", "\n", "Let's try this:"]}, {"cell_type": "code", "execution_count": 27, "metadata": {"collapsed": true}, "outputs": [], "source": ["def dec_factory(a, b):\n", "    def dec(fn):\n", "        def inner(*args, **kwargs):\n", "            print('running decorator inner')\n", "            print('free vars: ', a, b)  # a and b are free variables!\n", "            return fn(*args, **kwargs)\n", "        return inner\n", "    return dec"]}, {"cell_type": "code", "execution_count": 28, "metadata": {"collapsed": true}, "outputs": [], "source": ["@dec_factory(10, 20)\n", "def my_func():\n", "    print('python rocks')"]}, {"cell_type": "code", "execution_count": 29, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["running decorator inner\n", "free vars:  10 20\n", "python rocks\n"]}], "source": ["my_func()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["And this is how we can create decorators with parameters. We do not directly create a decorator, instead we use an outer function that returns a decorator when called, and pass arguments to that outer function, which the decorator and its inner function can of course access as nonlocal (free) variables."]}, {"cell_type": "markdown", "metadata": {}, "source": ["So now, let's go back to our original problem where we wanted our timing decorator to run a number of loops which could be specified as a parameter when decorating the function we want to time.\n", "\n", "Here it is again:"]}, {"cell_type": "code", "execution_count": 30, "metadata": {"collapsed": true}, "outputs": [], "source": ["def timed(fn, num_reps):\n", "    from time import perf_counter\n", "    \n", "    def inner(*args, **kwargs):\n", "        total_elapsed = 0\n", "        for i in range(num_reps):\n", "            start = perf_counter()\n", "            result = fn(*args, **kwargs)\n", "            end = perf_counter()\n", "            total_elapsed += (perf_counter() - start)\n", "        avg_elapsed = total_elapsed / num_reps\n", "        print('Avg Run time: {0:.6f}s ({1} reps)'.format(avg_elapsed,\n", "                                                        num_reps))\n", "        return result\n", "    \n", "    return inner"]}, {"cell_type": "markdown", "metadata": {}, "source": ["So, all we need to do is create an outer function around our timed decorator, and pass the `num_reps` argument to that outer function instead:"]}, {"cell_type": "code", "execution_count": 31, "metadata": {"collapsed": true}, "outputs": [], "source": ["def timed_factory(num_reps=1):\n", "    def timed(fn):\n", "        from time import perf_counter\n", "\n", "        def inner(*args, **kwargs):\n", "            total_elapsed = 0\n", "            for i in range(num_reps):\n", "                start = perf_counter()\n", "                result = fn(*args, **kwargs)\n", "                end = perf_counter()\n", "                total_elapsed += (perf_counter() - start)\n", "            avg_elapsed = total_elapsed / num_reps\n", "            print('Avg Run time: {0:.6f}s ({1} reps)'.format(avg_elapsed,\n", "                                                            num_reps))\n", "            return result\n", "        return inner\n", "    return timed    "]}, {"cell_type": "code", "execution_count": 32, "metadata": {"collapsed": true}, "outputs": [], "source": ["@timed_factory(5)\n", "def fib(n):\n", "    return calc_fib_recurse(n)"]}, {"cell_type": "code", "execution_count": 33, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Avg Run time: 0.249934s (5 reps)\n"]}, {"data": {"text/plain": ["832040"]}, "execution_count": 33, "metadata": {}, "output_type": "execute_result"}], "source": ["fib(30)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Just to put the finishing touch on this, we probably don't want to have our outer function named the way it is (`timed_factory`). Instead we probably just want to call it `timed`. So lets just do this final part:"]}, {"cell_type": "code", "execution_count": 34, "metadata": {"collapsed": true}, "outputs": [], "source": ["from functools import wraps\n", "\n", "def timed(num_reps=1):\n", "    def decorator(fn):\n", "        from time import perf_counter\n", "\n", "        @wraps(fn)\n", "        def inner(*args, **kwargs):\n", "            total_elapsed = 0\n", "            for i in range(num_reps):\n", "                start = perf_counter()\n", "                result = fn(*args, **kwargs)\n", "                end = perf_counter()\n", "                total_elapsed += (perf_counter() - start)\n", "            avg_elapsed = total_elapsed / num_reps\n", "            print('Avg Run time: {0:.6f}s ({1} reps)'.format(avg_elapsed,\n", "                                                            num_reps))\n", "            return result\n", "        return inner\n", "    return decorator  "]}, {"cell_type": "code", "execution_count": 35, "metadata": {"collapsed": true}, "outputs": [], "source": ["@timed(5)\n", "def fib(n):\n", "    return calc_fib_recurse(n)"]}, {"cell_type": "code", "execution_count": 36, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Avg Run time: 0.253744s (5 reps)\n"]}, {"data": {"text/plain": ["832040"]}, "execution_count": 36, "metadata": {}, "output_type": "execute_result"}], "source": ["fib(30)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Decorator Application (Decorator Class)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["If you recalls how we wrote a parameterized decorator, we had to write a decorator factory that took in the arguments for our decorator and then returned the decorator (which could reference the arguments as free variables).\n", "\n", "Very simply:"]}, {"cell_type": "code", "execution_count": 1, "metadata": {"collapsed": true}, "outputs": [], "source": ["def my_dec(a, b):\n", "    def dec(fn):\n", "        def inner(*args, **kwargs):\n", "            print('decorated function called: a={0}, b={1}'.format(a, b))\n", "            return fn(*args, **kwargs)\n", "        return inner\n", "    return dec"]}, {"cell_type": "code", "execution_count": 2, "metadata": {"collapsed": true}, "outputs": [], "source": ["@my_dec(10, 20)\n", "def my_func(s):\n", "    print('hello {0}'.format(s))"]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["decorated function called: a=10, b=20\n", "hello world\n"]}], "source": ["my_func('world')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["So, our decorator factory was passed some arguments, and returned a callable which took one single parameter, the function being decorated, but also had access to the arguments passed to the factory."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now, recall that we can make our class instances callable, simply by implementing the `__call__` method.\n", "\n", "Here's a simple example:"]}, {"cell_type": "code", "execution_count": 4, "metadata": {"collapsed": true}, "outputs": [], "source": ["class MyClass:\n", "    def __init__(self, a, b):\n", "        self.a = a\n", "        self.b = b\n", "        \n", "    def __call__(self):\n", "        print('MyClass instance called: a={0}, b={1}'.format(self.a, self.b))"]}, {"cell_type": "code", "execution_count": 5, "metadata": {"collapsed": true}, "outputs": [], "source": ["my_class = MyClass(10, 20)"]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["MyClass instance called: a=10, b=20\n"]}], "source": ["my_class()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["So let's modify this just a bit, and have the `__call__` method be our decorator!"]}, {"cell_type": "code", "execution_count": 7, "metadata": {"collapsed": true}, "outputs": [], "source": ["class MyClass:\n", "    def __init__(self, a, b):\n", "        self.a = a\n", "        self.b = b\n", "        \n", "    def __call__(self, fn):\n", "        def inner(*args, **kwargs):\n", "            print('MyClass instance called: a={0}, b={1}'.format(self.a, self.b))\n", "            return fn(*args, **kwargs)\n", "        return inner"]}, {"cell_type": "markdown", "metadata": {}, "source": ["So, we can decorate our functions this way:"]}, {"cell_type": "code", "execution_count": 8, "metadata": {"collapsed": true}, "outputs": [], "source": ["@MyClass(10, 20)\n", "def my_func(s):\n", "    print('Hello {0}!'.format(s))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Remember that `@MyClass(10, 20)` returned an object of type `MyClass`. But  that object is itself callable, so we could do something like:\n", "\n", "``\n", "my_func = MyClass(10, 20)(my_func)\n", "``\n", "\n", "or, more simply\n", "\n", "``\n", "@MyClass(10, 20)\n", "def my_func(s):\n", "    print(s)\n", "``"]}, {"cell_type": "code", "execution_count": 9, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["MyClass instance called: a=10, b=20\n", "Hello Python!\n"]}], "source": ["my_func('Python')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["So as you can see, we can also use callable classes to decorate functions!"]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": []}, {"cell_type": "markdown", "metadata": {}, "source": ["### Decorator Application: Decorating Classes"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We have so far worked with decorating functions. This means we can decorate functions defined with a `def` statement (we can use the `@` syntax, or the long form). Since class methods are functions, they can be decorated too. Lambda expressions can also be decorated (using the long form)."]}, {"cell_type": "markdown", "metadata": {}, "source": ["But if you think about how our decorators work, they take a single parameter, a function, and return some other function - usually a closure that uses the original function that was passed as an argument."]}, {"cell_type": "markdown", "metadata": {}, "source": ["We could use the same concept to accept, not a function, but a class instead. We could reference that class inside our decorator, modify it, and then return that modified class."]}, {"cell_type": "markdown", "metadata": {}, "source": ["First we look at something called **monkey patching**. It boils down to modifying or extending our code at **run time**.\n", "\n", "For example we can modify or add attributes to classes at run time. Modules too.\n", "\n", "In Python, many of the classes we use can be modified at run time \n", "(built-ins like strings, lists, and so on, cannot).\n", "\n", "But classes written in Python, such as the ones we write, and even library classes, as long as they are written in Python, not C, can. For example `Fraction` in the `fractions` module can be monkey patched.\n", "\n", "Just because we can do something however, does not mean we should! Monkey patching can be extremely useful, but don't do it just because you can - as always there should be a real reason to do it, as we'll see in a bit.\n", "\n", "Also, in general it is a bad idea to monkey patch the special methods `__???__` (such as `__len__`) as this will often not work due to how these methods are searched for by Python."]}, {"cell_type": "code", "execution_count": 1, "metadata": {"collapsed": true}, "outputs": [], "source": ["from fractions import Fraction"]}, {"cell_type": "code", "execution_count": 2, "metadata": {"collapsed": true}, "outputs": [], "source": ["Fraction.speak = lambda self: 'This is a late parrot.'"]}, {"cell_type": "code", "execution_count": 3, "metadata": {"collapsed": true}, "outputs": [], "source": ["f = Fraction(2, 3)"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"data": {"text/plain": ["Fraction(2, 3)"]}, "execution_count": 4, "metadata": {}, "output_type": "execute_result"}], "source": ["f"]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"data": {"text/plain": ["'This is a late parrot.'"]}, "execution_count": 5, "metadata": {}, "output_type": "execute_result"}], "source": ["f.speak()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Yes, this is obviously nonsense, but you get the idea that you can add attributes to classes even if you do not have direct control over the class, or after your class has been defined."]}, {"cell_type": "markdown", "metadata": {}, "source": ["If you want a more useful method, how about one that tells us if the Fraction is an integral number? (i.e. denominator is `1`)"]}, {"cell_type": "code", "execution_count": 6, "metadata": {"collapsed": true}, "outputs": [], "source": ["Fraction.is_integral = lambda self: self.denominator == 1"]}, {"cell_type": "code", "execution_count": 7, "metadata": {"collapsed": true}, "outputs": [], "source": ["f1 = Fraction(1, 2)\n", "f2 = Fraction(10, 5)"]}, {"cell_type": "code", "execution_count": 8, "metadata": {}, "outputs": [{"data": {"text/plain": ["False"]}, "execution_count": 8, "metadata": {}, "output_type": "execute_result"}], "source": ["f1.is_integral()"]}, {"cell_type": "code", "execution_count": 9, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 9, "metadata": {}, "output_type": "execute_result"}], "source": ["f2.is_integral()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now, we can make this change to the class by calling a function to do it instead:"]}, {"cell_type": "code", "execution_count": 10, "metadata": {"collapsed": true}, "outputs": [], "source": ["def dec_speak(cls):\n", "    cls.speak = lambda self: 'This is a very late parrot.'\n", "    return cls"]}, {"cell_type": "code", "execution_count": 11, "metadata": {"collapsed": true}, "outputs": [], "source": ["Fraction = dec_speak(Fraction)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["_(Hopefully the above code reminds you of decorators.)_"]}, {"cell_type": "code", "execution_count": 12, "metadata": {"collapsed": true}, "outputs": [], "source": ["f = Fraction(10, 2)"]}, {"cell_type": "code", "execution_count": 13, "metadata": {}, "outputs": [{"data": {"text/plain": ["'This is a very late parrot.'"]}, "execution_count": 13, "metadata": {}, "output_type": "execute_result"}], "source": ["f.speak()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can use that function to decorate our custom classes too, using the short **@** syntax too."]}, {"cell_type": "code", "execution_count": 14, "metadata": {"collapsed": true}, "outputs": [], "source": ["@dec_speak\n", "class Parrot:\n", "    def __init__(self):\n", "        self.state = 'late'"]}, {"cell_type": "code", "execution_count": 15, "metadata": {"collapsed": true}, "outputs": [], "source": ["polly = Parrot()"]}, {"cell_type": "code", "execution_count": 16, "metadata": {}, "outputs": [{"data": {"text/plain": ["'This is a very late parrot.'"]}, "execution_count": 16, "metadata": {}, "output_type": "execute_result"}], "source": ["polly.speak()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Using this technique we could for example add a useful *reciprocal* attribute to the Fraction class, but of course since it would probably be a one time kind of thing (how many Fraction classes are there that you will want to add a reciprocal to after all), there's no need for decorators. Decorators  are useful when they are able to be reused in more general ways."]}, {"cell_type": "code", "execution_count": 17, "metadata": {"collapsed": true}, "outputs": [], "source": ["Fraction.recip = lambda self: Fraction(self.denominator, self.numerator)"]}, {"cell_type": "code", "execution_count": 18, "metadata": {"collapsed": true}, "outputs": [], "source": ["f = Fraction(2,3)"]}, {"cell_type": "code", "execution_count": 19, "metadata": {}, "outputs": [{"data": {"text/plain": ["Fraction(2, 3)"]}, "execution_count": 19, "metadata": {}, "output_type": "execute_result"}], "source": ["f"]}, {"cell_type": "code", "execution_count": 20, "metadata": {}, "outputs": [{"data": {"text/plain": ["Fraction(3, 2)"]}, "execution_count": 20, "metadata": {}, "output_type": "execute_result"}], "source": ["f.recip()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["These example are quite trivial, and not very useful. \n", "\n", "So why bring this up? \n", "\n", "Because this same technique can be used for more interesting things."]}, {"cell_type": "markdown", "metadata": {}, "source": ["As a first example, let's say you typically like to inspect various properties of an object for debugging purposes, maybe the memory address, it's current state (property values), and the time at which the debug info was generated."]}, {"cell_type": "code", "execution_count": 21, "metadata": {"collapsed": true}, "outputs": [], "source": ["from datetime import datetime, timezone"]}, {"cell_type": "code", "execution_count": 22, "metadata": {"collapsed": true}, "outputs": [], "source": ["def debug_info(cls):\n", "    def info(self):\n", "        results = []\n", "        results.append('time: {0}'.format(datetime.now(timezone.utc)))\n", "        results.append('class: {0}'.format(self.__class__.__name__))\n", "        results.append('id: {0}'.format(hex(id(self))))\n", "        \n", "        if vars(self):\n", "            for k, v in vars(self).items():\n", "                results.append('{0}: {1}'.format(k, v))\n", "        \n", "        # we have not covered lists, the extend method and generators,\n", "        # but note that a more Pythonic way to do this would be:\n", "        #if vars(self):\n", "        #    results.extend('{0}: {1}'.format(k, v) \n", "        #                   for k, v in vars(self).items())\n", "        \n", "        return results\n", "    \n", "    cls.debug = info\n", "    \n", "    return cls"]}, {"cell_type": "code", "execution_count": 23, "metadata": {"collapsed": true}, "outputs": [], "source": ["@debug_info\n", "class Person:\n", "    def __init__(self, name, birth_year):\n", "        self.name = name\n", "        self.birth_year = birth_year\n", "        \n", "    def say_hi():\n", "        return 'Hello there!'"]}, {"cell_type": "code", "execution_count": 24, "metadata": {"collapsed": true}, "outputs": [], "source": ["p1 = Person('John', 1939)"]}, {"cell_type": "code", "execution_count": 25, "metadata": {}, "outputs": [{"data": {"text/plain": ["['time: 2018-02-09 04:44:02.893951+00:00',\n", " 'class: Person',\n", " 'id: 0x2dfe29a4630',\n", " 'name: John',\n", " 'birth_year: 1939']"]}, "execution_count": 25, "metadata": {}, "output_type": "execute_result"}], "source": ["p1.debug()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["And of course we can decorate other classes this way too, not just a single class:"]}, {"cell_type": "code", "execution_count": 26, "metadata": {"collapsed": true}, "outputs": [], "source": ["@debug_info\n", "class Automobile:\n", "    def __init__(self, make, model, year, top_speed_mph):\n", "        self.make = make\n", "        self.model = model\n", "        self.year = year\n", "        self.top_speed_mph = top_speed_mph\n", "        self.current_speed = 0\n", "    \n", "    @property\n", "    def speed(self):\n", "        return self.current_speed\n", "    \n", "    @speed.setter\n", "    def speed(self, new_speed):\n", "        self.current_speed = new_speed"]}, {"cell_type": "code", "execution_count": 27, "metadata": {"collapsed": true}, "outputs": [], "source": ["s = Automobile('Ford', 'Model T', 1908, 45)"]}, {"cell_type": "code", "execution_count": 28, "metadata": {}, "outputs": [{"data": {"text/plain": ["['time: 2018-02-09 04:44:03.562898+00:00',\n", " 'class: Automobile',\n", " 'id: 0x2dfe29b3a58',\n", " 'make: Ford',\n", " 'model: Model T',\n", " 'year: 1908',\n", " 'top_speed_mph: 45',\n", " 'current_speed: 0']"]}, "execution_count": 28, "metadata": {}, "output_type": "execute_result"}], "source": ["s.debug()"]}, {"cell_type": "code", "execution_count": 29, "metadata": {"collapsed": true}, "outputs": [], "source": ["s.speed = 20"]}, {"cell_type": "code", "execution_count": 30, "metadata": {}, "outputs": [{"data": {"text/plain": ["['time: 2018-02-09 04:44:03.898085+00:00',\n", " 'class: Automobile',\n", " 'id: 0x2dfe29b3a58',\n", " 'make: Ford',\n", " 'model: Model T',\n", " 'year: 1908',\n", " 'top_speed_mph: 45',\n", " 'current_speed: 20']"]}, "execution_count": 30, "metadata": {}, "output_type": "execute_result"}], "source": ["s.debug()"]}, {"cell_type": "raw", "metadata": {}, "source": ["Let's look at another example where decorating an entire class could be useful."]}, {"cell_type": "code", "execution_count": 31, "metadata": {"collapsed": true}, "outputs": [], "source": ["from math import sqrt"]}, {"cell_type": "code", "execution_count": 32, "metadata": {"collapsed": true}, "outputs": [], "source": ["class Point:\n", "    def __init__(self, x, y):\n", "        self.x = x\n", "        self.y = y\n", "        \n", "    def __abs__(self):\n", "        return sqrt(self.x**2 + self.y**2)\n", "    \n", "    def __repr__(self):\n", "        return 'Point({0},{1})'.format(self.x, self.y)"]}, {"cell_type": "code", "execution_count": 33, "metadata": {"collapsed": true}, "outputs": [], "source": ["p1, p2, p3 = Point(2, 3), Point(2, 3), Point(0,0)"]}, {"cell_type": "code", "execution_count": 34, "metadata": {}, "outputs": [{"data": {"text/plain": ["3.605551275463989"]}, "execution_count": 34, "metadata": {}, "output_type": "execute_result"}], "source": ["abs(p1)"]}, {"cell_type": "code", "execution_count": 35, "metadata": {}, "outputs": [{"data": {"text/plain": ["(Point(2,3), Point(2,3))"]}, "execution_count": 35, "metadata": {}, "output_type": "execute_result"}], "source": ["p1, p2"]}, {"cell_type": "code", "execution_count": 36, "metadata": {}, "outputs": [{"data": {"text/plain": ["False"]}, "execution_count": 36, "metadata": {}, "output_type": "execute_result"}], "source": ["p1 == p2"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Hmm, we probably would have expected `p1` to be equal to `p2` since it has the same coordinates. But by default Python will compare memory addresses, since our class does not implement the `__eq__` method used for `==` comparisons."]}, {"cell_type": "code", "execution_count": 37, "metadata": {}, "outputs": [{"data": {"text/plain": ["(Point(2,3), Point(0,0))"]}, "execution_count": 37, "metadata": {}, "output_type": "execute_result"}], "source": ["p2, p3"]}, {"cell_type": "code", "execution_count": 38, "metadata": {}, "outputs": [{"ename": "TypeError", "evalue": "'>' not supported between instances of 'Point' and 'Point'", "output_type": "error", "traceback": ["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[1;31mTypeError\u001b[0m                                 Traceback (most recent call last)", "\u001b[1;32m<ipython-input-38-b46639986960>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[1;32m----> 1\u001b[1;33m \u001b[0mp2\u001b[0m \u001b[1;33m>\u001b[0m \u001b[0mp3\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m", "\u001b[1;31mTypeError\u001b[0m: '>' not supported between instances of 'Point' and 'Point'"]}], "source": ["p2 > p3"]}, {"cell_type": "markdown", "metadata": {}, "source": ["So, that class does not support the comparison operators such as `<`, `<=`, etc. \n", "\n", "Even `==` does not work as expected - it will use the memory address instead of using a comparison of the `x` and `y` coordinates as we might probably expect."]}, {"cell_type": "markdown", "metadata": {}, "source": ["For the `<` operator, we need our class to implement the `__lt__` method, and for `==` we need the `__eq__` method.\n", "\n", "Other comparison operators are supported by implementing a variety of functions such as `__le__` (`<=`), `__gt__` (`>`), `__ge__` (`>=`).\n", "\n", "We are going to add the `__lt__` and `__eq__` methods to our Point class.\n", "\n", "We will consider a Point object to be smaller than another one if it is closer to the origin (i.e. smaller magnitude)."]}, {"cell_type": "code", "execution_count": 39, "metadata": {"collapsed": true}, "outputs": [], "source": ["del Point\n", "\n", "class Point:\n", "    def __init__(self, x, y):\n", "        self.x = x\n", "        self.y = y\n", "        \n", "    def __abs__(self):\n", "        return sqrt(self.x**2 + self.y**2)\n", "    \n", "    def __eq__(self, other):\n", "        if isinstance(other, Point):\n", "            return self.x == other.x and self.y == other.y\n", "        else:\n", "            return NotImplemented\n", "            \n", "    def __lt__(self, other):\n", "        if isinstance(other, Point):\n", "            return abs(self) < abs(other)\n", "        else:\n", "            return NotImplemented\n", "        \n", "    def __repr__(self):\n", "        return '{0}({1},{2})'.format(self.__class__.__name__, self.x, self.y)"]}, {"cell_type": "code", "execution_count": 40, "metadata": {"collapsed": true}, "outputs": [], "source": ["p1, p2, p3 = Point(2, 3), Point(2, 3), Point(0,0)"]}, {"cell_type": "code", "execution_count": 41, "metadata": {}, "outputs": [{"data": {"text/plain": ["(Point(2,3), Point(2,3), True)"]}, "execution_count": 41, "metadata": {}, "output_type": "execute_result"}], "source": ["p1, p2, p1==p2"]}, {"cell_type": "code", "execution_count": 42, "metadata": {}, "outputs": [{"data": {"text/plain": ["(Point(2,3), Point(0,0), False)"]}, "execution_count": 42, "metadata": {}, "output_type": "execute_result"}], "source": ["p2, p3, p2==p3"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As we can see, `==` now works as expected"]}, {"cell_type": "code", "execution_count": 43, "metadata": {"collapsed": true}, "outputs": [], "source": ["p4 = Point(1, 2)"]}, {"cell_type": "code", "execution_count": 44, "metadata": {}, "outputs": [{"data": {"text/plain": ["(3.605551275463989, 2.23606797749979, False)"]}, "execution_count": 44, "metadata": {}, "output_type": "execute_result"}], "source": ["abs(p1), abs(p4), p1 < p4"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Great, so now we have `<` and `==` implemented. What about the rest of the operators: `<=`, `>`, `>=`?"]}, {"cell_type": "code", "execution_count": 45, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 45, "metadata": {}, "output_type": "execute_result"}], "source": ["p1 > p4"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Ooh, since we have implemented `<` and `==`, does this mean Python magically implemented a `>` operator (i.e. not < and not ==)?"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Not exactly! What happened is that since `p1` and `p4` are both points, running the comparison `p1 > p4` is really the same as evaluating `p4 < p1` - and Python did do that automatically for us.\n", "\n", "But it has not implemented any of the others, such as `>=` and `<=`:"]}, {"cell_type": "code", "execution_count": 46, "metadata": {}, "outputs": [{"ename": "TypeError", "evalue": "'<=' not supported between instances of 'Point' and 'Point'", "output_type": "error", "traceback": ["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[1;31mTypeError\u001b[0m                                 Traceback (most recent call last)", "\u001b[1;32m<ipython-input-46-80f9ea228203>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[1;32m----> 1\u001b[1;33m \u001b[0mp1\u001b[0m \u001b[1;33m<=\u001b[0m \u001b[0mp4\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m", "\u001b[1;31mTypeError\u001b[0m: '<=' not supported between instances of 'Point' and 'Point'"]}], "source": ["p1 <= p4"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now, although we could proceed in a similar way and define `>=`, `<=` and `>` using the same technique, observe that if `<` and `==` is defined then:\n", "\n", "* `a <= b` iff `a < b or a == b`\n", "* `a > b` iff `not(a<b) and a != b`\n", "* `a >= b` iff `not(a<b)`"]}, {"cell_type": "markdown", "metadata": {}, "source": ["So, to be quite generic we could create a decorator that will implement these last three operators as long as `==` and `<` are defined. We could then decorate **any** class that implements just those two operators."]}, {"cell_type": "code", "execution_count": 47, "metadata": {"collapsed": true}, "outputs": [], "source": ["def complete_ordering(cls):\n", "    if '__eq__' in dir(cls) and '__lt__' in dir(cls):\n", "        cls.__le__ = lambda self, other: self < other or self == other\n", "        cls.__gt__ = lambda self, other: not(self < other) and not (self == other)\n", "        cls.__ge__ = lambda self, other: not (self < other)\n", "    return cls"]}, {"cell_type": "markdown", "metadata": {}, "source": ["In reality, the code above is **NOT** a good implementation at all. We are not checking that the types are compatible and returning a `NotImplemented` result if appropriate. I am also using inline operators (`<` and `==`) instead of the dunder functions (`__lt__` and `__eq__`). I just kept it simple because we'll use a better alternative in a bit."]}, {"cell_type": "markdown", "metadata": {}, "source": ["For example, a better way to implement `__ge__` would be as follows:"]}, {"cell_type": "code", "execution_count": 48, "metadata": {"collapsed": true}, "outputs": [], "source": ["def ge_from_lt(self, other):\n", "    # self >= other iff not(other < self)\n", "    result = self.__lt__(other)\n", "    if result is NotImplemented:\n", "        return NotImplemented\n", "    else:\n", "        return not result"]}, {"cell_type": "markdown", "metadata": {}, "source": ["You may be wondering why I used `__lt__` instead of just using the `<` operator. This is because I want to actually look at the result of the operation without raising an exception if the operation is not implemented. The way I have the total ordering decorator implemented could cause an infinite loop because when I evaluate `self < other`, if an exception is raised, Python will reflect the evaluation to `other > self`, and if that raises an error as well, Python will try to reflect that operation too, and we get into an infinite loop (which eventually terminates in a stack overflow). This was actually a bug in Python's standard library implementation of a `complete_ordering` decorator (called `total_ordering`) that was resolved in 3.4."]}, {"cell_type": "code", "execution_count": 49, "metadata": {"collapsed": true}, "outputs": [], "source": ["class Point:\n", "    def __init__(self, x, y):\n", "        self.x = x\n", "        self.y = y\n", "        \n", "    def __abs__(self):\n", "        return sqrt(self.x**2 + self.y**2)\n", "    \n", "    def __eq__(self, other):\n", "        if isinstance(other, Point):\n", "            return self.x == other.x and self.y == other.y\n", "        else:\n", "            return NotImplemented\n", "            \n", "    def __lt__(self, other):\n", "        if isinstance(other, Point):\n", "            return abs(self) < abs(other)\n", "        else:\n", "            return NotImplemented\n", "        \n", "    def __repr__(self):\n", "        return '{0}({1},{2})'.format(self.__class__, self.x, self.y)"]}, {"cell_type": "code", "execution_count": 50, "metadata": {"collapsed": true}, "outputs": [], "source": ["Point = complete_ordering(Point)        "]}, {"cell_type": "code", "execution_count": 51, "metadata": {"collapsed": true}, "outputs": [], "source": ["p1, p2, p3 = Point(1, 1), Point(3, 4), Point(3, 4)"]}, {"cell_type": "code", "execution_count": 52, "metadata": {}, "outputs": [{"data": {"text/plain": ["(1.4142135623730951, 5.0, 5.0)"]}, "execution_count": 52, "metadata": {}, "output_type": "execute_result"}], "source": ["abs(p1), abs(p2), abs(p3)"]}, {"cell_type": "code", "execution_count": 53, "metadata": {}, "outputs": [{"data": {"text/plain": ["(True, True, False, False, False, True)"]}, "execution_count": 53, "metadata": {}, "output_type": "execute_result"}], "source": ["p1 < p2, p1 <= p2, p1 > p2, p1 >= p2, p2 > p2, p2 >= p3"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now the `complete_ordering` decorator can also be directly applied to any class that defines `__eq__` and `__lt__`."]}, {"cell_type": "code", "execution_count": 54, "metadata": {"collapsed": true}, "outputs": [], "source": ["@complete_ordering\n", "class Grade:\n", "    def __init__(self, score, max_score):\n", "        self.score = score\n", "        self.max_score = max_score\n", "        self.score_percent = round(score / max_score * 100)\n", "     \n", "    def __repr__(self):\n", "        return 'Grade({0}, {1})'.format(self.score, self.max_score)\n", "    \n", "    def __eq__(self, other):\n", "        if isinstance(other, Grade):\n", "            return self.score_percent == other.score_percent\n", "        else:\n", "            return NotImplemented\n", "    \n", "    def __lt__(self, other):\n", "        if isinstance(other, Grade):\n", "            return self.score_percent < other.score_percent\n", "        else:\n", "            return NotImplemented\n", "        "]}, {"cell_type": "code", "execution_count": 55, "metadata": {"collapsed": true}, "outputs": [], "source": ["g1 = Grade(10, 100)\n", "g2 = Grade(20, 30)\n", "g3 = Grade(5, 50)"]}, {"cell_type": "code", "execution_count": 56, "metadata": {}, "outputs": [{"data": {"text/plain": ["(True, True, True)"]}, "execution_count": 56, "metadata": {}, "output_type": "execute_result"}], "source": ["g1 <= g2, g1 == g3, g2 > g3"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Often, given the `==` operator and just **one** of the other comparison operators (`<`, `<=`, `>`, `>=`), then all the rest can be derived.\n", "\n", "Our decorator insisted on `==` and `<`. but we could make it better by insisting on `==` and any one of the other operators. This will of course make our decorator more complicated, and in fact, Python has this precise functionality built in to the, you guessed it, `functools` module!\n", "\n", "It is a decorator called `total_ordering`. \n", "\n", "Let's see it in action:"]}, {"cell_type": "code", "execution_count": 57, "metadata": {"collapsed": true}, "outputs": [], "source": ["from functools import total_ordering"]}, {"cell_type": "code", "execution_count": 58, "metadata": {"collapsed": true}, "outputs": [], "source": ["@total_ordering\n", "class Grade:\n", "    def __init__(self, score, max_score):\n", "        self.score = score\n", "        self.max_score = max_score\n", "        self.score_percent = round(score / max_score * 100)\n", "     \n", "    def __repr__(self):\n", "        return 'Grade({0}, {1})'.format(self.score, self.max_score)\n", "    \n", "    def __eq__(self, other):\n", "        if isinstance(other, Grade):\n", "            return self.score_percent == other.score_percent\n", "        else:\n", "            return NotImplemented\n", "    \n", "    def __lt__(self, other):\n", "        if isinstance(other, Grade):\n", "            return self.score_percent < other.score_percent\n", "        else:\n", "            return NotImplemented"]}, {"cell_type": "code", "execution_count": 59, "metadata": {"collapsed": true}, "outputs": [], "source": ["g1, g2 = Grade(80, 100), Grade(60, 100)"]}, {"cell_type": "code", "execution_count": 60, "metadata": {}, "outputs": [{"data": {"text/plain": ["(True, True)"]}, "execution_count": 60, "metadata": {}, "output_type": "execute_result"}], "source": ["g1 >= g2, g1 > g2"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Or we could also do it this way:"]}, {"cell_type": "code", "execution_count": 61, "metadata": {"collapsed": true}, "outputs": [], "source": ["@total_ordering\n", "class Grade:\n", "    def __init__(self, score, max_score):\n", "        self.score = score\n", "        self.max_score = max_score\n", "        self.score_percent = round(score / max_score * 100)\n", "     \n", "    def __repr__(self):\n", "        return 'Grade({0}, {1})'.format(self.score, self.max_score)\n", "    \n", "    def __eq__(self, other):\n", "        if isinstance(other, Grade):\n", "            return self.score_percent == other.score_percent\n", "        else:\n", "            return NotImplemented\n", "    \n", "    def __gt__(self, other):\n", "        if isinstance(other, Grade):\n", "            return self.score_percent > other.score_percent\n", "        else:\n", "            return NotImplemented"]}, {"cell_type": "code", "execution_count": 62, "metadata": {"collapsed": true}, "outputs": [], "source": ["g1, g2 = Grade(80, 100), Grade(60, 100)"]}, {"cell_type": "code", "execution_count": 63, "metadata": {}, "outputs": [{"data": {"text/plain": ["(True, True, False, False)"]}, "execution_count": 63, "metadata": {}, "output_type": "execute_result"}], "source": ["g1 >= g2, g1 > g2, g1 <= g2, g1 < g2"]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Decorator Application: Single Dispatch Generic Functions"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Consider an application where we want to provide similar functionality but that varies slightly depending on the argument types passed in.\n", "\n", "In this set of examples we consider this problem where functionality differs based on a single argument's type (hence single dispatch) instead of the type of multiple arguments (which would be multi dispatch)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["If you have a background in some other OO languages such as Java or C#, you'll know that we can easily do something like this by basically **overloading** functions: using a different data type for the function parameter, hence changing the function signature. Then although the name of the function is the same, calling `do_something(100)` and `do_something('java')` would call a different function, the first one would call the `do_something(int)` function, and the second would call the `do_something(String)` function.\n", "\n", "Of course, Python is not statically typed, so even if Python had function overloading built-in, we would not be able to make such a distinction in our function signatures since there is nothing that says that a parameter must be of a specific type, so in a best case scenario we would have to \"distinguish\" functions with the same name only by the number of parameters they take. And then we'd have to somehow deal with variable numbers of positional and keyword arguments too... Uuugh!\n", "In any event, single dispatch could never work.\n", "\n", "Instead we have to come up with a different solution."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's say we want to display various data types in html format, with different presentations for integers (we want both base 10 and hex values), floats (we always want it rounded to 2 decimal points), strings (we want the string html-escaped, and all newline characters replaced by `<br/>`), lists and tuples should be implemented using bulleted lists, and the same with dictionaries except we want the name/value pair to be displayed in the bulleted list."]}, {"cell_type": "markdown", "metadata": {"collapsed": true}, "source": ["For starters, let's just implement individual functions to do each of those things.\n", "\n", "I am going to keep the functions very simple, but in practice you should handle situations like None objects, empty lists and dictionaries, possibly the wrong type being passed to the function, etc."]}, {"cell_type": "code", "execution_count": 1, "metadata": {"collapsed": true}, "outputs": [], "source": ["from html import escape\n", "\n", "def html_escape(arg):\n", "    return escape(str(arg))\n", "                      \n", "def html_int(a):\n", "    return '{0}(<i>{1}</i)'.format(a, str(hex(a)))\n", "\n", "def html_real(a):\n", "    return '{0:.2f}'.format(round(a, 2))\n", "                                  \n", "def html_str(s):\n", "    return html_escape(s).replace('\\n', '<br/>\\n')\n", "                                  \n", "def html_list(l):\n", "    items = ('<li>{0}</li>'.format(html_escape(item)) \n", "             for item in l)\n", "    return '<ul>\\n' + '\\n'.join(items) + '\\n</ul>'\n", "                                  \n", "def html_dict(d):\n", "    items = ('<li>{0}={1}</li>'.format(html_escape(k), html_escape(v)) \n", "             for k, v in d.items())    \n", "    return '<ul>\\n' + '\\n'.join(items) + '\\n</ul>'"]}, {"cell_type": "code", "execution_count": 2, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["this is <br/>\n", "a multi line string<br/>\n", "with special characters: 10 &lt; 100\n"]}], "source": ["print(html_str(\"\"\"this is \n", "a multi line string\n", "with special characters: 10 < 100\"\"\"))"]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["255(<i>0xff</i)\n"]}], "source": ["print(html_int(255))"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["(3+10j)\n"]}], "source": ["print(html_escape(3+10j))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Ideally we would want to just have to call a single function, maybe `htmlize` that would figure out which particular flavor of the `html_xxx` function to call depending on the argument type."]}, {"cell_type": "markdown", "metadata": {}, "source": ["We could try it as follows:"]}, {"cell_type": "code", "execution_count": 5, "metadata": {"collapsed": true}, "outputs": [], "source": ["from decimal import Decimal\n", "\n", "def htmlize(arg):\n", "    if isinstance(arg, int):\n", "        return html_int(arg)\n", "    elif isinstance(arg, float) or isinstance(arg, Decimal):\n", "        return html_real(arg)\n", "    elif isinstance(arg, str):\n", "        return html_str(arg)\n", "    elif isinstance(arg, list) or isinstance(arg, tuple):\n", "        return html_list(arg)\n", "    elif isinstance(arg, dict):\n", "        return html_dict(arg)\n", "    else:\n", "        # default behavior - just html escape string representation\n", "        return html_escape(str(arg))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now we can essentially use the same function call to handle different types - the `htmlize` function is a dispatcher - it dispatches the request to a different function based on the argument type. (There's a much better way to do some of this, but we'll have to wait until we cover abstract base classes to do so)."]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["<ul>\n", "<li>1</li>\n", "<li>2</li>\n", "<li>3</li>\n", "</ul>\n"]}], "source": ["print(htmlize([1, 2, 3]))"]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["<ul>\n", "<li>key1=1</li>\n", "<li>key2=2</li>\n", "</ul>\n"]}], "source": ["print(htmlize(dict(key1=1, key2=2)))"]}, {"cell_type": "code", "execution_count": 8, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["255(<i>0xff</i)\n"]}], "source": ["print(htmlize(255))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But there are a number of shortcomings here:"]}, {"cell_type": "code", "execution_count": 9, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["<ul>\n", "<li>first element is \n", "a multi-line string</li>\n", "<li>(1, 2, 3)</li>\n", "</ul>\n"]}], "source": ["print(htmlize([\"\"\"first element is \n", "a multi-line string\"\"\", (1, 2, 3)]))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see, the multi-line string did not get the newline characters replaced, the tuple was not rendered as an html list, and the integers do not have their hex representation.\n", "\n", "So we just need to redefine the `html_list` and `html_dict` functions to use the `htmlize` function:"]}, {"cell_type": "code", "execution_count": 10, "metadata": {"collapsed": true}, "outputs": [], "source": ["def html_list(l):\n", "    items = ['<li>{0}</li>'.format(htmlize(item)) for item in l]\n", "    return '<ul>\\n' + '\\n'.join(items) + '\\n</ul>'"]}, {"cell_type": "code", "execution_count": 11, "metadata": {"collapsed": true}, "outputs": [], "source": ["def html_dict(d):\n", "    items = ['<li>{0}={1}</li>'.format(html_escape(k), htmlize(v)) for k, v in d.items()]\n", "    return '<ul>\\n' + '\\n'.join(items) + '\\n</ul>'"]}, {"cell_type": "code", "execution_count": 12, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["<ul>\n", "<li>first element is <br/>\n", "a multi-line string</li>\n", "<li><ul>\n", "<li>1(<i>0x1</i)</li>\n", "<li>2(<i>0x2</i)</li>\n", "<li>3(<i>0x3</i)</li>\n", "</ul></li>\n", "</ul>\n"]}], "source": ["print(htmlize([\"\"\"first element is \n", "a multi-line string\"\"\", (1, 2, 3)]))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Much better, but hopefully you spotted something that might seem problematic!\n", "\n", "Do we not have a circular reference?\n", "\n", "In order to define `html_list` and `html_dict` we needed to call `htmlize`, but in order to define `htmlize` we needed to call `html_list` and `html_dict`."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Remember that in Python we can reference a function **inside** the body of another function **before** the function has been defined, as long as by the time we **call** the first function, the second one has been defined. SO this is actually OK.\n", "\n", "If you don't believe me and want to make sure of this yourself, go ahead and reset your Kernel (click on the Kernel | Restart menu option), and run the following code without running anything prior to this.\n", "\n", "The `htmlize` function body makes calls to other functions such as `html_escape`, `html_int`, etc that have not actually been defined yet"]}, {"cell_type": "code", "execution_count": 1, "metadata": {"collapsed": true}, "outputs": [], "source": ["from html import escape\n", "from decimal import Decimal\n", "\n", "def htmlize(arg):\n", "    if isinstance(arg, int):\n", "        return html_int(arg)\n", "    elif isinstance(arg, float) or isinstance(arg, Decimal):\n", "        return html_real(arg)\n", "    elif isinstance(arg, str):\n", "        return html_str(arg)\n", "    elif isinstance(arg, list) or isinstance(arg, tuple) or isinstance(arg, set):\n", "        return html_list(arg)\n", "    elif isinstance(arg, dict):\n", "        return html_dict(arg)\n", "    else:\n", "        # default behavior - just html escape string representation\n", "        return html_escape(str(arg))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now we define all the functions that `htmlize` uses before we actually call `htmlize` and all is good:"]}, {"cell_type": "code", "execution_count": 14, "metadata": {"collapsed": true}, "outputs": [], "source": ["def html_escape(arg):\n", "    return escape(str(arg))\n", "                      \n", "def html_int(a):\n", "    return '{0}(<i>{1}</i)'.format(a, str(hex(a)))\n", "\n", "def html_real(a):\n", "    return '{0:.2f}'.format(round(a, 2))\n", "                                  \n", "def html_str(s):\n", "    return html_escape(s).replace('\\n', '<br/>\\n')\n", "                                  \n", "def html_list(l):\n", "    items = ['<li>{0}</li>'.format(htmlize(item)) for item in l]\n", "    return '<ul>\\n' + '\\n'.join(items) + '\\n</ul>'\n", "                                  \n", "def html_dict(d):\n", "    items = ['<li>{0}={1}</li>'.format(html_escape(k), htmlize(v)) for k, v in d.items()]\n", "    return '<ul>\\n' + '\\n'.join(items) + '\\n</ul>'"]}, {"cell_type": "code", "execution_count": 15, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["<ul>\n", "<li>first element is <br/>\n", "a multi-line string</li>\n", "<li><ul>\n", "<li>1(<i>0x1</i)</li>\n", "<li>2(<i>0x2</i)</li>\n", "<li>3(<i>0x3</i)</li>\n", "</ul></li>\n", "</ul>\n"]}], "source": ["print(htmlize([\"\"\"first element is \n", "a multi-line string\"\"\", (1, 2, 3)]))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see this works just fine.\n", "\n", "But we still have something undesirable. You'll notice that the dispatch function `htmlize` needs to have this big `if...elif...else` statement that will just keep growing as we need to handle more and more types (including potentially custom types).\n", "\n", "This will just get unwieldy, and not very flexible (every time someone creates a new type that has to have a special html representation they will need to go into the `htmlize` function and modify it."]}, {"cell_type": "markdown", "metadata": {}, "source": ["So instead, we are going to try a more flexible approach using decorators."]}, {"cell_type": "markdown", "metadata": {}, "source": ["The way we are going to approach this is to create a dispatcher function, and then separately \"register\" each type-specific function with the dispatcher."]}, {"cell_type": "markdown", "metadata": {}, "source": ["First, we are going to create a decorator that will do something that may seem kind of silly - it is going to take the decorated function and store it in a dictionary, using a key consisting of the **type** `object`.\n", "\n", "Then when the returned closure is called, the closure will call the function stored in that dictionary."]}, {"cell_type": "code", "execution_count": 16, "metadata": {"collapsed": true}, "outputs": [], "source": ["def singledispatch(fn):\n", "    registry = dict()\n", "    registry[object] = fn\n", "    \n", "    def inner(arg):\n", "        return registry[object](arg)\n", "\n", "    return inner"]}, {"cell_type": "code", "execution_count": 17, "metadata": {"collapsed": true}, "outputs": [], "source": ["@singledispatch\n", "def htmlizer(arg):\n", "    return escape(str(arg))"]}, {"cell_type": "code", "execution_count": 18, "metadata": {}, "outputs": [{"data": {"text/plain": ["'a &lt; 10'"]}, "execution_count": 18, "metadata": {}, "output_type": "execute_result"}], "source": ["htmlizer('a < 10')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Next, we are going to add some functions to that `registry` dictionary, and modify our inner function to choose the correct function from the registry, or pick a default based on the type of the argument:"]}, {"cell_type": "code", "execution_count": 19, "metadata": {"collapsed": true}, "outputs": [], "source": ["def singledispatch(fn):\n", "    registry = dict()\n", "    \n", "    registry[object] = fn\n", "    registry[int] = lambda arg: '{0}(<i>{1}</i)'.format(arg, str(hex(arg)))\n", "    registry[float] = lambda arg: '{0:.2f}'.format(round(arg, 2))\n", "    \n", "    def inner(arg):\n", "        fn = registry.get(type(arg), registry[object])\n", "        return fn(arg)\n", "    return inner"]}, {"cell_type": "code", "execution_count": 20, "metadata": {"collapsed": true}, "outputs": [], "source": ["@singledispatch\n", "def htmlize(a):\n", "    return escape(str(a))"]}, {"cell_type": "code", "execution_count": 21, "metadata": {}, "outputs": [{"data": {"text/plain": ["'10(<i>0xa</i)'"]}, "execution_count": 21, "metadata": {}, "output_type": "execute_result"}], "source": ["htmlize(10)"]}, {"cell_type": "code", "execution_count": 22, "metadata": {}, "outputs": [{"data": {"text/plain": ["'3.14'"]}, "execution_count": 22, "metadata": {}, "output_type": "execute_result"}], "source": ["htmlize(3.1415)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now, we want a way to add the specialized functions to the `registry` dictionary from **outside** the `singledispatch` function - to do so we will create a parametrized decorator that will (1) take the type as a parameter, and (2) return a closure that will decorate the function associated with the type:"]}, {"cell_type": "code", "execution_count": 23, "metadata": {"collapsed": true}, "outputs": [], "source": ["def singledispatch(fn):\n", "    registry = dict()\n", "    \n", "    registry[object] = fn\n", "    \n", "    def register(type_):\n", "        def inner(fn):\n", "            registry[type_] = fn\n", "        return inner\n", "        \n", "    \n", "    def decorator(arg):\n", "        fn = registry.get(type(arg), registry[object])\n", "        return fn(arg)\n", "    \n", "    return decorator"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But of course this is not good enough - how do we get a hold of the `register` function from outside `singledispatch`? Remember, `singledispatch` is a decorator that returns the `decorated` closure, not the `register` closure."]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can do this by adding the `register` function as an **attribute** of the `decorated` function before we return it. \n", "\n", "While we're at it we're also going to:\n", "\n", "* add the `registry` dictionary as an attribute as so we can look into it to see what it contains.\n", "\n", "* add another function that given a type will return the function associated with that type (or the default function if the type is not found in the dictionary)"]}, {"cell_type": "code", "execution_count": 24, "metadata": {"collapsed": true}, "outputs": [], "source": ["def singledispatch(fn):\n", "    registry = dict()\n", "    \n", "    registry[object] = fn\n", "    \n", "    def register(type_):\n", "        def inner(fn):\n", "            registry[type_] = fn\n", "            return fn  # we do this so we can stack register decorators!\n", "        return inner\n", "   \n", "    def decorator(arg):\n", "        fn = registry.get(type(arg), registry[object])\n", "        return fn(arg)\n", "    \n", "    def dispatch(type_):\n", "        return registry.get(type_, registry[object])\n", "\n", "    decorator.register = register\n", "    decorator.registry = registry.keys()\n", "    decorator.dispatch = dispatch\n", "    return decorator"]}, {"cell_type": "code", "execution_count": 25, "metadata": {"collapsed": true}, "outputs": [], "source": ["@singledispatch\n", "def htmlize(arg):\n", "    return escape(str(arg))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["And we can see that `htmlize` (that returned `inner`) function has an attribute called `register`:"]}, {"cell_type": "code", "execution_count": 26, "metadata": {}, "outputs": [{"data": {"text/plain": ["<function __main__.singledispatch.<locals>.register>"]}, "execution_count": 26, "metadata": {}, "output_type": "execute_result"}], "source": ["htmlize.register"]}, {"cell_type": "markdown", "metadata": {}, "source": ["as well as that `registry` attribute that we put in just we could see what keys are in the `registry` dictionary:"]}, {"cell_type": "code", "execution_count": 27, "metadata": {}, "outputs": [{"data": {"text/plain": ["dict_keys([<class 'object'>])"]}, "execution_count": 27, "metadata": {}, "output_type": "execute_result"}], "source": ["htmlize.registry"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can also ask it what function it is going to use for any specific type (currently we only have one registered, the default, for the most general `object` type):"]}, {"cell_type": "code", "execution_count": 28, "metadata": {}, "outputs": [{"data": {"text/plain": ["object"]}, "execution_count": 28, "metadata": {}, "output_type": "execute_result"}], "source": ["htmlize.dispatch(str)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["And you'll note that the extended scope of `register` and `dispatch` is the same as the extended scope of `htmlize`."]}, {"cell_type": "markdown", "metadata": {}, "source": ["So now we can register some functions (it will store the function with associated data type in the `registry` dictionary):"]}, {"cell_type": "code", "execution_count": 29, "metadata": {"collapsed": true}, "outputs": [], "source": ["@htmlize.register(int)\n", "def html_int(a):\n", "    return '{0}(<i>{1}</i)'.format(a, str(hex(a)))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can peek into the registered types:"]}, {"cell_type": "code", "execution_count": 30, "metadata": {}, "outputs": [{"data": {"text/plain": ["dict_keys([<class 'object'>, <class 'int'>])"]}, "execution_count": 30, "metadata": {}, "output_type": "execute_result"}], "source": ["htmlize.registry"]}, {"cell_type": "markdown", "metadata": {}, "source": ["and we can ask the decorated `htmlize` function what function it is going to use for the `int` type:"]}, {"cell_type": "code", "execution_count": 31, "metadata": {}, "outputs": [{"data": {"text/plain": ["<function __main__.html_int>"]}, "execution_count": 31, "metadata": {}, "output_type": "execute_result"}], "source": ["htmlize.dispatch(int)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["and we can actually call it as well:"]}, {"cell_type": "code", "execution_count": 32, "metadata": {}, "outputs": [{"data": {"text/plain": ["'100(<i>0x64</i)'"]}, "execution_count": 32, "metadata": {}, "output_type": "execute_result"}], "source": ["htmlize(100)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The huge advantage now is that we can keep registering new handlers from anywhere in our module, or even from outside our module!"]}, {"cell_type": "code", "execution_count": 33, "metadata": {"collapsed": true}, "outputs": [], "source": ["@htmlize.register(float)\n", "def html_real(a):\n", "    return '{0:.2f}'.format(round(a, 2))\n", "\n", "@htmlize.register(str)\n", "def html_str(s):\n", "    return escape(s).replace('\\n', '<br/>\\n')\n", "\n", "@htmlize.register(tuple)\n", "@htmlize.register(list)\n", "def html_list(l):\n", "    items = ['<li>{0}</li>'.format(htmlize(item)) for item in l]\n", "    return '<ul>\\n' + '\\n'.join(items) + '\\n</ul>'\n", "\n", "@htmlize.register(dict)\n", "def html_dict(d):\n", "    items = ['<li>{0}={1}</li>'.format(htmlize(k), htmlize(v)) for k, v in d.items()]\n", "    return '<ul>\\n' + '\\n'.join(items) + '\\n</ul>'"]}, {"cell_type": "code", "execution_count": 34, "metadata": {}, "outputs": [{"data": {"text/plain": ["dict_keys([<class 'object'>, <class 'int'>, <class 'float'>, <class 'str'>, <class 'list'>, <class 'tuple'>, <class 'dict'>])"]}, "execution_count": 34, "metadata": {}, "output_type": "execute_result"}], "source": ["htmlize.registry"]}, {"cell_type": "code", "execution_count": 35, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["<ul>\n", "<li>1(<i>0x1</i)</li>\n", "<li>2(<i>0x2</i)</li>\n", "<li>3(<i>0x3</i)</li>\n", "</ul>\n"]}], "source": ["print(htmlize([1, 2, 3]))"]}, {"cell_type": "code", "execution_count": 36, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["<ul>\n", "<li>1(<i>0x1</i)</li>\n", "<li>2(<i>0x2</i)</li>\n", "<li>3(<i>0x3</i)</li>\n", "</ul>\n"]}], "source": ["print(htmlize((1, 2, 3)))"]}, {"cell_type": "code", "execution_count": 37, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["this<br/>\n", "is a multi line string with<br/>\n", "a &lt; 10\n"]}], "source": ["print(htmlize(\"\"\"this\n", "is a multi line string with\n", "a < 10\"\"\"))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Our single dispatch decorator works quite well - but it has some limitations. For example it cannot handle functions that take in more than one argument (in which case dispatching would be based on the type of the **first** argument), and we also are not allowing for types based on parent classes - for example, integers and booleans are both integral numbers - i.e. they both inherit from the Integral base class. Similarly lists and tuples are both more generic Sequence types. We'll see this in more detail when we get to the topic of abstract base classes (ABC's)."]}, {"cell_type": "code", "execution_count": 38, "metadata": {"collapsed": true}, "outputs": [], "source": ["from numbers import Integral"]}, {"cell_type": "code", "execution_count": 39, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 39, "metadata": {}, "output_type": "execute_result"}], "source": ["isinstance(100, Integral)"]}, {"cell_type": "code", "execution_count": 40, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 40, "metadata": {}, "output_type": "execute_result"}], "source": ["isinstance(True, Integral)"]}, {"cell_type": "code", "execution_count": 41, "metadata": {}, "outputs": [{"data": {"text/plain": ["False"]}, "execution_count": 41, "metadata": {}, "output_type": "execute_result"}], "source": ["isinstance(100.5, Integral)"]}, {"cell_type": "code", "execution_count": 42, "metadata": {}, "outputs": [{"data": {"text/plain": ["False"]}, "execution_count": 42, "metadata": {}, "output_type": "execute_result"}], "source": ["type(100) is Integral"]}, {"cell_type": "code", "execution_count": 43, "metadata": {}, "outputs": [{"data": {"text/plain": ["False"]}, "execution_count": 43, "metadata": {}, "output_type": "execute_result"}], "source": ["type(True) is Integral"]}, {"cell_type": "code", "execution_count": 44, "metadata": {}, "outputs": [{"data": {"text/plain": ["int"]}, "execution_count": 44, "metadata": {}, "output_type": "execute_result"}], "source": ["(100).__class__"]}, {"cell_type": "code", "execution_count": 45, "metadata": {}, "outputs": [{"data": {"text/plain": ["bool"]}, "execution_count": 45, "metadata": {}, "output_type": "execute_result"}], "source": ["(True).__class__"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The way we have implement our decorator, if we register an Integral generic function, it won't pick up either integers or Booleans.\n", "\n", "We can certainly fix this shortcoming ourselves, but of course...\n", "\n", "We can can use Python's built-in single dispatch support, in ...\n", "\n", "you guessed it!\n", "\n", "the `functools` module."]}, {"cell_type": "code", "execution_count": 46, "metadata": {"collapsed": true}, "outputs": [], "source": ["from functools import singledispatch\n", "from numbers import Integral\n", "from collections.abc import Sequence"]}, {"cell_type": "code", "execution_count": 47, "metadata": {"collapsed": true}, "outputs": [], "source": ["@singledispatch\n", "def htmlize(a):\n", "    return escape(str(a))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The `singledispatch` returned closure has a few attributes we can use:\n", "1. A `register` decorator (just like ours did)\n", "2. A `registry` property that is the registry dictionary\n", "3. A `dispatch` function that can be used to determine which registry key (registered type) it will use for the specified type."]}, {"cell_type": "code", "execution_count": 48, "metadata": {"collapsed": true}, "outputs": [], "source": ["@htmlize.register(Integral)\n", "def htmlize_int(a):\n", "    return '{0}(<i>{1}</i)'.format(a, str(hex(a))) "]}, {"cell_type": "code", "execution_count": 49, "metadata": {}, "outputs": [{"data": {"text/plain": ["<function __main__.htmlize_int>"]}, "execution_count": 49, "metadata": {}, "output_type": "execute_result"}], "source": ["htmlize.dispatch(int)"]}, {"cell_type": "code", "execution_count": 50, "metadata": {}, "outputs": [{"data": {"text/plain": ["<function __main__.htmlize_int>"]}, "execution_count": 50, "metadata": {}, "output_type": "execute_result"}], "source": ["htmlize.dispatch(bool)"]}, {"cell_type": "code", "execution_count": 51, "metadata": {}, "outputs": [{"data": {"text/plain": ["'100(<i>0x64</i)'"]}, "execution_count": 51, "metadata": {}, "output_type": "execute_result"}], "source": ["htmlize(100)"]}, {"cell_type": "code", "execution_count": 52, "metadata": {}, "outputs": [{"data": {"text/plain": ["'True(<i>0x1</i)'"]}, "execution_count": 52, "metadata": {}, "output_type": "execute_result"}], "source": ["htmlize(True)"]}, {"cell_type": "code", "execution_count": 53, "metadata": {"collapsed": true}, "outputs": [], "source": ["@htmlize.register(Sequence)\n", "def html_sequence(l):\n", "    items = ['<li>{0}</li>'.format(htmlize(item)) for item in l]\n", "    return '<ul>\\n' + '\\n'.join(items) + '\\n</ul>'"]}, {"cell_type": "code", "execution_count": 54, "metadata": {}, "outputs": [{"data": {"text/plain": ["<function __main__.html_sequence>"]}, "execution_count": 54, "metadata": {}, "output_type": "execute_result"}], "source": ["htmlize.dispatch(list)"]}, {"cell_type": "code", "execution_count": 55, "metadata": {}, "outputs": [{"data": {"text/plain": ["<function __main__.html_sequence>"]}, "execution_count": 55, "metadata": {}, "output_type": "execute_result"}], "source": ["htmlize.dispatch(tuple)"]}, {"cell_type": "code", "execution_count": 56, "metadata": {}, "outputs": [{"data": {"text/plain": ["<function __main__.html_sequence>"]}, "execution_count": 56, "metadata": {}, "output_type": "execute_result"}], "source": ["htmlize.dispatch(str)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["You'll note that a string is also a sequence type, hence our dispatcher will call the `html_sequence` function on a string."]}, {"cell_type": "markdown", "metadata": {}, "source": ["In fact, at this point things would not even run properly.\n", "\n", "If we were to call\n", "\n", "`htmlize('abc')`\n", "\n", "we'd get an infinite recursion!\n", "\n", "The call to `htmlize` the string `abc` would treat it as a sequence, which would call `htmlize` character by character. But each character is itself just a string of length 1, so it will `htmlize` for that single character, which would treat it as a sequence, which would call `htmlize` for that single character again, and so on, in an infinite loop. "]}, {"cell_type": "code", "execution_count": 57, "metadata": {}, "outputs": [{"ename": "RecursionError", "evalue": "maximum recursion depth exceeded", "output_type": "error", "traceback": ["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[1;31mRecursionError\u001b[0m                            Traceback (most recent call last)", "\u001b[1;32m<ipython-input-57-d6479a8af936>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[1;32m----> 1\u001b[1;33m \u001b[0mhtmlize\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34m'abc'\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m", "\u001b[1;32mD:\\Users\\fbapt\\Anaconda3\\envs\\deepdive\\lib\\functools.py\u001b[0m in \u001b[0;36mwrapper\u001b[1;34m(*args, **kw)\u001b[0m\n\u001b[0;32m    801\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    802\u001b[0m     \u001b[1;32mdef\u001b[0m \u001b[0mwrapper\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m*\u001b[0m\u001b[0margs\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;33m**\u001b[0m\u001b[0mkw\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 803\u001b[1;33m         \u001b[1;32mreturn\u001b[0m \u001b[0mdispatch\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0margs\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;36m0\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0m__class__\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m*\u001b[0m\u001b[0margs\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;33m**\u001b[0m\u001b[0mkw\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    804\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    805\u001b[0m     \u001b[0mregistry\u001b[0m\u001b[1;33m[\u001b[0m\u001b[0mobject\u001b[0m\u001b[1;33m]\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mfunc\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n", "\u001b[1;32m<ipython-input-53-50c13b0d81b3>\u001b[0m in \u001b[0;36mhtml_sequence\u001b[1;34m(l)\u001b[0m\n\u001b[0;32m      1\u001b[0m \u001b[1;33m@\u001b[0m\u001b[0mhtmlize\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mregister\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mSequence\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m      2\u001b[0m \u001b[1;32mdef\u001b[0m \u001b[0mhtml_sequence\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0ml\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m----> 3\u001b[1;33m     \u001b[0mitems\u001b[0m \u001b[1;33m=\u001b[0m \u001b[1;33m[\u001b[0m\u001b[1;34m'<li>{0}</li>'\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mformat\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mhtmlize\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mitem\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m)\u001b[0m \u001b[1;32mfor\u001b[0m \u001b[0mitem\u001b[0m \u001b[1;32min\u001b[0m \u001b[0ml\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m      4\u001b[0m     \u001b[1;32mreturn\u001b[0m \u001b[1;34m'<ul>\\n'\u001b[0m \u001b[1;33m+\u001b[0m \u001b[1;34m'\\n'\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mjoin\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mitems\u001b[0m\u001b[1;33m)\u001b[0m \u001b[1;33m+\u001b[0m \u001b[1;34m'\\n</ul>'\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n", "\u001b[1;32m<ipython-input-53-50c13b0d81b3>\u001b[0m in \u001b[0;36m<listcomp>\u001b[1;34m(.0)\u001b[0m\n\u001b[0;32m      1\u001b[0m \u001b[1;33m@\u001b[0m\u001b[0mhtmlize\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mregister\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mSequence\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m      2\u001b[0m \u001b[1;32mdef\u001b[0m \u001b[0mhtml_sequence\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0ml\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m----> 3\u001b[1;33m     \u001b[0mitems\u001b[0m \u001b[1;33m=\u001b[0m \u001b[1;33m[\u001b[0m\u001b[1;34m'<li>{0}</li>'\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mformat\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mhtmlize\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mitem\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m)\u001b[0m \u001b[1;32mfor\u001b[0m \u001b[0mitem\u001b[0m \u001b[1;32min\u001b[0m \u001b[0ml\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m      4\u001b[0m     \u001b[1;32mreturn\u001b[0m \u001b[1;34m'<ul>\\n'\u001b[0m \u001b[1;33m+\u001b[0m \u001b[1;34m'\\n'\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mjoin\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mitems\u001b[0m\u001b[1;33m)\u001b[0m \u001b[1;33m+\u001b[0m \u001b[1;34m'\\n</ul>'\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n", "... last 3 frames repeated, from the frame below ...\n", "\u001b[1;32mD:\\Users\\fbapt\\Anaconda3\\envs\\deepdive\\lib\\functools.py\u001b[0m in \u001b[0;36mwrapper\u001b[1;34m(*args, **kw)\u001b[0m\n\u001b[0;32m    801\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    802\u001b[0m     \u001b[1;32mdef\u001b[0m \u001b[0mwrapper\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m*\u001b[0m\u001b[0margs\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;33m**\u001b[0m\u001b[0mkw\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 803\u001b[1;33m         \u001b[1;32mreturn\u001b[0m \u001b[0mdispatch\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0margs\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;36m0\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0m__class__\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m*\u001b[0m\u001b[0margs\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;33m**\u001b[0m\u001b[0mkw\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    804\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    805\u001b[0m     \u001b[0mregistry\u001b[0m\u001b[1;33m[\u001b[0m\u001b[0mobject\u001b[0m\u001b[1;33m]\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mfunc\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n", "\u001b[1;31mRecursionError\u001b[0m: maximum recursion depth exceeded"]}], "source": ["htmlize('abc')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Instead, we are going to register a string handler specifically - that way we will avoid that problem entirely:"]}, {"cell_type": "code", "execution_count": 58, "metadata": {"collapsed": true}, "outputs": [], "source": ["@htmlize.register(str)\n", "def html_str(s):\n", "    return escape(s).replace('\\n', '<br/>\\n')"]}, {"cell_type": "code", "execution_count": 59, "metadata": {}, "outputs": [{"data": {"text/plain": ["<function __main__.html_str>"]}, "execution_count": 59, "metadata": {}, "output_type": "execute_result"}], "source": ["htmlize.dispatch(str)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["So, even though a string is both an `str` instance and in general a sequence type, the \"closest\" type will be picked by the dispatcher (again something our own implementation did not do).\n", "\n", "This means, we have something for generic sequences, but something specific for more specialized strings."]}, {"cell_type": "code", "execution_count": 60, "metadata": {}, "outputs": [{"data": {"text/plain": ["'abc'"]}, "execution_count": 60, "metadata": {}, "output_type": "execute_result"}], "source": ["htmlize('abc')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can do the same thing with sequences - right now `html_sequence` will be used for both lists and tuples. "]}, {"cell_type": "markdown", "metadata": {}, "source": ["But suppose we want slightly different handling of tuples:"]}, {"cell_type": "code", "execution_count": 61, "metadata": {"collapsed": true}, "outputs": [], "source": ["@htmlize.register(tuple)\n", "def html_tuple(t):\n", "    items = [escape(str(item)) for item in t]\n", "    return '({0})'.format(', '.join(items))"]}, {"cell_type": "code", "execution_count": 62, "metadata": {}, "outputs": [{"data": {"text/plain": ["<function __main__.html_sequence>"]}, "execution_count": 62, "metadata": {}, "output_type": "execute_result"}], "source": ["htmlize.dispatch(list)"]}, {"cell_type": "code", "execution_count": 63, "metadata": {}, "outputs": [{"data": {"text/plain": ["<function __main__.html_tuple>"]}, "execution_count": 63, "metadata": {}, "output_type": "execute_result"}], "source": ["htmlize.dispatch(tuple)"]}, {"cell_type": "code", "execution_count": 64, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["<ul>\n", "<li>a</li>\n", "<li>100(<i>0x64</i)</li>\n", "<li>3.14</li>\n", "</ul>\n"]}], "source": ["print(htmlize(['a', 100, 3.14]))"]}, {"cell_type": "code", "execution_count": 65, "metadata": {"scrolled": true}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["(a, 100, 3.14)\n"]}], "source": ["print(htmlize(('a', 100, 3.14)))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["One thing of note is that we started our decoration with a `@singledispatch` decorator - you'll notice that no specific type was indicated here - and in fact this means the dispatcher will use the generic `object` type."]}, {"cell_type": "markdown", "metadata": {}, "source": ["This means that any object type not specifically handled by our dispatcher will fall back on that `object` key - hence you can think of it as the default for the dispatcher."]}, {"cell_type": "code", "execution_count": 66, "metadata": {}, "outputs": [{"data": {"text/plain": ["NoneType"]}, "execution_count": 66, "metadata": {}, "output_type": "execute_result"}], "source": ["type(None)"]}, {"cell_type": "code", "execution_count": 67, "metadata": {}, "outputs": [{"data": {"text/plain": ["<function __main__.htmlize>"]}, "execution_count": 67, "metadata": {}, "output_type": "execute_result"}], "source": ["htmlize.dispatch(type(None))"]}, {"cell_type": "code", "execution_count": 68, "metadata": {}, "outputs": [{"data": {"text/plain": ["complex"]}, "execution_count": 68, "metadata": {}, "output_type": "execute_result"}], "source": ["type(1+1j)"]}, {"cell_type": "code", "execution_count": 69, "metadata": {}, "outputs": [{"data": {"text/plain": ["<function __main__.htmlize>"]}, "execution_count": 69, "metadata": {}, "output_type": "execute_result"}], "source": ["htmlize.dispatch(complex)"]}, {"cell_type": "code", "execution_count": 70, "metadata": {}, "outputs": [{"data": {"text/plain": ["int"]}, "execution_count": 70, "metadata": {}, "output_type": "execute_result"}], "source": ["type(3)"]}, {"cell_type": "code", "execution_count": 71, "metadata": {}, "outputs": [{"data": {"text/plain": ["<function __main__.htmlize_int>"]}, "execution_count": 71, "metadata": {}, "output_type": "execute_result"}], "source": ["htmlize.dispatch(int)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Lastly, because the name of the individual specialized functions does not really matter to us (the dispatcher will pick the appropriate function), it is quite common for an underscore character ( \\_ ) to be used for the function name - the memory address of each specialized function will be stored in the `registry` dictionary, and the function name does not matter - in fact we can even add lambdas to the registry."]}, {"cell_type": "code", "execution_count": 72, "metadata": {"collapsed": true}, "outputs": [], "source": ["@singledispatch\n", "def htmlize(a):\n", "    return escape(str(a))"]}, {"cell_type": "code", "execution_count": 73, "metadata": {"collapsed": true}, "outputs": [], "source": ["@htmlize.register(int)\n", "def _(a):\n", "    return '{0}({1})'.format(a, str(hex(a)))"]}, {"cell_type": "code", "execution_count": 74, "metadata": {"collapsed": true}, "outputs": [], "source": ["@htmlize.register(str)\n", "def _(s):\n", "    return escape(s).replace('\\n', '<br/>\\n')"]}, {"cell_type": "code", "execution_count": 75, "metadata": {}, "outputs": [{"data": {"text/plain": ["<function __main__.<lambda>>"]}, "execution_count": 75, "metadata": {}, "output_type": "execute_result"}], "source": ["htmlize.register(float)(lambda f: '{0:.2f}'.format(f))"]}, {"cell_type": "code", "execution_count": 76, "metadata": {}, "outputs": [{"data": {"text/plain": ["mappingproxy({object: <function __main__.htmlize>,\n", "              int: <function __main__._>,\n", "              str: <function __main__._>,\n", "              float: <function __main__.<lambda>>})"]}, "execution_count": 76, "metadata": {}, "output_type": "execute_result"}], "source": ["htmlize.registry"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But note that the `__main__._` function for `int` and `str` are not the same functions (even tough they have the same name):"]}, {"cell_type": "code", "execution_count": 77, "metadata": {}, "outputs": [{"data": {"text/plain": ["3104966916432"]}, "execution_count": 77, "metadata": {}, "output_type": "execute_result"}], "source": ["id(htmlize.registry[str])"]}, {"cell_type": "code", "execution_count": 78, "metadata": {}, "outputs": [{"data": {"text/plain": ["3104967451784"]}, "execution_count": 78, "metadata": {}, "output_type": "execute_result"}], "source": ["id(htmlize.registry[int])"]}, {"cell_type": "markdown", "metadata": {}, "source": ["And everything works as expected:"]}, {"cell_type": "code", "execution_count": 79, "metadata": {}, "outputs": [{"data": {"text/plain": ["'100(0x64)'"]}, "execution_count": 79, "metadata": {}, "output_type": "execute_result"}], "source": ["htmlize(100)"]}, {"cell_type": "code", "execution_count": 80, "metadata": {}, "outputs": [{"data": {"text/plain": ["'3.14'"]}, "execution_count": 80, "metadata": {}, "output_type": "execute_result"}], "source": ["htmlize(3.1415)"]}, {"cell_type": "code", "execution_count": 81, "metadata": {"scrolled": true}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["this<br/>\n", "is a multi-line string<br/>\n", "a &lt; 10\n"]}], "source": ["print(htmlize(\"\"\"this\n", "is a multi-line string\n", "a < 10\"\"\"))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["If this same name but different function thing has you confused, look at it this way:"]}, {"cell_type": "code", "execution_count": 82, "metadata": {"collapsed": true}, "outputs": [], "source": ["def my_func():\n", "    print('my_func initial')"]}, {"cell_type": "code", "execution_count": 83, "metadata": {}, "outputs": [{"data": {"text/plain": ["3104966916296"]}, "execution_count": 83, "metadata": {}, "output_type": "execute_result"}], "source": ["id(my_func)"]}, {"cell_type": "code", "execution_count": 84, "metadata": {"collapsed": true}, "outputs": [], "source": ["f = my_func"]}, {"cell_type": "code", "execution_count": 85, "metadata": {}, "outputs": [{"data": {"text/plain": ["3104966916296"]}, "execution_count": 85, "metadata": {}, "output_type": "execute_result"}], "source": ["id(f)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["So, `f` and `my_func` point to the same function in memory.\n", "\n", "Let's go ahead and \"redefine\" the function `my_func`:"]}, {"cell_type": "code", "execution_count": 86, "metadata": {"collapsed": true}, "outputs": [], "source": ["def my_func():\n", "    print('second my_func')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["In fact, we did not \"redefine\" the previous `my_func`, it still exists in memory (and `f` still points to it). Instead we have re-assigned the function that `my_func` points to:"]}, {"cell_type": "code", "execution_count": 87, "metadata": {}, "outputs": [{"data": {"text/plain": ["3104966914800"]}, "execution_count": 87, "metadata": {}, "output_type": "execute_result"}], "source": ["id(my_func)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But the original `my_func` is still around, and 'f' still has a reference to it:"]}, {"cell_type": "code", "execution_count": 88, "metadata": {}, "outputs": [{"data": {"text/plain": ["3104966916296"]}, "execution_count": 88, "metadata": {}, "output_type": "execute_result"}], "source": ["id(f)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["So, we can call each one:"]}, {"cell_type": "code", "execution_count": 89, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["my_func initial\n"]}], "source": ["f()"]}, {"cell_type": "code", "execution_count": 90, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["second my_func\n"]}], "source": ["my_func()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But the function `__name__` have the same value:"]}, {"cell_type": "code", "execution_count": 91, "metadata": {}, "outputs": [{"data": {"text/plain": ["'my_func'"]}, "execution_count": 91, "metadata": {}, "output_type": "execute_result"}], "source": ["f.__name__"]}, {"cell_type": "code", "execution_count": 92, "metadata": {}, "outputs": [{"data": {"text/plain": ["'my_func'"]}, "execution_count": 92, "metadata": {}, "output_type": "execute_result"}], "source": ["my_func.__name__"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Just always keep in mind that labels point to something in memory, it is not the object itself. So in this case we have two distinct objects (functions) which happen to have the same name, but are two very different objects - `f` points to the first one we created, and `my_func` points to the second."]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Tuples as Data Structures"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Tuples are an immutable container type.\n", "\n", "They contain a collection of objects. The tuple is a sequence type - this means order matters (and is preserved) and elements can be accessed by index (zero based), slicing, or iteration.\n", "\n", "Other common sequence types in Python include lists and strings. Strings, like tuples are immutable, whereas lists are mutable.\n", "\n", "Tuples are sometimes presented as immutable lists, but in fact, they could be compared more closely to strings with one major difference: strings are homogeneous sequences, while tuples can be heterogeneous."]}, {"cell_type": "markdown", "metadata": {}, "source": ["A tuple literal is often presented as:"]}, {"cell_type": "code", "execution_count": 1, "metadata": {}, "outputs": [{"data": {"text/plain": ["('a', 10, True)"]}, "execution_count": 1, "metadata": {}, "output_type": "execute_result"}], "source": ["('a', 10, True)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But the parentheses are not what indicate a tuple - it is the commas:"]}, {"cell_type": "code", "execution_count": 2, "metadata": {"collapsed": true}, "outputs": [], "source": ["a = ('a', 10, True)\n", "b = 'b', 20, False"]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [{"data": {"text/plain": ["tuple"]}, "execution_count": 3, "metadata": {}, "output_type": "execute_result"}], "source": ["type(a)"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"data": {"text/plain": ["tuple"]}, "execution_count": 4, "metadata": {}, "output_type": "execute_result"}], "source": ["type(b)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Sometimes however, the parentheses are *required* to remove any ambiguity.\n", "\n", "For example, consider this function that expects a tuple (or other iterable) as its argument:"]}, {"cell_type": "code", "execution_count": 5, "metadata": {"collapsed": true}, "outputs": [], "source": ["def iterate(t):\n", "    for element in t:\n", "        print(element)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["If we call the function this way, Python will interpret it as three arguments:"]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [{"ename": "TypeError", "evalue": "iterate() takes 1 positional argument but 3 were given", "output_type": "error", "traceback": ["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[1;31mTypeError\u001b[0m                                 Traceback (most recent call last)", "\u001b[1;32m<ipython-input-6-868649c3b72b>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[1;32m----> 1\u001b[1;33m \u001b[0miterate\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;36m1\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;36m2\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;36m3\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m", "\u001b[1;31mTypeError\u001b[0m: iterate() takes 1 positional argument but 3 were given"]}], "source": ["iterate(1, 2, 3)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Instead, we now **have** to use the parentheses to indicate we are packing a tuple:"]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1\n", "2\n", "3\n"]}], "source": ["iterate((1, 2, 3))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Since tuples are sequence types, we can access items by index:"]}, {"cell_type": "code", "execution_count": 8, "metadata": {"collapsed": true}, "outputs": [], "source": ["a = 'a', 10, True"]}, {"cell_type": "code", "execution_count": 9, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 9, "metadata": {}, "output_type": "execute_result"}], "source": ["a[2]"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Or we can even slice them:"]}, {"cell_type": "code", "execution_count": 10, "metadata": {}, "outputs": [{"data": {"text/plain": ["(3, 4)"]}, "execution_count": 10, "metadata": {}, "output_type": "execute_result"}], "source": ["a = 1, 2, 3, 4, 5\n", "a[2:4]"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can iterate over them:"]}, {"cell_type": "code", "execution_count": 11, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["1\n", "2\n", "3\n", "4\n", "5\n"]}], "source": ["a = 1, 2, 3, 4, 5\n", "for element in a:\n", "    print(element)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can also use unpacking:"]}, {"cell_type": "code", "execution_count": 12, "metadata": {"collapsed": true}, "outputs": [], "source": ["point = 10, 20, 30"]}, {"cell_type": "code", "execution_count": 13, "metadata": {"collapsed": true}, "outputs": [], "source": ["x, y, z = point"]}, {"cell_type": "code", "execution_count": 14, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["10\n", "20\n", "30\n"]}], "source": ["print(x)\n", "print(y)\n", "print(z)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Tuples are immutable, in the sense that we cannot change the reference of an object in the container and we cannot add or remove objects from the container. This is the same as strings."]}, {"cell_type": "code", "execution_count": 15, "metadata": {"collapsed": true}, "outputs": [], "source": ["a = 10, 'python', True"]}, {"cell_type": "code", "execution_count": 16, "metadata": {}, "outputs": [{"ename": "TypeError", "evalue": "'tuple' object does not support item assignment", "output_type": "error", "traceback": ["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[1;31mTypeError\u001b[0m                                 Traceback (most recent call last)", "\u001b[1;32m<ipython-input-16-90c4006d224a>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[1;32m----> 1\u001b[1;33m \u001b[0ma\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;36m0\u001b[0m\u001b[1;33m]\u001b[0m \u001b[1;33m=\u001b[0m \u001b[1;36m20\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m", "\u001b[1;31mTypeError\u001b[0m: 'tuple' object does not support item assignment"]}], "source": ["a[0] = 20"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can however 'extend' tuples, but just as with strings, we are actually just creating a new tuple:"]}, {"cell_type": "code", "execution_count": 17, "metadata": {"collapsed": true}, "outputs": [], "source": ["a = 1, 2, 3"]}, {"cell_type": "code", "execution_count": 18, "metadata": {}, "outputs": [{"data": {"text/plain": ["2726988303960"]}, "execution_count": 18, "metadata": {}, "output_type": "execute_result"}], "source": ["id(a)"]}, {"cell_type": "code", "execution_count": 19, "metadata": {"collapsed": true}, "outputs": [], "source": ["a = a + (4, 5, 6)"]}, {"cell_type": "code", "execution_count": 20, "metadata": {}, "outputs": [{"data": {"text/plain": ["(1, 2, 3, 4, 5, 6)"]}, "execution_count": 20, "metadata": {}, "output_type": "execute_result"}], "source": ["a"]}, {"cell_type": "code", "execution_count": 21, "metadata": {}, "outputs": [{"data": {"text/plain": ["2726964089000"]}, "execution_count": 21, "metadata": {}, "output_type": "execute_result"}], "source": ["id(a)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see we no longer have the same memory address for `a`."]}, {"cell_type": "markdown", "metadata": {}, "source": ["We have to be careful when we think about immutability of tuples. The tuple, as a container is immutable, but the elements contained in the tuple may very well be mutable."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's define a simple point class to store the x and y coordinates of a point in 2D space:"]}, {"cell_type": "code", "execution_count": 22, "metadata": {"collapsed": true}, "outputs": [], "source": ["class Point2D:\n", "    def __init__(self, x, y):\n", "        self.x = x\n", "        self.y = y\n", "    \n", "    def __repr__(self):\n", "        return f'{self.__class__.__name__}(x={self.x}, y={self.y})'"]}, {"cell_type": "code", "execution_count": 23, "metadata": {"collapsed": true}, "outputs": [], "source": ["a = Point2D(0, 0), Point2D(10, 10), Point2D(20, 20)"]}, {"cell_type": "code", "execution_count": 24, "metadata": {}, "outputs": [{"data": {"text/plain": ["(Point2D(x=0, y=0), Point2D(x=10, y=10), Point2D(x=20, y=20))"]}, "execution_count": 24, "metadata": {}, "output_type": "execute_result"}], "source": ["a"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Although the tuple `a` is immutable, its contained elements are mutable:"]}, {"cell_type": "markdown", "metadata": {}, "source": ["So we cannot do this:"]}, {"cell_type": "code", "execution_count": 25, "metadata": {}, "outputs": [{"ename": "TypeError", "evalue": "'tuple' object does not support item assignment", "output_type": "error", "traceback": ["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[1;31mTypeError\u001b[0m                                 Traceback (most recent call last)", "\u001b[1;32m<ipython-input-25-e869cf518b45>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[1;32m----> 1\u001b[1;33m \u001b[0ma\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;36m0\u001b[0m\u001b[1;33m]\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mPoint2D\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m-\u001b[0m\u001b[1;36m10\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;33m-\u001b[0m\u001b[1;36m10\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m", "\u001b[1;31mTypeError\u001b[0m: 'tuple' object does not support item assignment"]}], "source": ["a[0] = Point2D(-10, -10)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But we can modify the contents of the first element:"]}, {"cell_type": "code", "execution_count": 26, "metadata": {"collapsed": true}, "outputs": [], "source": ["a[0].x = -10"]}, {"cell_type": "code", "execution_count": 27, "metadata": {}, "outputs": [{"data": {"text/plain": ["(Point2D(x=-10, y=0), Point2D(x=10, y=10), Point2D(x=20, y=20))"]}, "execution_count": 27, "metadata": {}, "output_type": "execute_result"}], "source": ["a"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Tuples as Data Records"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can interpret tuples as lightweight data structures where, by convention, the position of the element in the tuple has meaning.\n", "\n", "For example, we may elect to represent a point as a tuple, and not use the class approach we just did:"]}, {"cell_type": "code", "execution_count": 28, "metadata": {"collapsed": true}, "outputs": [], "source": ["pt1 = (0, 0)\n", "pt2 = (10, 10)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Here, we simply decide that the first position of the tuple represents the x=coordinate while the second element represents the y-coordinate of a point in 2D space."]}, {"cell_type": "markdown", "metadata": {}, "source": ["We could also decide that we are going to represent a city using a tuple, where the first position will the city name, the second position will be the country, and the the third position will be the population:"]}, {"cell_type": "code", "execution_count": 29, "metadata": {"collapsed": true}, "outputs": [], "source": ["london = 'London', 'UK', 8_780_000\n", "new_york = 'New York', 'USA', 8_500_000\n", "beijing = 'Beijing', 'China', 21_000_000"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can even have a list of these tuples:"]}, {"cell_type": "code", "execution_count": 30, "metadata": {"collapsed": true}, "outputs": [], "source": ["cities = london, new_york, beijing"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can obtain a list of all the cities in the list using a simple list comprehension and the fact that the city name is the first element (index 0) of each tuple:"]}, {"cell_type": "code", "execution_count": 31, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["['London', 'New York', 'Beijing']\n"]}], "source": ["city_names = [t[0] for t in cities]\n", "print(city_names)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We could even calculate the total population of all these cities.\n", "\n", "We start with a simple loop to do this:"]}, {"cell_type": "code", "execution_count": 32, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["total=38280000\n"]}], "source": ["total = 0\n", "for city in cities:\n", "    total += city[2]\n", "print (f'total={total}')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["You will note that the reason this worked is because the `cities` list contained **only** city tuples. The list was homogeneous. The tuples on the other hand are heterogeneous.\n", "\n", "This is often a key difference between lists and tuples, especially when we consider tuples as data structures. The tuples are heterogeneous, while the list needs to be homogeneous so we can apoply the same calculations to each element of the list.\n", "\n", "The above example would break if one of the elements in the `cities` list was an integer for example."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Back to our example calculating the total population. There is a more Pythonic way of doing this.\n", "\n", "First we use a comprehension to extract just the population from each city :"]}, {"cell_type": "code", "execution_count": 33, "metadata": {}, "outputs": [{"data": {"text/plain": ["[8780000, 8500000, 21000000]"]}, "execution_count": 33, "metadata": {}, "output_type": "execute_result"}], "source": ["[city[2] for city in cities]"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Next we simply sum up the population values:"]}, {"cell_type": "code", "execution_count": 34, "metadata": {}, "outputs": [{"data": {"text/plain": ["38280000"]}, "execution_count": 34, "metadata": {}, "output_type": "execute_result"}], "source": ["sum([city[2] for city in cities])"]}, {"cell_type": "markdown", "metadata": {}, "source": ["In fact (and we'll cover this in detail later in this course), we don't even need the square brackets in the sum:"]}, {"cell_type": "code", "execution_count": 35, "metadata": {}, "outputs": [{"data": {"text/plain": ["38280000"]}, "execution_count": 35, "metadata": {}, "output_type": "execute_result"}], "source": ["sum(city[2] for city in cities)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now, since tuples are sequence types, and hence iterable, we can also use unpacking to extract values from the tuple:"]}, {"cell_type": "code", "execution_count": 36, "metadata": {"collapsed": true}, "outputs": [], "source": ["city, country, population = new_york"]}, {"cell_type": "code", "execution_count": 37, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["New York\n", "USA\n", "8500000\n"]}], "source": ["print(city)\n", "print(country)\n", "print(population)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can also use extended unpacking:"]}, {"cell_type": "code", "execution_count": 38, "metadata": {"collapsed": true}, "outputs": [], "source": ["record = 'DJIA', 2018, 1, 19, 25_987, 26_072, 25_942, 26_072"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Where the structure is: symbol, year, month, day, open, high low, close"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We could then unpack the record using straight unpacking:"]}, {"cell_type": "code", "execution_count": 39, "metadata": {"collapsed": true}, "outputs": [], "source": ["symbol, year, month, day, open_, high, low, close = record"]}, {"cell_type": "code", "execution_count": 40, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["DJIA\n", "26072\n"]}], "source": ["print(symbol)\n", "print(close)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But suppose we are only interested in the symbol, year, month, day and close. Then we could use extended unpacking as follows:"]}, {"cell_type": "code", "execution_count": 41, "metadata": {"collapsed": true}, "outputs": [], "source": ["symbol, year, month, day, *others, close = record"]}, {"cell_type": "code", "execution_count": 42, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["DJIA 2018 1 19 26072\n"]}], "source": ["print(symbol, year, month, day, close)"]}, {"cell_type": "code", "execution_count": 43, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["[25987, 26072, 25942]\n"]}], "source": ["print(others)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["A convetion often used in Python when we are not particularly interested in something, is to use an underscore as a variable name:"]}, {"cell_type": "code", "execution_count": 44, "metadata": {"collapsed": true}, "outputs": [], "source": ["symbol, year, month, day, *_, close = record"]}, {"cell_type": "markdown", "metadata": {}, "source": ["There's nothing special about the underscore here, it's just a legal variable name (in an interactive Python session, the underscore is actually used to store the results of the last calculation)"]}, {"cell_type": "code", "execution_count": 45, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["[25987, 26072, 25942]\n"]}], "source": ["print(_)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["By the way do not write code like this to do the unpacking we just did:"]}, {"cell_type": "code", "execution_count": 46, "metadata": {"collapsed": true}, "outputs": [], "source": ["symbol, year, close = record[0], record[1], record[7]"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Although this works, it is not very readable code, plus you are packing a new tuple (the right hand side) and then unpacking it into the variables on the left. Much better to do this:"]}, {"cell_type": "code", "execution_count": 47, "metadata": {"collapsed": true}, "outputs": [], "source": ["symbol, year, *_, close = record"]}, {"cell_type": "markdown", "metadata": {}, "source": ["If you only need to pick a few elements out of the tuple (like in our example where we just wanted the population to sum it up), then by all means access it directly using the index."]}, {"cell_type": "markdown", "metadata": {}, "source": ["But did you know that you can also unpack tuples directly in the loop?"]}, {"cell_type": "code", "execution_count": 48, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["('London', 'UK', 8780000)\n", "('New York', 'USA', 8500000)\n", "('Beijing', 'China', 21000000)\n"]}], "source": ["for element in cities:\n", "    print(element)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see, each element is a tuple, and we can actually unpack it at the same time as the loop this way:"]}, {"cell_type": "code", "execution_count": 49, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["city=London, population=8780000\n", "city=New York, population=8500000\n", "city=Beijing, population=21000000\n"]}], "source": ["for city, country, population in cities:\n", "    print(f'city={city}, population={population}')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["This, by the way, is how we can use the `enumerate` function in Python. The enumerate function produces an iterable from another iterable but contains the index number. Values are returned as tuples, where the first position is the index value, and the second position is the value (here we also see how a tuple was used as a data structure). So that tuple can be unpacked as follows:"]}, {"cell_type": "code", "execution_count": 50, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["0: Beijing\n", "1: China\n", "2: 21000000\n"]}], "source": ["for index, value in enumerate(beijing):\n", "    print(f'{index}: {value}')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Of course, since we are not interested in the country in this case, we might write it this way as well:"]}, {"cell_type": "code", "execution_count": 51, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["city=London, population=8780000\n", "city=New York, population=8500000\n", "city=Beijing, population=21000000\n"]}], "source": ["for city, _, population in cities:\n", "    print(f'city={city}, population={population}')"]}, {"cell_type": "markdown", "metadata": {"collapsed": true}, "source": ["Another frequent application of usign tuples as data structures is for returning multiple values from a function."]}, {"cell_type": "code", "execution_count": 67, "metadata": {}, "outputs": [], "source": ["from random import uniform\n", "from math import sqrt\n", "\n", "def random_shot(radius):\n", "    '''Generates a random 2D coordinate within \n", "    the bounds [-radius, radius] * [-radius, radius]\n", "    (a square of area 4)\n", "    and also determines if it falls within \n", "    a circle centered at the origin \n", "    with specified radius'''\n", "    \n", "    random_x = uniform(-radius, radius)\n", "    random_y = uniform(-radius, radius)\n", "\n", "    if sqrt(random_x ** 2 + random_y ** 2) <= radius:\n", "        is_in_circle = True\n", "    else:\n", "        is_in_circle = False\n", "    \n", "    return random_x, random_y, is_in_circle"]}, {"cell_type": "code", "execution_count": 71, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Pi is approximately: 3.14294\n"]}], "source": ["num_attempts = 1_000_000\n", "count_inside = 0\n", "for i in range(num_attempts):\n", "    *_, is_in_circle = random_shot(1)\n", "    if is_in_circle:\n", "        count_inside += 1\n", "\n", "print(f'Pi is approximately: {4 * count_inside / num_attempts}')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Named Tuples"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The ``namedtuple`` function in ``collections`` allows us to create a tuple that also has names attached to each field (aka property). This can be handy to reference data in the tuple structure by name instead of just relying on position.\n", "\n", "The ``namedtuple`` function is basically a class factory that creates a new type of class that uses a tuple as its underlying data storage (in fact, named tuples inherit from `tuple`), but layers in field names to each position and makes a property out of the field name.\n", "\n", "The ``namedtuple`` function creates a **class**, and we then use that class to instantiate our instances of named tuples."]}, {"cell_type": "markdown", "metadata": {}, "source": ["To use the ``namedtuple`` function we therefore need to select a class **name**, as well as indicate the **property** names, in the order in which they will be stored and accessed in the tuple.\n", "\n", "Note that a ``namedtuple``, like the regular ``tuple`` is an **immutable** data structure. (In fact, named tuples inherit from tuples - we'll revisit this in our section on metaclasses)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["If you find yourself writing code such as:"]}, {"cell_type": "code", "execution_count": 1, "metadata": {"collapsed": true}, "outputs": [], "source": ["class Point3D:\n", "    def __init__(self, x, y, z):\n", "        self.x = x\n", "        self.y = y\n", "        self.z = z"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Forget it! You seriously need to use named tuples! Not only can you shorten the amount of code you need to write, but you get some additional functionality for \"free\", such as `__repr__` and `__eq__` that you do not have to implement yourself!"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Creating Named Tuples"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We are going to create a ``Point`` named tuple that will contain an x-coordinate and a y-coordinate."]}, {"cell_type": "code", "execution_count": 2, "metadata": {"collapsed": true}, "outputs": [], "source": ["from collections import namedtuple"]}, {"cell_type": "code", "execution_count": 3, "metadata": {"collapsed": true}, "outputs": [], "source": ["Point2D = namedtuple('Point2D', ('x', 'y'))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Note that we have two different uses of `Point2D` here. The label we are assigning the return value of the call to ``namedtuple`` and the **name** of the class generated by calling ``namedtuple``.\n", "\n", "We could also have done the following:"]}, {"cell_type": "code", "execution_count": 4, "metadata": {"collapsed": true}, "outputs": [], "source": ["Pt = namedtuple('Point2D', ('x', 'y'))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The ``namedtuple`` class name is `Point2D`, but the label we `Pt` simply points to that class, so we would then create instances of the `Point2D` class as follows:"]}, {"cell_type": "code", "execution_count": 5, "metadata": {"collapsed": true}, "outputs": [], "source": ["pt1 = Pt(10, 20)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["And we can see what `pt1` is:"]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [{"data": {"text/plain": ["Point2D(x=10, y=20)"]}, "execution_count": 6, "metadata": {}, "output_type": "execute_result"}], "source": ["pt1"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see we have an object of type `Point2D`, and it has two properties, `x` and `y` with respective values `10` and `20`.\n", "\n", "The only weird thing here is that we are using `Pt` to generate our instances of the `Point2D` class.\n", "\n", "That's why we usually always created `namedtuple` generated classes this way:"]}, {"cell_type": "code", "execution_count": 7, "metadata": {"collapsed": true}, "outputs": [], "source": ["Point2D = namedtuple('Point2D', ('x', 'y'))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Then the following makes more sense:"]}, {"cell_type": "code", "execution_count": 8, "metadata": {"collapsed": true}, "outputs": [], "source": ["pt1 = Point2D(10, 20)"]}, {"cell_type": "code", "execution_count": 9, "metadata": {}, "outputs": [{"data": {"text/plain": ["Point2D(x=10, y=20)"]}, "execution_count": 9, "metadata": {}, "output_type": "execute_result"}], "source": ["pt1"]}, {"cell_type": "markdown", "metadata": {}, "source": ["This is not different than doing this:"]}, {"cell_type": "code", "execution_count": 10, "metadata": {"collapsed": true}, "outputs": [], "source": ["Pt3 = Point3D  # class we defined earlier"]}, {"cell_type": "code", "execution_count": 11, "metadata": {"collapsed": true}, "outputs": [], "source": ["pt3 = Pt3(10, 20, 30)"]}, {"cell_type": "code", "execution_count": 12, "metadata": {}, "outputs": [{"data": {"text/plain": ["<__main__.Point3D at 0x27408e1fa90>"]}, "execution_count": 12, "metadata": {}, "output_type": "execute_result"}], "source": ["pt3"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see above, we used another label `Pt3` as a label that also references the `Point3D` class. It would be weird to do it this way here, and its weird for tuples as well. Of course, you may run into circumstances where you need to do this - just not as a general rule."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Note that all named tuples  are honest to goodness **classes**, just as if you had used a `class` definition such as with `Point3D`. \n", "\n", "The `namedtuple` function **generates** classes for us - it is a **class factory**."]}, {"cell_type": "code", "execution_count": 13, "metadata": {}, "outputs": [{"data": {"text/plain": ["type"]}, "execution_count": 13, "metadata": {}, "output_type": "execute_result"}], "source": ["type(Point3D)"]}, {"cell_type": "code", "execution_count": 14, "metadata": {}, "outputs": [{"data": {"text/plain": ["type"]}, "execution_count": 14, "metadata": {}, "output_type": "execute_result"}], "source": ["type(Point2D)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["However, `Point2D` is a subclass of `tuple`, while `Point3D` is not:"]}, {"cell_type": "code", "execution_count": 15, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 15, "metadata": {}, "output_type": "execute_result"}], "source": ["isinstance(pt1, tuple)"]}, {"cell_type": "code", "execution_count": 16, "metadata": {}, "outputs": [{"data": {"text/plain": ["False"]}, "execution_count": 16, "metadata": {}, "output_type": "execute_result"}], "source": ["isinstance(pt3, tuple)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["So, when we create an instance of a class, we are in fact calling the `__new__` method with our initial values. It's just a callable that has the **field names** we used to generate our named tuple class as its parameters. This means we can use keyword arguments when instantiating our named tuples!"]}, {"cell_type": "code", "execution_count": 17, "metadata": {"collapsed": true}, "outputs": [], "source": ["pt4 = Point2D(y=20, x=10)"]}, {"cell_type": "code", "execution_count": 18, "metadata": {}, "outputs": [{"data": {"text/plain": ["Point2D(x=10, y=20)"]}, "execution_count": 18, "metadata": {}, "output_type": "execute_result"}], "source": ["pt4"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### What did we get for free using a named tuple vs our own class?"]}, {"cell_type": "markdown", "metadata": {}, "source": ["First using a named tuple for our 2D point:"]}, {"cell_type": "code", "execution_count": 19, "metadata": {"collapsed": true}, "outputs": [], "source": ["pt2d_1 = Point2D(10, 20)\n", "pt2d_2 = Point2D(10, 20)"]}, {"cell_type": "code", "execution_count": 20, "metadata": {}, "outputs": [{"data": {"text/plain": ["Point2D(x=10, y=20)"]}, "execution_count": 20, "metadata": {}, "output_type": "execute_result"}], "source": ["pt2d_1"]}, {"cell_type": "code", "execution_count": 21, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 21, "metadata": {}, "output_type": "execute_result"}], "source": ["pt2d_1 == pt2d_2"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now using our 3D class:"]}, {"cell_type": "code", "execution_count": 22, "metadata": {"collapsed": true}, "outputs": [], "source": ["pt3d_1 = Point3D(10, 20, 30)\n", "pt3d_2 = Point3D(10, 20, 30)"]}, {"cell_type": "code", "execution_count": 23, "metadata": {}, "outputs": [{"data": {"text/plain": ["<__main__.Point3D at 0x27408e1f9e8>"]}, "execution_count": 23, "metadata": {}, "output_type": "execute_result"}], "source": ["pt3d_1"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Oh, we probably need to implement the `__repr__` method in our class"]}, {"cell_type": "code", "execution_count": 24, "metadata": {}, "outputs": [{"data": {"text/plain": ["False"]}, "execution_count": 24, "metadata": {}, "output_type": "execute_result"}], "source": ["pt3d_1 == pt3d_2"]}, {"cell_type": "markdown", "metadata": {}, "source": ["And we would also need to implement the __eq__ method!\n", "\n", "Let's do that:"]}, {"cell_type": "code", "execution_count": 25, "metadata": {"collapsed": true}, "outputs": [], "source": ["class Point3D:\n", "    def __init__(self, x, y, z):\n", "        self.x = x\n", "        self.y = y\n", "        self.z = z\n", "    \n", "    def __repr__(self):\n", "        return f\"Point3D(x={self.x}, y={self.y}, z={self.z})\"\n", "    \n", "    def __eq__(self, other):\n", "        if isinstance(other, Point3D):\n", "            return self.x == other.x and self.y == other.y and self.z == other.z\n", "        else:\n", "            return False"]}, {"cell_type": "code", "execution_count": 26, "metadata": {"collapsed": true}, "outputs": [], "source": ["pt3d_1 = Point3D(10, 20, 30)\n", "pt3d_2 = Point3D(10, 20, 30)"]}, {"cell_type": "code", "execution_count": 27, "metadata": {}, "outputs": [{"data": {"text/plain": ["Point3D(x=10, y=20, z=30)"]}, "execution_count": 27, "metadata": {}, "output_type": "execute_result"}], "source": ["pt3d_1"]}, {"cell_type": "code", "execution_count": 28, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 28, "metadata": {}, "output_type": "execute_result"}], "source": ["pt3d_1 == pt3d_2"]}, {"cell_type": "markdown", "metadata": {}, "source": ["How about finding the largest coordinate in the point?\n", "\n", "That's easy for `Point2D` since it is a tuple, but not the case for `Point3D`:"]}, {"cell_type": "code", "execution_count": 29, "metadata": {}, "outputs": [{"data": {"text/plain": ["20"]}, "execution_count": 29, "metadata": {}, "output_type": "execute_result"}], "source": ["max(pt2d_1)"]}, {"cell_type": "code", "execution_count": 30, "metadata": {}, "outputs": [{"ename": "TypeError", "evalue": "'Point3D' object is not iterable", "output_type": "error", "traceback": ["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[1;31mTypeError\u001b[0m                                 Traceback (most recent call last)", "\u001b[1;32m<ipython-input-30-e803e2758ff1>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[1;32m----> 1\u001b[1;33m \u001b[0mmax\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mpt3d_1\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m", "\u001b[1;31mTypeError\u001b[0m: 'Point3D' object is not iterable"]}], "source": ["max(pt3d_1)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["How about calculating the dot product of two points (considering them as vectors starting at the origin)?"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The formula would be:\n", "a.b = a.x * b.x + a.y + b.y + a.z * b.z"]}, {"cell_type": "markdown", "metadata": {}, "source": ["For the 3D point we would need to do the following:"]}, {"cell_type": "code", "execution_count": 31, "metadata": {"collapsed": true}, "outputs": [], "source": ["def dot_product_3d(a, b):\n", "    return a.x * b.x + a.y * b.y + a.z + b.z"]}, {"cell_type": "code", "execution_count": 32, "metadata": {}, "outputs": [{"data": {"text/plain": ["560"]}, "execution_count": 32, "metadata": {}, "output_type": "execute_result"}], "source": ["dot_product_3d(pt3d_1, pt3d_2)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But for our 2D point, which, remember is a tuple as well, we can write a generic function that would work equally well with a 3D named tuple too:"]}, {"cell_type": "code", "execution_count": 33, "metadata": {"collapsed": true}, "outputs": [], "source": ["def dot_product(a, b):\n", "    return sum(e[0] * e[1] for e in  zip(a, b))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Here's a break down of how we implemented the dot product:"]}, {"cell_type": "markdown", "metadata": {}, "source": ["First we zip up the components of `a` and `b` to get an iterable of tuples containing the x-coordinates in the 1st element, and the y-coordinates in the second tuple. Our zip will contain as many elements as there are dimensions."]}, {"cell_type": "code", "execution_count": 34, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Point2D(x=1, y=2)\n", "Point2D(x=10, y=20)\n", "(1, 2)\n", "(10, 20)\n", "[(1, 10), (2, 20)]\n"]}], "source": ["a = Point2D(1, 2)\n", "b = Point2D(10, 20)\n", "print(a)\n", "print(b)\n", "print(tuple(a))\n", "print(tuple(b))\n", "print(list(zip(a, b)))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Note that if we had more dimensions this would work equally well.\n", "\n", "Suppose we had 3 dimensions:"]}, {"cell_type": "code", "execution_count": 35, "metadata": {}, "outputs": [{"data": {"text/plain": ["[(1, 10), (2, 20), (3, 30)]"]}, "execution_count": 35, "metadata": {}, "output_type": "execute_result"}], "source": ["u = (1, 2, 3)\n", "v = (10, 20, 30)\n", "list(zip(u, v))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Then we create a comprehension that multiplies the components together:"]}, {"cell_type": "code", "execution_count": 36, "metadata": {}, "outputs": [{"data": {"text/plain": ["[10, 40]"]}, "execution_count": 36, "metadata": {}, "output_type": "execute_result"}], "source": ["[e[0] * e[1] for e in zip(a, b)]"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Then we simply add those up:"]}, {"cell_type": "code", "execution_count": 37, "metadata": {}, "outputs": [{"data": {"text/plain": ["50"]}, "execution_count": 37, "metadata": {}, "output_type": "execute_result"}], "source": ["sum([e[0] * e[1] for e in zip(a, b)])"]}, {"cell_type": "code", "execution_count": 38, "metadata": {}, "outputs": [{"data": {"text/plain": ["50"]}, "execution_count": 38, "metadata": {}, "output_type": "execute_result"}], "source": ["dot_product(a, b)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["And if we defined a 4D point named tuple:"]}, {"cell_type": "code", "execution_count": 39, "metadata": {"collapsed": true}, "outputs": [], "source": ["Point4D = namedtuple('Point4D', ['i', 'j', 'k', 'l'])"]}, {"cell_type": "code", "execution_count": 40, "metadata": {"collapsed": true}, "outputs": [], "source": ["pt4d_1 = (1, 1, 1, 10)\n", "pt4d_2 = (2, 2, 2, 10)"]}, {"cell_type": "code", "execution_count": 41, "metadata": {}, "outputs": [{"data": {"text/plain": ["106"]}, "execution_count": 41, "metadata": {}, "output_type": "execute_result"}], "source": ["dot_product(pt4d_1, pt4d_2)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see we got the correct dot product. We could not have done this using our `Point3D` class!"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Other Ways to Specify Field Names"]}, {"cell_type": "markdown", "metadata": {}, "source": ["There are a number of ways we can specify the field names for the named tuple:\n", "\n", "* we can provide a sequence of strings containing each property name\n", "* we can provide a single string with property names separated by whitespace or a comma"]}, {"cell_type": "code", "execution_count": 42, "metadata": {"collapsed": true}, "outputs": [], "source": ["Circle = namedtuple('Circle', ['center_x', 'center_y', 'radius'])"]}, {"cell_type": "code", "execution_count": 43, "metadata": {"collapsed": true}, "outputs": [], "source": ["circle_1 = Circle(0, 0, 10)\n", "circle_2 = Circle(center_x=10, center_y=20, radius=100)"]}, {"cell_type": "code", "execution_count": 44, "metadata": {}, "outputs": [{"data": {"text/plain": ["Circle(center_x=0, center_y=0, radius=10)"]}, "execution_count": 44, "metadata": {}, "output_type": "execute_result"}], "source": ["circle_1"]}, {"cell_type": "code", "execution_count": 45, "metadata": {}, "outputs": [{"data": {"text/plain": ["Circle(center_x=10, center_y=20, radius=100)"]}, "execution_count": 45, "metadata": {}, "output_type": "execute_result"}], "source": ["circle_2"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Or we can do it this way:"]}, {"cell_type": "code", "execution_count": 46, "metadata": {"collapsed": true}, "outputs": [], "source": ["City = namedtuple('City', 'name country population')"]}, {"cell_type": "code", "execution_count": 47, "metadata": {"collapsed": true}, "outputs": [], "source": ["new_york = City('New York', 'USA', 8_500_000)"]}, {"cell_type": "code", "execution_count": 48, "metadata": {}, "outputs": [{"data": {"text/plain": ["City(name='New York', country='USA', population=8500000)"]}, "execution_count": 48, "metadata": {}, "output_type": "execute_result"}], "source": ["new_york"]}, {"cell_type": "markdown", "metadata": {}, "source": ["This would work equally well:"]}, {"cell_type": "code", "execution_count": 49, "metadata": {"collapsed": true}, "outputs": [], "source": ["Stock = namedtuple('Stock', 'symbol, year, month, day, open, high, low, close')"]}, {"cell_type": "code", "execution_count": 50, "metadata": {"collapsed": true}, "outputs": [], "source": ["djia = Stock('DJIA', 2018, 1, 25, 26_313, 26_458, 26_260, 26_393)"]}, {"cell_type": "code", "execution_count": 51, "metadata": {}, "outputs": [{"data": {"text/plain": ["Stock(symbol='DJIA', year=2018, month=1, day=25, open=26313, high=26458, low=26260, close=26393)"]}, "execution_count": 51, "metadata": {}, "output_type": "execute_result"}], "source": ["djia"]}, {"cell_type": "markdown", "metadata": {}, "source": ["In fact, since whitespace can be used we can even use a multi-line string!"]}, {"cell_type": "code", "execution_count": 52, "metadata": {"collapsed": true}, "outputs": [], "source": ["Stock = namedtuple('Stock', '''symbol\n", "                               year month day\n", "                               open high low close''')"]}, {"cell_type": "code", "execution_count": 53, "metadata": {"collapsed": true}, "outputs": [], "source": ["djia = Stock('DJIA', 2018, 1, 25, 26_313, 26_458, 26_260, 26_393)"]}, {"cell_type": "code", "execution_count": 54, "metadata": {}, "outputs": [{"data": {"text/plain": ["Stock(symbol='DJIA', year=2018, month=1, day=25, open=26313, high=26458, low=26260, close=26393)"]}, "execution_count": 54, "metadata": {}, "output_type": "execute_result"}], "source": ["djia"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Accessing Items in a Named Tuple"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The major advantage of named tuples are that, as the name suggests, we can access the properties (fields) of the tuple by name:"]}, {"cell_type": "code", "execution_count": 55, "metadata": {}, "outputs": [{"data": {"text/plain": ["Point2D(x=10, y=20)"]}, "execution_count": 55, "metadata": {}, "output_type": "execute_result"}], "source": ["pt1"]}, {"cell_type": "code", "execution_count": 56, "metadata": {}, "outputs": [{"data": {"text/plain": ["10"]}, "execution_count": 56, "metadata": {}, "output_type": "execute_result"}], "source": ["pt1.x"]}, {"cell_type": "code", "execution_count": 57, "metadata": {}, "outputs": [{"data": {"text/plain": ["Circle(center_x=0, center_y=0, radius=10)"]}, "execution_count": 57, "metadata": {}, "output_type": "execute_result"}], "source": ["circle_1"]}, {"cell_type": "code", "execution_count": 58, "metadata": {}, "outputs": [{"data": {"text/plain": ["10"]}, "execution_count": 58, "metadata": {}, "output_type": "execute_result"}], "source": ["circle_1.radius"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now named tuples *are* tuples, so elements can be accessed by index, unpacked, and iterated."]}, {"cell_type": "code", "execution_count": 59, "metadata": {}, "outputs": [{"data": {"text/plain": ["10"]}, "execution_count": 59, "metadata": {}, "output_type": "execute_result"}], "source": ["circle_1[2]"]}, {"cell_type": "code", "execution_count": 60, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["DJIA\n", "2018\n", "1\n", "25\n", "26313\n", "26458\n", "26260\n", "26393\n"]}], "source": ["for item in djia:\n", "    print(item)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can also unpack named tuples just like ordinary tuples:"]}, {"cell_type": "code", "execution_count": 61, "metadata": {}, "outputs": [{"data": {"text/plain": ["Point2D(x=10, y=20)"]}, "execution_count": 61, "metadata": {}, "output_type": "execute_result"}], "source": ["pt1"]}, {"cell_type": "code", "execution_count": 62, "metadata": {"collapsed": true}, "outputs": [], "source": ["x, y = pt1"]}, {"cell_type": "code", "execution_count": 63, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["10 20\n"]}], "source": ["print(x, y)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can also use extended unpacking:"]}, {"cell_type": "code", "execution_count": 64, "metadata": {}, "outputs": [{"data": {"text/plain": ["Stock(symbol='DJIA', year=2018, month=1, day=25, open=26313, high=26458, low=26260, close=26393)"]}, "execution_count": 64, "metadata": {}, "output_type": "execute_result"}], "source": ["djia"]}, {"cell_type": "code", "execution_count": 65, "metadata": {"collapsed": true}, "outputs": [], "source": ["symbol, *_, close = djia"]}, {"cell_type": "code", "execution_count": 66, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["DJIA 26393\n"]}], "source": ["print(symbol, close)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["And remember that the `_` we use in the unpacking is just a regular variable:"]}, {"cell_type": "code", "execution_count": 67, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["[2018, 1, 25, 26313, 26458, 26260]\n"]}], "source": ["print(_)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The field names for these named tuples can be any valid variable name **except** that they cannot start with an underscore. \n", "\n", "For example the following would not be valid:"]}, {"cell_type": "code", "execution_count": 68, "metadata": {}, "outputs": [{"ename": "ValueError", "evalue": "Field names cannot start with an underscore: '_age'", "output_type": "error", "traceback": ["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[1;31mValueError\u001b[0m                                Traceback (most recent call last)", "\u001b[1;32m<ipython-input-68-cc651156ccc1>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[1;32m----> 1\u001b[1;33m \u001b[0mPerson\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mnamedtuple\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34m'Person'\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;33m[\u001b[0m\u001b[1;34m'firstname'\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;34m'lastname'\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;34m'_age'\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;34m'ssn'\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m", "\u001b[1;32mD:\\Users\\fbapt\\Anaconda3\\envs\\deepdive\\lib\\collections\\__init__.py\u001b[0m in \u001b[0;36mnamedtuple\u001b[1;34m(typename, field_names, verbose, rename, module)\u001b[0m\n\u001b[0;32m    409\u001b[0m         \u001b[1;32mif\u001b[0m \u001b[0mname\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mstartswith\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34m'_'\u001b[0m\u001b[1;33m)\u001b[0m \u001b[1;32mand\u001b[0m \u001b[1;32mnot\u001b[0m \u001b[0mrename\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    410\u001b[0m             raise ValueError('Field names cannot start with an underscore: '\n\u001b[1;32m--> 411\u001b[1;33m                              '%r' % name)\n\u001b[0m\u001b[0;32m    412\u001b[0m         \u001b[1;32mif\u001b[0m \u001b[0mname\u001b[0m \u001b[1;32min\u001b[0m \u001b[0mseen\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    413\u001b[0m             \u001b[1;32mraise\u001b[0m \u001b[0mValueError\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34m'Encountered duplicate field name: %r'\u001b[0m \u001b[1;33m%\u001b[0m \u001b[0mname\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n", "\u001b[1;31mValueError\u001b[0m: Field names cannot start with an underscore: '_age'"]}], "source": ["Person = namedtuple('Person', ['firstname', 'lastname', '_age', 'ssn'])"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can also choose to let the `namedtuple` function replace invalid field names automatically for us, by using the keyword argument `rename`. When we set that argument to `True` (it is `False` by default) it will replace the invalid name using the position (index) of the field, preceded by an underscore:"]}, {"cell_type": "code", "execution_count": 69, "metadata": {"collapsed": true}, "outputs": [], "source": ["Person = namedtuple('Person', ['firstname', 'lastname', '_age', 'ssn'], rename=True)"]}, {"cell_type": "code", "execution_count": 70, "metadata": {"collapsed": true}, "outputs": [], "source": ["eric = Person('Eric', 'Idle', 42, 'unknown')"]}, {"cell_type": "code", "execution_count": 71, "metadata": {}, "outputs": [{"data": {"text/plain": ["Person(firstname='Eric', lastname='Idle', _2=42, ssn='unknown')"]}, "execution_count": 71, "metadata": {}, "output_type": "execute_result"}], "source": ["eric"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see the invalid field name `_y` was replaced by `_1` since it was the second element (i.e. index of `1`)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Named Tuple Internals"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can easily find out the fields in a named tuple using the `_fields` property:"]}, {"cell_type": "code", "execution_count": 72, "metadata": {}, "outputs": [{"data": {"text/plain": ["('x', 'y')"]}, "execution_count": 72, "metadata": {}, "output_type": "execute_result"}], "source": ["Point2D._fields"]}, {"cell_type": "code", "execution_count": 73, "metadata": {}, "outputs": [{"data": {"text/plain": ["('symbol', 'year', 'month', 'day', 'open', 'high', 'low', 'close')"]}, "execution_count": 73, "metadata": {}, "output_type": "execute_result"}], "source": ["Stock._fields"]}, {"cell_type": "markdown", "metadata": {}, "source": ["There is also a property, `_source` that allows us to see exactly the class that was generated by calling `namedtuple` (remember that `namedtuple` is a class **factory**):"]}, {"cell_type": "code", "execution_count": 74, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["from builtins import property as _property, tuple as _tuple\n", "from operator import itemgetter as _itemgetter\n", "from collections import OrderedDict\n", "\n", "class Point2D(tuple):\n", "    'Point2D(x, y)'\n", "\n", "    __slots__ = ()\n", "\n", "    _fields = ('x', 'y')\n", "\n", "    def __new__(_cls, x, y):\n", "        'Create new instance of Point2D(x, y)'\n", "        return _tuple.__new__(_cls, (x, y))\n", "\n", "    @classmethod\n", "    def _make(cls, iterable, new=tuple.__new__, len=len):\n", "        'Make a new Point2D object from a sequence or iterable'\n", "        result = new(cls, iterable)\n", "        if len(result) != 2:\n", "            raise TypeError('Expected 2 arguments, got %d' % len(result))\n", "        return result\n", "\n", "    def _replace(_self, **kwds):\n", "        'Return a new Point2D object replacing specified fields with new values'\n", "        result = _self._make(map(kwds.pop, ('x', 'y'), _self))\n", "        if kwds:\n", "            raise ValueError('Got unexpected field names: %r' % list(kwds))\n", "        return result\n", "\n", "    def __repr__(self):\n", "        'Return a nicely formatted representation string'\n", "        return self.__class__.__name__ + '(x=%r, y=%r)' % self\n", "\n", "    def _asdict(self):\n", "        'Return a new OrderedDict which maps field names to their values.'\n", "        return OrderedDict(zip(self._fields, self))\n", "\n", "    def __getnewargs__(self):\n", "        'Return self as a plain tuple.  Used by copy and pickle.'\n", "        return tuple(self)\n", "\n", "    x = _property(_itemgetter(0), doc='Alias for field number 0')\n", "\n", "    y = _property(_itemgetter(1), doc='Alias for field number 1')\n", "\n", "\n"]}], "source": ["print(Point2D._source)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["And of course this will be slightly different for another named tuple generated class:"]}, {"cell_type": "code", "execution_count": 75, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["from builtins import property as _property, tuple as _tuple\n", "from operator import itemgetter as _itemgetter\n", "from collections import OrderedDict\n", "\n", "class Person(tuple):\n", "    'Person(firstname, lastname, _2, ssn)'\n", "\n", "    __slots__ = ()\n", "\n", "    _fields = ('firstname', 'lastname', '_2', 'ssn')\n", "\n", "    def __new__(_cls, firstname, lastname, _2, ssn):\n", "        'Create new instance of Person(firstname, lastname, _2, ssn)'\n", "        return _tuple.__new__(_cls, (firstname, lastname, _2, ssn))\n", "\n", "    @classmethod\n", "    def _make(cls, iterable, new=tuple.__new__, len=len):\n", "        'Make a new Person object from a sequence or iterable'\n", "        result = new(cls, iterable)\n", "        if len(result) != 4:\n", "            raise TypeError('Expected 4 arguments, got %d' % len(result))\n", "        return result\n", "\n", "    def _replace(_self, **kwds):\n", "        'Return a new Person object replacing specified fields with new values'\n", "        result = _self._make(map(kwds.pop, ('firstname', 'lastname', '_2', 'ssn'), _self))\n", "        if kwds:\n", "            raise ValueError('Got unexpected field names: %r' % list(kwds))\n", "        return result\n", "\n", "    def __repr__(self):\n", "        'Return a nicely formatted representation string'\n", "        return self.__class__.__name__ + '(firstname=%r, lastname=%r, _2=%r, ssn=%r)' % self\n", "\n", "    def _asdict(self):\n", "        'Return a new OrderedDict which maps field names to their values.'\n", "        return OrderedDict(zip(self._fields, self))\n", "\n", "    def __getnewargs__(self):\n", "        'Return self as a plain tuple.  Used by copy and pickle.'\n", "        return tuple(self)\n", "\n", "    firstname = _property(_itemgetter(0), doc='Alias for field number 0')\n", "\n", "    lastname = _property(_itemgetter(1), doc='Alias for field number 1')\n", "\n", "    _2 = _property(_itemgetter(2), doc='Alias for field number 2')\n", "\n", "    ssn = _property(_itemgetter(3), doc='Alias for field number 3')\n", "\n", "\n"]}], "source": ["print(Person._source)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Converting Named Tuples to Dictionaries"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The `namedtuple` generated class also provides us an instance method, `_asdict()` that will create a dictionary from all the fields in the named tuple:"]}, {"cell_type": "code", "execution_count": 76, "metadata": {}, "outputs": [{"data": {"text/plain": ["OrderedDict([('firstname', 'Eric'),\n", "             ('lastname', 'Idle'),\n", "             ('_2', 42),\n", "             ('ssn', 'unknown')])"]}, "execution_count": 76, "metadata": {}, "output_type": "execute_result"}], "source": ["eric._asdict()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Technically, it is an `OrderedDict` which we will cover in later section. Basically an `OrderedDict` is a dictionary that, unlike the standard built-in `Dictionary` is **guaranteed** to preserve the order of the keys.\n", "\n", "[**Note** that as of Python 3.6, regular dictionaries **do** preserve the order of the keys, but until just recently it was not **guaranteed** and was bascially an implementation detail.\n", "\n", "**However, this has now changed!!** Guido van Rossum has now agreed that this is no longer an implementation detail, and starting in Python 3.7 dictionary order is guaranteed. Since it is actually already the case in Python 3.6, you can now safely assume this fact - as long as you are running your code under Python 3.6 or higher. Your code will break if you rely on dictionary order prior to 3.6, in that case, still use an `OrderedDict`]"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Overhead of Named Tuples"]}, {"cell_type": "markdown", "metadata": {}, "source": ["At this point you may be wondering whether there's more overhead to using a named tuple vs a regular tuple.\n", "\n", "There is, but it is tiny. The field names are stored in the **class**, not every instance of the named tuples.\n", "This means that the overhead incurred by the field names for one instance of the named tuple vs 1000 instances is the same. Otherwise, the instances are tuples, so you can access contained objects using indexing, slicing and iteration just as if it were a plain tuple. No overhead there either. Looking up values by name do have some overhead of course, but no more than if you had created a custom class."]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Named Tuples - Modifying and Extending"]}, {"cell_type": "code", "execution_count": 1, "metadata": {"collapsed": true}, "outputs": [], "source": ["from collections import namedtuple"]}, {"cell_type": "code", "execution_count": 2, "metadata": {"collapsed": true}, "outputs": [], "source": ["Point2D = namedtuple('Point2D', 'x y')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The objects generated by `namedtuple` generated classes are **immutable**.\n", "\n", "In other words the following will not work:"]}, {"cell_type": "code", "execution_count": 3, "metadata": {"collapsed": true}, "outputs": [], "source": ["origin = Point2D(10,0)"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"ename": "AttributeError", "evalue": "can't set attribute", "output_type": "error", "traceback": ["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[1;31mAttributeError\u001b[0m                            Traceback (most recent call last)", "\u001b[1;32m<ipython-input-4-ebd2d3bb5d60>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[1;32m----> 1\u001b[1;33m \u001b[0morigin\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mx\u001b[0m \u001b[1;33m=\u001b[0m \u001b[1;36m0\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m", "\u001b[1;31mAttributeError\u001b[0m: can't set attribute"]}], "source": ["origin.x = 0"]}, {"cell_type": "markdown", "metadata": {}, "source": ["However, we may want to \"change\" the value of one of the coordinates of our `origin` variable.\n", "\n", "This is just like strings, we have to create a new version of the tuple, and assign it to the same label.\n", "\n", "Suppose we want to change the x-coordinate of our `origin` to something else, but retain whatever the y-coordinate was.\n", "\n", "We could do it as follows:"]}, {"cell_type": "code", "execution_count": 5, "metadata": {"collapsed": true}, "outputs": [], "source": ["origin = Point2D(0, origin.y)"]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [{"data": {"text/plain": ["Point2D(x=0, y=0)"]}, "execution_count": 6, "metadata": {}, "output_type": "execute_result"}], "source": ["origin"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Of course this could become quite unwieldy when we have a larger number of properties and we only need to change a single item:"]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [], "source": ["Stock = namedtuple('Stock', 'symbol year month day open high low close')"]}, {"cell_type": "code", "execution_count": 8, "metadata": {"collapsed": true}, "outputs": [], "source": ["djia = Stock('DJIA', 2018, 1, 25, 26_313, 26_458, 26_260, 26_393)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["To update the `close` property for example, we could write:"]}, {"cell_type": "code", "execution_count": 9, "metadata": {"collapsed": true}, "outputs": [], "source": ["djia = Stock(djia.symbol, djia.year, djia.month, djia.day, \n", "                  djia.open, djia.high, djia.low, 26_394)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now that was quite painful!\n", "\n", "We can be a bit more clever about this and use tuple unpacking and argument unpacking as follows:"]}, {"cell_type": "code", "execution_count": 10, "metadata": {"collapsed": true}, "outputs": [], "source": ["*values, _ = djia"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We didn't care about the `close` price since we are replacing it, hence the underscore variable name.\n", "\n", "And we now have everything else in a list:"]}, {"cell_type": "code", "execution_count": 11, "metadata": {}, "outputs": [{"data": {"text/plain": ["['DJIA', 2018, 1, 25, 26313, 26458, 26260]"]}, "execution_count": 11, "metadata": {}, "output_type": "execute_result"}], "source": ["values"]}, {"cell_type": "markdown", "metadata": {}, "source": ["And now we are going to use the `*` again, but this time to unpack the list into separate arguments when we call the `Stock` initializer:"]}, {"cell_type": "code", "execution_count": 12, "metadata": {"collapsed": true}, "outputs": [], "source": ["djia = Stock(*values, 26_393)"]}, {"cell_type": "code", "execution_count": 13, "metadata": {}, "outputs": [{"data": {"text/plain": ["Stock(symbol='DJIA', year=2018, month=1, day=25, open=26313, high=26458, low=26260, close=26393)"]}, "execution_count": 13, "metadata": {}, "output_type": "execute_result"}], "source": ["djia"]}, {"cell_type": "markdown", "metadata": {}, "source": ["This is much better than our first attempt!\n", "\n", "But this approach does not always work, what happens if we want to change a values somewhere in the middle? Or two values?\n", "\n", "We cannot do: \n", "`*first, month, *last = djia`\n", "\n", "That would make no sense whatsoever! (and Python will tell you so!)\n", "\n", "Maybe slicing and unpacking can work here..."]}, {"cell_type": "code", "execution_count": 14, "metadata": {}, "outputs": [{"data": {"text/plain": ["Stock(symbol='DJIA', year=2018, month=1, day=25, open=26313, high=26458, low=26260, close=26393)"]}, "execution_count": 14, "metadata": {}, "output_type": "execute_result"}], "source": ["djia"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We could try **slicing**:"]}, {"cell_type": "code", "execution_count": 15, "metadata": {}, "outputs": [{"data": {"text/plain": ["('DJIA', 2018, 1)"]}, "execution_count": 15, "metadata": {}, "output_type": "execute_result"}], "source": ["djia[:3]"]}, {"cell_type": "code", "execution_count": 16, "metadata": {}, "outputs": [{"data": {"text/plain": ["('DJIA', 2018, 1, 26, 26313, 26458, 26260, 26393)"]}, "execution_count": 16, "metadata": {}, "output_type": "execute_result"}], "source": ["djia[:3] + (26,) + djia[4:]"]}, {"cell_type": "markdown", "metadata": {}, "source": ["So now we could use this to create a new StockPrice instance:"]}, {"cell_type": "code", "execution_count": 17, "metadata": {"collapsed": true}, "outputs": [], "source": ["djia2 = Stock(*(djia[:3] + (26,) + djia[4:]))"]}, {"cell_type": "code", "execution_count": 18, "metadata": {}, "outputs": [{"data": {"text/plain": ["Stock(symbol='DJIA', year=2018, month=1, day=26, open=26313, high=26458, low=26260, close=26393)"]}, "execution_count": 18, "metadata": {}, "output_type": "execute_result"}], "source": ["djia2"]}, {"cell_type": "markdown", "metadata": {}, "source": ["This works, but that's quite cumbersome...\n", "\n", "And it gets worse - suppose we want to modify the year and day using this approach:"]}, {"cell_type": "code", "execution_count": 19, "metadata": {}, "outputs": [{"data": {"text/plain": ["Stock(symbol='DJIA', year=2018, month=1, day=25, open=26313, high=26458, low=26260, close=26393)"]}, "execution_count": 19, "metadata": {}, "output_type": "execute_result"}], "source": ["djia"]}, {"cell_type": "code", "execution_count": 20, "metadata": {"collapsed": true}, "outputs": [], "source": ["values = djia[0:1] + (2019,) + djia[2:3] + (26,) + djia[4:]"]}, {"cell_type": "code", "execution_count": 21, "metadata": {}, "outputs": [{"data": {"text/plain": ["('DJIA', 2019, 1, 26, 26313, 26458, 26260, 26393)"]}, "execution_count": 21, "metadata": {}, "output_type": "execute_result"}], "source": ["values"]}, {"cell_type": "code", "execution_count": 22, "metadata": {"collapsed": true}, "outputs": [], "source": ["djia3 = Stock(*values)"]}, {"cell_type": "code", "execution_count": 23, "metadata": {}, "outputs": [{"data": {"text/plain": ["Stock(symbol='DJIA', year=2019, month=1, day=26, open=26313, high=26458, low=26260, close=26393)"]}, "execution_count": 23, "metadata": {}, "output_type": "execute_result"}], "source": ["djia3"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Or, if you want to avoid unpacking the `values` into the multiple positional arguments required by the `Stock` constructor, we can make us of the `_make` class method that can use an iterable:"]}, {"cell_type": "code", "execution_count": 24, "metadata": {}, "outputs": [], "source": ["djia4 = Stock._make(values)"]}, {"cell_type": "code", "execution_count": 25, "metadata": {}, "outputs": [{"data": {"text/plain": ["Stock(symbol='DJIA', year=2019, month=1, day=26, open=26313, high=26458, low=26260, close=26393)"]}, "execution_count": 25, "metadata": {}, "output_type": "execute_result"}], "source": ["djia4"]}, {"cell_type": "markdown", "metadata": {}, "source": ["This is really getting too complex.\n", "\n", "Fortunately there's a better way!\n", "\n", "The namedtuple implementation also provides another instance method called `_replace` which takes keyword-only arguments. That method will make a copy of the current tuple and substitute property values based on the keyword-only arguments passed in."]}, {"cell_type": "code", "execution_count": 26, "metadata": {}, "outputs": [{"data": {"text/plain": ["Stock(symbol='DJIA', year=2018, month=1, day=25, open=26313, high=26458, low=26260, close=26393)"]}, "execution_count": 26, "metadata": {}, "output_type": "execute_result"}], "source": ["djia"]}, {"cell_type": "code", "execution_count": 27, "metadata": {}, "outputs": [{"data": {"text/plain": ["2785020879400"]}, "execution_count": 27, "metadata": {}, "output_type": "execute_result"}], "source": ["id(djia)"]}, {"cell_type": "code", "execution_count": 28, "metadata": {"collapsed": true}, "outputs": [], "source": ["djia5 = djia._replace(year=2019, day=26)"]}, {"cell_type": "code", "execution_count": 29, "metadata": {}, "outputs": [{"data": {"text/plain": ["Stock(symbol='DJIA', year=2019, month=1, day=26, open=26313, high=26458, low=26260, close=26393)"]}, "execution_count": 29, "metadata": {}, "output_type": "execute_result"}], "source": ["djia5"]}, {"cell_type": "code", "execution_count": 30, "metadata": {}, "outputs": [{"data": {"text/plain": ["Stock(symbol='DJIA', year=2018, month=1, day=25, open=26313, high=26458, low=26260, close=26393)"]}, "execution_count": 30, "metadata": {}, "output_type": "execute_result"}], "source": ["djia"]}, {"cell_type": "code", "execution_count": 31, "metadata": {}, "outputs": [{"data": {"text/plain": ["2785020880480"]}, "execution_count": 31, "metadata": {}, "output_type": "execute_result"}], "source": ["id(djia5)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Much better!!"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Extending Named Tuples"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Sometimes we may want to add one or more properties to an existing class without modifying the code for the custom class itself.\n", "\n", "Using inheritance is one way to go about it so you may be tempted to do this with named tuples as well, but it's not easy, and there's a cleaner way to do this if all you're after is additional data fields.\n", "\n", "Let's say we have a Point class that is for 2D problems:"]}, {"cell_type": "code", "execution_count": 32, "metadata": {"collapsed": true}, "outputs": [], "source": ["Point2D = namedtuple('Point2D', 'x y')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We could easily create a 3D point class as follows:"]}, {"cell_type": "code", "execution_count": 33, "metadata": {"collapsed": true}, "outputs": [], "source": ["Point3D = namedtuple('Point3D', 'x y z')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But if our named tuple has many fields, such as our `Stock` named tuple that's a little more difficult:"]}, {"cell_type": "code", "execution_count": 34, "metadata": {}, "outputs": [{"data": {"text/plain": ["Stock(symbol='DJIA', year=2018, month=1, day=25, open=26313, high=26458, low=26260, close=26393)"]}, "execution_count": 34, "metadata": {}, "output_type": "execute_result"}], "source": ["djia"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Suppose we want to create a new class, say `StockExt`, it would take some effort:"]}, {"cell_type": "code", "execution_count": 35, "metadata": {"collapsed": true}, "outputs": [], "source": ["StockExt = namedtuple('StockExt', \n", "                      '''symbol year month day open high low \n", "                      close previous_close''')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Instead we can leverage that `_fields` property:"]}, {"cell_type": "code", "execution_count": 36, "metadata": {}, "outputs": [{"data": {"text/plain": ["('symbol', 'year', 'month', 'day', 'open', 'high', 'low', 'close')"]}, "execution_count": 36, "metadata": {}, "output_type": "execute_result"}], "source": ["Stock._fields"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Remember that the `namedtuple` initializer can handle a list or tuple containing the field names. For example, the one we just retrieved from `_fields`.\n", "\n", "Now all we need to do is create a new tuple that contains those fields along with whatever extras we want:"]}, {"cell_type": "code", "execution_count": 37, "metadata": {"collapsed": true}, "outputs": [], "source": ["new_fields = Stock._fields + ('previous_close',)"]}, {"cell_type": "code", "execution_count": 38, "metadata": {}, "outputs": [{"data": {"text/plain": ["('symbol',\n", " 'year',\n", " 'month',\n", " 'day',\n", " 'open',\n", " 'high',\n", " 'low',\n", " 'close',\n", " 'previous_close')"]}, "execution_count": 38, "metadata": {}, "output_type": "execute_result"}], "source": ["new_fields"]}, {"cell_type": "markdown", "metadata": {}, "source": ["And now we can create our new named tuple this way:"]}, {"cell_type": "code", "execution_count": 39, "metadata": {"collapsed": true}, "outputs": [], "source": ["StockExt = namedtuple('StockExt', Stock._fields + ('previous_close',))"]}, {"cell_type": "code", "execution_count": 40, "metadata": {}, "outputs": [{"data": {"text/plain": ["('symbol',\n", " 'year',\n", " 'month',\n", " 'day',\n", " 'open',\n", " 'high',\n", " 'low',\n", " 'close',\n", " 'previous_close')"]}, "execution_count": 40, "metadata": {}, "output_type": "execute_result"}], "source": ["StockExt._fields"]}, {"cell_type": "markdown", "metadata": {}, "source": ["If you did not want to use tuple concatenation for some reason, you could also do it using strings:"]}, {"cell_type": "code", "execution_count": 41, "metadata": {}, "outputs": [{"data": {"text/plain": ["'symbol year month day open high low close previous_close'"]}, "execution_count": 41, "metadata": {}, "output_type": "execute_result"}], "source": ["' '.join(Stock._fields) + ' previous_close'"]}, {"cell_type": "code", "execution_count": 42, "metadata": {"collapsed": true}, "outputs": [], "source": ["StockExt = namedtuple('StockExt', \n", "                      ' '.join(Stock._fields) + ' previous_close')"]}, {"cell_type": "code", "execution_count": 43, "metadata": {}, "outputs": [{"data": {"text/plain": ["('symbol',\n", " 'year',\n", " 'month',\n", " 'day',\n", " 'open',\n", " 'high',\n", " 'low',\n", " 'close',\n", " 'previous_close')"]}, "execution_count": 43, "metadata": {}, "output_type": "execute_result"}], "source": ["StockExt._fields"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now, with this newly extended class, we may want to take one of the \"old\" named tuple instance (`djia`) and create the extended version of it using the `StockExt` class.\n", "\n", "This is also quite simple to do, since named tuples are tuples, and can therefore be unpacked in the arguments of a function call."]}, {"cell_type": "code", "execution_count": 44, "metadata": {}, "outputs": [{"data": {"text/plain": ["Stock(symbol='DJIA', year=2018, month=1, day=25, open=26313, high=26458, low=26260, close=26393)"]}, "execution_count": 44, "metadata": {}, "output_type": "execute_result"}], "source": ["djia"]}, {"cell_type": "code", "execution_count": 45, "metadata": {"collapsed": true}, "outputs": [], "source": ["djia_ext = StockExt(*djia, 25_000)"]}, {"cell_type": "code", "execution_count": 46, "metadata": {"scrolled": true}, "outputs": [{"data": {"text/plain": ["StockExt(symbol='DJIA', year=2018, month=1, day=25, open=26313, high=26458, low=26260, close=26393, previous_close=25000)"]}, "execution_count": 46, "metadata": {}, "output_type": "execute_result"}], "source": ["djia_ext"]}, {"cell_type": "markdown", "metadata": {}, "source": ["or, we can use the `_make` method:"]}, {"cell_type": "code", "execution_count": 47, "metadata": {"collapsed": true}, "outputs": [], "source": ["djia_ext = StockExt._make(djia + (25_000, ))"]}, {"cell_type": "code", "execution_count": 48, "metadata": {}, "outputs": [{"data": {"text/plain": ["StockExt(symbol='DJIA', year=2018, month=1, day=25, open=26313, high=26458, low=26260, close=26393, previous_close=25000)"]}, "execution_count": 48, "metadata": {}, "output_type": "execute_result"}], "source": ["djia_ext"]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Named Tuples - DocStrings and Default Values"]}, {"cell_type": "code", "execution_count": 1, "metadata": {"collapsed": true}, "outputs": [], "source": ["from collections import namedtuple"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Adding DocStrings to Named Tuples"]}, {"cell_type": "markdown", "metadata": {}, "source": ["This is easy to do, both with the generated class, as well as it's properties."]}, {"cell_type": "code", "execution_count": 2, "metadata": {"collapsed": true}, "outputs": [], "source": ["Point2D = namedtuple('Point2D', 'x y')"]}, {"cell_type": "code", "execution_count": 3, "metadata": {"collapsed": true}, "outputs": [], "source": ["Point2D.__doc__ = 'Represents a 2D Cartesian coordinate'"]}, {"cell_type": "markdown", "metadata": {}, "source": ["And we can even add docstrings to the properties:"]}, {"cell_type": "code", "execution_count": 4, "metadata": {"collapsed": true}, "outputs": [], "source": ["Point2D.x.__doc__ = 'x-coordinate'\n", "Point2D.y.__doc__ = 'y-coordinate'"]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Help on class Point2D in module __main__:\n", "\n", "class Point2D(builtins.tuple)\n", " |  Represents a 2D Cartesian coordinate\n", " |  \n", " |  Method resolution order:\n", " |      Point2D\n", " |      builtins.tuple\n", " |      builtins.object\n", " |  \n", " |  Methods defined here:\n", " |  \n", " |  __getnewargs__(self)\n", " |      Return self as a plain tuple.  Used by copy and pickle.\n", " |  \n", " |  __repr__(self)\n", " |      Return a nicely formatted representation string\n", " |  \n", " |  _asdict(self)\n", " |      Return a new OrderedDict which maps field names to their values.\n", " |  \n", " |  _replace(_self, **kwds)\n", " |      Return a new Point2D object replacing specified fields with new values\n", " |  \n", " |  ----------------------------------------------------------------------\n", " |  Class methods defined here:\n", " |  \n", " |  _make(iterable, new=<built-in method __new__ of type object at 0x00000000595CB160>, len=<built-in function len>) from builtins.type\n", " |      Make a new Point2D object from a sequence or iterable\n", " |  \n", " |  ----------------------------------------------------------------------\n", " |  Static methods defined here:\n", " |  \n", " |  __new__(_cls, x, y)\n", " |      Create new instance of Point2D(x, y)\n", " |  \n", " |  ----------------------------------------------------------------------\n", " |  Data descriptors defined here:\n", " |  \n", " |  x\n", " |      x-coordinate\n", " |  \n", " |  y\n", " |      y-coordinate\n", " |  \n", " |  ----------------------------------------------------------------------\n", " |  Data and other attributes defined here:\n", " |  \n", " |  _fields = ('x', 'y')\n", " |  \n", " |  _source = \"from builtins import property as _property, tupl..._itemget...\n", " |  \n", " |  ----------------------------------------------------------------------\n", " |  Methods inherited from builtins.tuple:\n", " |  \n", " |  __add__(self, value, /)\n", " |      Return self+value.\n", " |  \n", " |  __contains__(self, key, /)\n", " |      Return key in self.\n", " |  \n", " |  __eq__(self, value, /)\n", " |      Return self==value.\n", " |  \n", " |  __ge__(self, value, /)\n", " |      Return self>=value.\n", " |  \n", " |  __getattribute__(self, name, /)\n", " |      Return getattr(self, name).\n", " |  \n", " |  __getitem__(self, key, /)\n", " |      Return self[key].\n", " |  \n", " |  __gt__(self, value, /)\n", " |      Return self>value.\n", " |  \n", " |  __hash__(self, /)\n", " |      Return hash(self).\n", " |  \n", " |  __iter__(self, /)\n", " |      Implement iter(self).\n", " |  \n", " |  __le__(self, value, /)\n", " |      Return self<=value.\n", " |  \n", " |  __len__(self, /)\n", " |      Return len(self).\n", " |  \n", " |  __lt__(self, value, /)\n", " |      Return self<value.\n", " |  \n", " |  __mul__(self, value, /)\n", " |      Return self*value.n\n", " |  \n", " |  __ne__(self, value, /)\n", " |      Return self!=value.\n", " |  \n", " |  __rmul__(self, value, /)\n", " |      Return self*value.\n", " |  \n", " |  count(...)\n", " |      T.count(value) -> integer -- return number of occurrences of value\n", " |  \n", " |  index(...)\n", " |      T.index(value, [start, [stop]]) -> integer -- return first index of value.\n", " |      Raises ValueError if the value is not present.\n", "\n"]}], "source": ["help(Point2D)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Adding Default Values to Named Tuples"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Using a Prototype"]}, {"cell_type": "markdown", "metadata": {}, "source": ["This technique is in the Python docs, and uses the concept of creating a prototype object that has the default values set:"]}, {"cell_type": "code", "execution_count": 6, "metadata": {"collapsed": true}, "outputs": [], "source": ["Vector = namedtuple('Vector', 'x1 y1 x2 y2 origin_x origin_y')"]}, {"cell_type": "code", "execution_count": 7, "metadata": {"collapsed": true}, "outputs": [], "source": ["vector_zeroorigin = Vector(x1=None, y1=None, x2=None, y2=None, origin_x=0, origin_y=0)"]}, {"cell_type": "code", "execution_count": 8, "metadata": {}, "outputs": [{"data": {"text/plain": ["Vector(x1=None, y1=None, x2=None, y2=None, origin_x=0, origin_y=0)"]}, "execution_count": 8, "metadata": {}, "output_type": "execute_result"}], "source": ["vector_zeroorigin"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The named tuple `vector_zeroorigin` is now a prototype of a vector with zero origin.\n", "\n", "To create new vectors using that origin as a default, we no longer use the `Vector` class, but instead use `_replace` as follows:"]}, {"cell_type": "code", "execution_count": 9, "metadata": {"collapsed": true}, "outputs": [], "source": ["v1 = vector_zeroorigin._replace(x1=1, y1=1, x2=10, y2=10)"]}, {"cell_type": "code", "execution_count": 10, "metadata": {}, "outputs": [{"data": {"text/plain": ["Vector(x1=1, y1=1, x2=10, y2=10, origin_x=0, origin_y=0)"]}, "execution_count": 10, "metadata": {}, "output_type": "execute_result"}], "source": ["v1"]}, {"cell_type": "markdown", "metadata": {}, "source": ["This certainly works, and can be useful in cases where you may want more than one prototype (e.g. `vector_zeroorigin` and `vector_otherorigin`)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Using `__defaults__`"]}, {"cell_type": "markdown", "metadata": {}, "source": ["There is an alternative way of doing this. And, in my opinion, a much cleaner alternative."]}, {"cell_type": "markdown", "metadata": {}, "source": ["In Python the default values for a function's parameters are stored as a tuple in the `__defaults__` attribute.\n", "\n"]}, {"cell_type": "code", "execution_count": 11, "metadata": {"collapsed": true}, "outputs": [], "source": ["def func(a, b=20, c=30):\n", "    print(a, b, c)"]}, {"cell_type": "code", "execution_count": 12, "metadata": {}, "outputs": [{"data": {"text/plain": ["(20, 30)"]}, "execution_count": 12, "metadata": {}, "output_type": "execute_result"}], "source": ["func.__defaults__"]}, {"cell_type": "code", "execution_count": 13, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["10 20 30\n"]}], "source": ["func(10)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But the `__defaults__` property is writable:"]}, {"cell_type": "code", "execution_count": 14, "metadata": {}, "outputs": [], "source": ["func.__defaults__ = (200, 300)"]}, {"cell_type": "code", "execution_count": 15, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["10 200 300\n"]}], "source": ["func(10)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["In this case, the function we are interested in specifying default values for, is the named tuple class constructor, i.e. `__new__`.\n", "\n", "So, we will simply need to set `Vector.__new__.__defaults__` to the desired tuple of default values.\n", "\n", "The only thing to note is that if you specify less default values (say `m` values) than the total number of arguments (say `n` values, where `m < n`), then the defaults will apply to the **last** `m` values. Think of it as writing out your field names and default values on two lines, and right-aligning them. (If you specify more, then the values at the beginning are effectively ignored)"]}, {"cell_type": "code", "execution_count": 16, "metadata": {}, "outputs": [], "source": ["Vector.__new__.__defaults__ = (0, 0)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Here I am basically setting default values for the last two elements only, i.e. `origin_x` and `origin_y`."]}, {"cell_type": "code", "execution_count": 17, "metadata": {"collapsed": true}, "outputs": [], "source": ["v1 = Vector(0, 0, 10, 10, -10, -10)"]}, {"cell_type": "code", "execution_count": 18, "metadata": {}, "outputs": [{"data": {"text/plain": ["Vector(x1=0, y1=0, x2=10, y2=10, origin_x=-10, origin_y=-10)"]}, "execution_count": 18, "metadata": {}, "output_type": "execute_result"}], "source": ["v1"]}, {"cell_type": "code", "execution_count": 19, "metadata": {"collapsed": true}, "outputs": [], "source": ["v2 = Vector(5, 5, 20, 20)"]}, {"cell_type": "code", "execution_count": 20, "metadata": {}, "outputs": [{"data": {"text/plain": ["Vector(x1=5, y1=5, x2=20, y2=20, origin_x=0, origin_y=0)"]}, "execution_count": 20, "metadata": {}, "output_type": "execute_result"}], "source": ["v2"]}, {"cell_type": "code", "execution_count": 21, "metadata": {"collapsed": true}, "outputs": [], "source": ["v3 = Vector(x1=1, y1=1, x2=10, y2=10)"]}, {"cell_type": "code", "execution_count": 22, "metadata": {}, "outputs": [{"data": {"text/plain": ["Vector(x1=1, y1=1, x2=10, y2=10, origin_x=0, origin_y=0)"]}, "execution_count": 22, "metadata": {}, "output_type": "execute_result"}], "source": ["v3"]}, {"cell_type": "markdown", "metadata": {}, "source": ["An even simpler way to set default values if you want **all** the defaults to be the same:"]}, {"cell_type": "code", "execution_count": 23, "metadata": {"collapsed": true}, "outputs": [], "source": ["Vector.__new__.__defaults__ = (0,) * len(Vector._fields)"]}, {"cell_type": "code", "execution_count": 24, "metadata": {"collapsed": true}, "outputs": [], "source": ["v5 = Vector()"]}, {"cell_type": "code", "execution_count": 25, "metadata": {}, "outputs": [{"data": {"text/plain": ["Vector(x1=0, y1=0, x2=0, y2=0, origin_x=0, origin_y=0)"]}, "execution_count": 25, "metadata": {}, "output_type": "execute_result"}], "source": ["v5"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Of course, the usual admonishment of not using mutable default values holds here as well."]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Named Tuples - Application - Alternative to Dictionaries"]}, {"cell_type": "markdown", "metadata": {}, "source": ["First an important caveat: all this really only works for dictionaries with **string** keys. Dictionary keys can be other hashable data types, (including tuples, as long as they contain hashable types in turn), and these examples will not work with those types of dictionaries."]}, {"cell_type": "code", "execution_count": 4, "metadata": {"collapsed": true}, "outputs": [], "source": ["from collections import namedtuple"]}, {"cell_type": "code", "execution_count": 11, "metadata": {"collapsed": true}, "outputs": [], "source": ["data_dict = dict(key1=100, key2=200, key3=300)"]}, {"cell_type": "code", "execution_count": 12, "metadata": {"collapsed": true}, "outputs": [], "source": ["Data = namedtuple('Data', data_dict.keys())"]}, {"cell_type": "code", "execution_count": 13, "metadata": {}, "outputs": [{"data": {"text/plain": ["('key1', 'key2', 'key3')"]}, "execution_count": 13, "metadata": {}, "output_type": "execute_result"}], "source": ["Data._fields"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now we can create an instance of the `Data` named tuple using the data in the `data_dict` dictionary. \n", "\n", "We could try the following (bad idea):"]}, {"cell_type": "code", "execution_count": 15, "metadata": {"collapsed": true}, "outputs": [], "source": ["d1 = Data(*data_dict.values())"]}, {"cell_type": "code", "execution_count": 16, "metadata": {}, "outputs": [{"data": {"text/plain": ["Data(key1=100, key2=200, key3=300)"]}, "execution_count": 16, "metadata": {}, "output_type": "execute_result"}], "source": ["d1"]}, {"cell_type": "markdown", "metadata": {}, "source": ["This looks like it worked. \n", "\n", "But consider this second dictionary, where we do not create the keys in the same order:"]}, {"cell_type": "code", "execution_count": 35, "metadata": {"collapsed": true}, "outputs": [], "source": ["data_dict_2 = dict(key1=100, key3=300, key2=200)"]}, {"cell_type": "code", "execution_count": 36, "metadata": {"collapsed": true}, "outputs": [], "source": ["d2 = Data(*data_dict_2.values())"]}, {"cell_type": "code", "execution_count": 37, "metadata": {}, "outputs": [{"data": {"text/plain": ["Data(key1=100, key2=300, key3=200)"]}, "execution_count": 37, "metadata": {}, "output_type": "execute_result"}], "source": ["d2"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Obviously this went terribly wrong!\n", "\n", "We cannot guarantee that the order of `values()` will be in the same order as the keys (in our named tuple and in the dictionary).\n", "\n", "Instead, we should unpack the dictionary itself, resulting in keyword arguments that will be passed to the `Data` constructor:"]}, {"cell_type": "code", "execution_count": 38, "metadata": {"collapsed": true}, "outputs": [], "source": ["d2 = Data(**data_dict_2)"]}, {"cell_type": "code", "execution_count": 39, "metadata": {}, "outputs": [{"data": {"text/plain": ["Data(key1=100, key2=200, key3=300)"]}, "execution_count": 39, "metadata": {}, "output_type": "execute_result"}], "source": ["d2"]}, {"cell_type": "markdown", "metadata": {}, "source": ["So, the pattern to create a named tuple out of a single dictionary is straightforward:\n", "\n", "For any dictionary `d` we can created a named tuple class and insert the data into it as follows:\n", "\n", "`1. Struct = namedtuple('Struct', d.keys())`\n", "\n", "`2. data = Struct(**d)`"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Because dictionaries now preserve key order, the order of the fields in the named tuple structure will be the same. If you want your fields to be sorted in a different way, just sort the keys when you create the named tuple class. For example, to have keys sorted alphabetically we could do:"]}, {"cell_type": "code", "execution_count": 40, "metadata": {"collapsed": true}, "outputs": [], "source": ["data_dict = dict(first_name='John', last_name='Cleese', age=42, complaint='dead parrot')"]}, {"cell_type": "code", "execution_count": 41, "metadata": {}, "outputs": [{"data": {"text/plain": ["dict_keys(['first_name', 'last_name', 'age', 'complaint'])"]}, "execution_count": 41, "metadata": {}, "output_type": "execute_result"}], "source": ["data_dict.keys()"]}, {"cell_type": "code", "execution_count": 44, "metadata": {}, "outputs": [{"data": {"text/plain": ["['age', 'complaint', 'first_name', 'last_name']"]}, "execution_count": 44, "metadata": {}, "output_type": "execute_result"}], "source": ["sorted(data_dict.keys())"]}, {"cell_type": "code", "execution_count": 45, "metadata": {"collapsed": true}, "outputs": [], "source": ["Struct = namedtuple('Struct', sorted(data_dict.keys()))"]}, {"cell_type": "code", "execution_count": 46, "metadata": {}, "outputs": [{"data": {"text/plain": ["('age', 'complaint', 'first_name', 'last_name')"]}, "execution_count": 46, "metadata": {}, "output_type": "execute_result"}], "source": ["Struct._fields"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Of course we can still put in the correct values from the dictionary into the correct slots in the tuple by unpacking the dictionary instead of just the values:"]}, {"cell_type": "code", "execution_count": 48, "metadata": {"collapsed": true}, "outputs": [], "source": ["d1 = Struct(**data_dict)"]}, {"cell_type": "code", "execution_count": 49, "metadata": {}, "outputs": [{"data": {"text/plain": ["Struct(age=42, complaint='dead parrot', first_name='John', last_name='Cleese')"]}, "execution_count": 49, "metadata": {}, "output_type": "execute_result"}], "source": ["d1"]}, {"cell_type": "markdown", "metadata": {}, "source": ["And of course, since this is now a named tuple we can access the data using the field name:"]}, {"cell_type": "code", "execution_count": 50, "metadata": {}, "outputs": [{"data": {"text/plain": ["'dead parrot'"]}, "execution_count": 50, "metadata": {}, "output_type": "execute_result"}], "source": ["d1.complaint"]}, {"cell_type": "markdown", "metadata": {}, "source": ["instead of how we would have done it with the dictionary:"]}, {"cell_type": "code", "execution_count": 51, "metadata": {}, "outputs": [{"data": {"text/plain": ["'dead parrot'"]}, "execution_count": 51, "metadata": {}, "output_type": "execute_result"}], "source": ["data_dict['complaint']"]}, {"cell_type": "markdown", "metadata": {}, "source": ["I also want to point out that with dictionaries we often end up with code where the key is stored in some variable and then referenced this way:"]}, {"cell_type": "code", "execution_count": 53, "metadata": {}, "outputs": [{"data": {"text/plain": ["42"]}, "execution_count": 53, "metadata": {}, "output_type": "execute_result"}], "source": ["key_name = 'age'\n", "data_dict[key_name]"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We cannot use this approach directly with named tuples however. For example this will not work:"]}, {"cell_type": "code", "execution_count": 54, "metadata": {}, "outputs": [{"ename": "AttributeError", "evalue": "'Struct' object has no attribute 'key_name'", "output_type": "error", "traceback": ["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[1;31mAttributeError\u001b[0m                            Traceback (most recent call last)", "\u001b[1;32m<ipython-input-54-f110bbdbc0a7>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[0;32m      1\u001b[0m \u001b[0mkey_name\u001b[0m \u001b[1;33m=\u001b[0m \u001b[1;34m'age'\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m----> 2\u001b[1;33m \u001b[0md1\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mkey_name\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m", "\u001b[1;31mAttributeError\u001b[0m: 'Struct' object has no attribute 'key_name'"]}], "source": ["key_name = 'age'\n", "d1.key_name"]}, {"cell_type": "markdown", "metadata": {}, "source": ["However, we can use the `getattr` function that we have seen before:"]}, {"cell_type": "code", "execution_count": 57, "metadata": {}, "outputs": [{"data": {"text/plain": ["42"]}, "execution_count": 57, "metadata": {}, "output_type": "execute_result"}], "source": ["key_name = 'age'\n", "getattr(d1, key_name)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We also have the `get` method on dictionaries that can specify a default value to return if the key does not exist:"]}, {"cell_type": "code", "execution_count": 59, "metadata": {}, "outputs": [{"data": {"text/plain": ["(42, None)"]}, "execution_count": 59, "metadata": {}, "output_type": "execute_result"}], "source": ["data_dict.get('age', None), data_dict.get('invalid_key', None)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["And we can do the same with the `getattr` function:"]}, {"cell_type": "code", "execution_count": 60, "metadata": {}, "outputs": [{"data": {"text/plain": ["(42, None)"]}, "execution_count": 60, "metadata": {}, "output_type": "execute_result"}], "source": ["getattr(d1, 'age', None), getattr(d1, 'invalid_field', None)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now this is not very useful if you are only working with a single instance of a dictionary that has the same set of keys. Kind of pointless really.\n", "\n", "You also do not want to create a new named tuple for every instance of a dictionary - that would just be way too much overhead.\n", "\n", "But in cases where you have a collection of dictionaries that share a common set of keys, this can be really useful, as long as you are willing to live with the fact that you now have immutable structures."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's suppose we have this data list:"]}, {"cell_type": "code", "execution_count": 3, "metadata": {"collapsed": true}, "outputs": [], "source": ["data_list = [\n", "    {'key1': 1, 'key2': 2},\n", "    {'key1': 3, 'key2': 4},\n", "    {'key1': 5, 'key2': 6, 'key3': 7},\n", "    {'key2': 100}\n", "]"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The first thing to note is that we need to figure out all the possible keys that have been used in the dictionaries in this list."]}, {"cell_type": "markdown", "metadata": {}, "source": ["The easiest way to do this is to extract all the keys of all the dictionaries and then make a `set` out of them, to eliminate duplicate key names:"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We could do it this way, using a simple loop:"]}, {"cell_type": "code", "execution_count": 79, "metadata": {"collapsed": true}, "outputs": [], "source": ["keys = set()\n", "for d in data_list:\n", "    for key in d.keys():\n", "        keys.add(key)"]}, {"cell_type": "code", "execution_count": 80, "metadata": {}, "outputs": [{"data": {"text/plain": ["{'key1', 'key2', 'key3'}"]}, "execution_count": 80, "metadata": {}, "output_type": "execute_result"}], "source": ["keys"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But actually a more efficient way would be to use a comprehension:"]}, {"cell_type": "code", "execution_count": 110, "metadata": {"collapsed": true}, "outputs": [], "source": ["keys = {key for dict_ in data_list for key in dict_.keys()}"]}, {"cell_type": "code", "execution_count": 111, "metadata": {}, "outputs": [{"data": {"text/plain": ["{'key1', 'key2', 'key3'}"]}, "execution_count": 111, "metadata": {}, "output_type": "execute_result"}], "source": ["keys"]}, {"cell_type": "markdown", "metadata": {}, "source": ["In fact, we can also use the fact that we can union multiple sets (we'll cover this in detail later) by unpacking all the keys and creating a union of them:"]}, {"cell_type": "code", "execution_count": 114, "metadata": {"collapsed": true}, "outputs": [], "source": ["keys = set().union(*(dict_.keys() for dict_ in data_list))"]}, {"cell_type": "code", "execution_count": 115, "metadata": {}, "outputs": [{"data": {"text/plain": ["{'key1', 'key2', 'key3'}"]}, "execution_count": 115, "metadata": {}, "output_type": "execute_result"}], "source": ["keys"]}, {"cell_type": "markdown", "metadata": {}, "source": ["However you do it, we end up with a set of all the possible keys used in our list of dictionaries."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now we can go ahead and create a named tuple with all those keys as fields:"]}, {"cell_type": "code", "execution_count": 117, "metadata": {"collapsed": true}, "outputs": [], "source": ["Struct = namedtuple('Struct', keys)"]}, {"cell_type": "code", "execution_count": 118, "metadata": {}, "outputs": [{"data": {"text/plain": ["('key3', 'key2', 'key1')"]}, "execution_count": 118, "metadata": {}, "output_type": "execute_result"}], "source": ["Struct._fields"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see, sets do not preserve order, so in this case we'll probably sort the keys to create our named tuple:"]}, {"cell_type": "code", "execution_count": 119, "metadata": {"collapsed": true}, "outputs": [], "source": ["Struct = namedtuple('Struct', sorted(keys))"]}, {"cell_type": "code", "execution_count": 120, "metadata": {}, "outputs": [{"data": {"text/plain": ["('key1', 'key2', 'key3')"]}, "execution_count": 120, "metadata": {}, "output_type": "execute_result"}], "source": ["Struct._fields"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now, we're also going to provide default values, since not all dictionaries have all the keys in them. In this case I'm going to set the default to `None` if the key is missing:"]}, {"cell_type": "code", "execution_count": 121, "metadata": {"collapsed": true}, "outputs": [], "source": ["Struct.__new__.__defaults__ = (None,) * len(Struct._fields)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now we're ready to load up all these dictionaries into a new list of named tuples:"]}, {"cell_type": "code", "execution_count": 122, "metadata": {"collapsed": true}, "outputs": [], "source": ["tuple_list = [Struct(**dict_) for dict_ in data_list]"]}, {"cell_type": "code", "execution_count": 123, "metadata": {}, "outputs": [{"data": {"text/plain": ["[Struct(key1=1, key2=2, key3=None),\n", " Struct(key1=3, key2=4, key3=None),\n", " Struct(key1=5, key2=6, key3=7),\n", " Struct(key1=None, key2=100, key3=None)]"]}, "execution_count": 123, "metadata": {}, "output_type": "execute_result"}], "source": ["tuple_list"]}, {"cell_type": "markdown", "metadata": {}, "source": ["So lastly, let's just package this all up neatly into a single function that will take an iterable of dictionaries, or an arbitrary number of dictionaries as positional arguments, and return a list of named tuples:"]}, {"cell_type": "code", "execution_count": 5, "metadata": {"collapsed": true}, "outputs": [], "source": ["def tuplify_dicts(dicts):\n", "    keys = {key for dict_ in dicts for key in dict_.keys()}\n", "    Struct = namedtuple('Struct', keys)\n", "    Struct.__new__.__defaults__ = (None,) * len(Struct._fields)\n", "    return [Struct(**dict_) for dict_ in dicts]"]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [{"data": {"text/plain": ["[Struct(key1=1, key2=2, key3=None),\n", " Struct(key1=3, key2=4, key3=None),\n", " Struct(key1=5, key2=6, key3=7),\n", " Struct(key1=None, key2=100, key3=None)]"]}, "execution_count": 6, "metadata": {}, "output_type": "execute_result"}], "source": ["tuplify_dicts(data_list)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Isn't Python wonderful? :-)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Named Tuples - Application - Returning Multiple Values"]}, {"cell_type": "markdown", "metadata": {"collapsed": true}, "source": ["We already know that we can easily return multiple values from a function by using a tuple:"]}, {"cell_type": "code", "execution_count": 21, "metadata": {"collapsed": true}, "outputs": [], "source": ["from random import randint, random\n", "\n", "def random_color():\n", "    red = randint(0, 255)\n", "    green = randint(0,255)\n", "    blue = randint(0, 255)\n", "    alpha = round(random(), 2)\n", "    return red, green, blue, alpha"]}, {"cell_type": "code", "execution_count": 23, "metadata": {}, "outputs": [{"data": {"text/plain": ["(97, 254, 97, 0.06)"]}, "execution_count": 23, "metadata": {}, "output_type": "execute_result"}], "source": ["random_color()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["So of course, we could call the function this and unpack the results at the same time:"]}, {"cell_type": "code", "execution_count": 25, "metadata": {"collapsed": true}, "outputs": [], "source": ["red, green, blue, alpha = random_color()"]}, {"cell_type": "code", "execution_count": 26, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["red=42, green=178, blue=69, alpha=0.7\n"]}], "source": ["print(f'red={red}, green={green}, blue={blue}, alpha={alpha}')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But it might be nicer to use a named tuple:"]}, {"cell_type": "code", "execution_count": 27, "metadata": {"collapsed": true}, "outputs": [], "source": ["from collections import namedtuple"]}, {"cell_type": "code", "execution_count": 28, "metadata": {"collapsed": true}, "outputs": [], "source": ["Color = namedtuple('Color', 'red green blue alpha')\n", "\n", "def random_color():\n", "    red = randint(0, 255)\n", "    green = randint(0,255)\n", "    blue = randint(0, 255)\n", "    alpha = round(random(), 2)\n", "    return Color(red, green, blue, alpha)"]}, {"cell_type": "code", "execution_count": 29, "metadata": {"collapsed": true}, "outputs": [], "source": ["color = random_color()"]}, {"cell_type": "code", "execution_count": 30, "metadata": {}, "outputs": [{"data": {"text/plain": ["5"]}, "execution_count": 30, "metadata": {}, "output_type": "execute_result"}], "source": ["color.red"]}, {"cell_type": "code", "execution_count": 31, "metadata": {}, "outputs": [{"data": {"text/plain": ["Color(red=5, green=210, blue=143, alpha=0.06)"]}, "execution_count": 31, "metadata": {}, "output_type": "execute_result"}], "source": ["color"]}, {"cell_type": "markdown", "metadata": {}, "source": ["### What is a Module?"]}, {"cell_type": "markdown", "metadata": {}, "source": ["A module is simply another data type. And the modules we use are instances of that data type."]}, {"cell_type": "code", "execution_count": 1, "metadata": {"collapsed": true}, "outputs": [], "source": ["import math"]}, {"cell_type": "markdown", "metadata": {}, "source": ["That word `math` is simply a label (think variable name) in our (global) namespace that points to some object in memory that is the `math` module."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's see what is in our global namespace:"]}, {"cell_type": "code", "execution_count": 2, "metadata": {}, "outputs": [{"data": {"text/plain": ["{'In': ['', 'import math', 'globals()'],\n", " 'Out': {},\n", " '_': '',\n", " '__': '',\n", " '___': '',\n", " '__builtin__': <module 'builtins' (built-in)>,\n", " '__builtins__': <module 'builtins' (built-in)>,\n", " '__doc__': 'Automatically created module for IPython interactive environment',\n", " '__loader__': None,\n", " '__name__': '__main__',\n", " '__package__': None,\n", " '__spec__': None,\n", " '_dh': ['d:\\\\fbapt\\\\Dropbox\\\\Python Deep Dive\\\\Section 09 - Modules, Packages and Namespaces\\\\02 - What is a Module'],\n", " '_i': 'import math',\n", " '_i1': 'import math',\n", " '_i2': 'globals()',\n", " '_ih': ['', 'import math', 'globals()'],\n", " '_ii': '',\n", " '_iii': '',\n", " '_oh': {},\n", " 'exit': <IPython.core.autocall.ZMQExitAutocall at 0x1ae10cb5550>,\n", " 'get_ipython': <bound method InteractiveShell.get_ipython of <ipykernel.zmqshell.ZMQInteractiveShell object at 0x000001AE10373208>>,\n", " 'math': <module 'math' (built-in)>,\n", " 'quit': <IPython.core.autocall.ZMQExitAutocall at 0x1ae10cb5550>}"]}, "execution_count": 2, "metadata": {}, "output_type": "execute_result"}], "source": ["globals()"]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [{"data": {"text/plain": ["<module 'math' (built-in)>"]}, "execution_count": 3, "metadata": {}, "output_type": "execute_result"}], "source": ["globals()['math']"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"data": {"text/plain": ["module"]}, "execution_count": 4, "metadata": {}, "output_type": "execute_result"}], "source": ["type(math)"]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"data": {"text/plain": ["<module 'math' (built-in)>"]}, "execution_count": 5, "metadata": {}, "output_type": "execute_result"}], "source": ["math"]}, {"cell_type": "markdown", "metadata": {}, "source": ["It's just an object of type `module`, and it even has a memory address:"]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [{"data": {"text/plain": ["1847086390312"]}, "execution_count": 6, "metadata": {}, "output_type": "execute_result"}], "source": ["id(math)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Take note of this memory address, we'll want to refer to it later!\n", "\n", "Let me show you what happens if I set the `math` **label** to `None` (I could even use `del globals()['math']`:"]}, {"cell_type": "code", "execution_count": 13, "metadata": {"collapsed": true}, "outputs": [], "source": ["math = None"]}, {"cell_type": "code", "execution_count": 15, "metadata": {}, "outputs": [{"data": {"text/plain": ["NoneType"]}, "execution_count": 15, "metadata": {}, "output_type": "execute_result"}], "source": ["type(math)"]}, {"cell_type": "code", "execution_count": 16, "metadata": {}, "outputs": [{"data": {"text/plain": ["1800367120"]}, "execution_count": 16, "metadata": {}, "output_type": "execute_result"}], "source": ["id(math)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see the label `math` now points to something else.\n", "\n", "Let me re-import it:"]}, {"cell_type": "code", "execution_count": 17, "metadata": {"collapsed": true}, "outputs": [], "source": ["import math"]}, {"cell_type": "markdown", "metadata": {}, "source": ["And now we can see:"]}, {"cell_type": "code", "execution_count": 18, "metadata": {}, "outputs": [{"data": {"text/plain": ["<module 'math' (built-in)>"]}, "execution_count": 18, "metadata": {}, "output_type": "execute_result"}], "source": ["math"]}, {"cell_type": "code", "execution_count": 19, "metadata": {}, "outputs": [{"data": {"text/plain": ["1847086390312"]}, "execution_count": 19, "metadata": {}, "output_type": "execute_result"}], "source": ["id(math)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["You'll notice that the label `math` now is the **same** memory address as the first time we ran the import."]}, {"cell_type": "markdown", "metadata": {}, "source": ["**NOTE**: Please do not do this in your code. You never what side effects you may encounter - I just showed you this to make a point - when I ran the import the second time, I obtained a label that pointed to the **same** object."]}, {"cell_type": "markdown", "metadata": {}, "source": ["What happens is that when you import a module, it is not actually loaded into the module's namespace only. Instead, the module is loaded into an overarching global system dictionary that contains the module name and the reference to the module object. The name we see here is \"copied\" into our namespace from that system namespace."]}, {"cell_type": "markdown", "metadata": {}, "source": ["If we had a project with multiple modules that each imported `math`, Python will load the `math` module the first time it is requested and put it into memory.\n", "\n", "The next time the `math` module is imported (in some different module), Python always looks at the system modules first - if it is there it simply copies that reference into our module's namespace and sets the label accordingly."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's take a look at the system modules:"]}, {"cell_type": "code", "execution_count": 20, "metadata": {"collapsed": true}, "outputs": [], "source": ["import sys"]}, {"cell_type": "code", "execution_count": 24, "metadata": {}, "outputs": [{"data": {"text/plain": ["dict"]}, "execution_count": 24, "metadata": {}, "output_type": "execute_result"}], "source": ["type(sys.modules)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The `sys.modules` currently contains a **lot** of entries, so I'm just going to look at the one we're interested in - the `math` module:"]}, {"cell_type": "code", "execution_count": 27, "metadata": {}, "outputs": [{"data": {"text/plain": ["<module 'math' (built-in)>"]}, "execution_count": 27, "metadata": {}, "output_type": "execute_result"}], "source": ["sys.modules['math']"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Aha! The `sys.modules` dictionary contains a key for `math` and as you saw it is the `math` module. In fact we can look at the memory address once more:"]}, {"cell_type": "code", "execution_count": 28, "metadata": {}, "outputs": [{"data": {"text/plain": ["1847086390312"]}, "execution_count": 28, "metadata": {}, "output_type": "execute_result"}], "source": ["id(sys.modules['math'])"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Compare that to the `id` of the `math` module in our own (main) module - the same!"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now that we have established that a module is just an instance of the `module` type, and where it lives (in memory) with references to it maintained in the `sys.modules` dictionary as well as in any module namespace that imported it, let's see how we could create a module dynamically!"]}, {"cell_type": "markdown", "metadata": {}, "source": ["If it's an object, let's inspect it..."]}, {"cell_type": "code", "execution_count": 34, "metadata": {}, "outputs": [{"data": {"text/plain": ["'math'"]}, "execution_count": 34, "metadata": {}, "output_type": "execute_result"}], "source": ["math.__name__"]}, {"cell_type": "code", "execution_count": 37, "metadata": {}, "outputs": [{"data": {"text/plain": ["{'__doc__': 'This module is always available.  It provides access to the\\nmathematical functions defined by the C standard.',\n", " '__loader__': _frozen_importlib.BuiltinImporter,\n", " '__name__': 'math',\n", " '__package__': '',\n", " '__spec__': ModuleSpec(name='math', loader=<class '_frozen_importlib.BuiltinImporter'>, origin='built-in'),\n", " 'acos': <function math.acos>,\n", " 'acosh': <function math.acosh>,\n", " 'asin': <function math.asin>,\n", " 'asinh': <function math.asinh>,\n", " 'atan': <function math.atan>,\n", " 'atan2': <function math.atan2>,\n", " 'atanh': <function math.atanh>,\n", " 'ceil': <function math.ceil>,\n", " 'copysign': <function math.copysign>,\n", " 'cos': <function math.cos>,\n", " 'cosh': <function math.cosh>,\n", " 'degrees': <function math.degrees>,\n", " 'e': 2.718281828459045,\n", " 'erf': <function math.erf>,\n", " 'erfc': <function math.erfc>,\n", " 'exp': <function math.exp>,\n", " 'expm1': <function math.expm1>,\n", " 'fabs': <function math.fabs>,\n", " 'factorial': <function math.factorial>,\n", " 'floor': <function math.floor>,\n", " 'fmod': <function math.fmod>,\n", " 'frexp': <function math.frexp>,\n", " 'fsum': <function math.fsum>,\n", " 'gamma': <function math.gamma>,\n", " 'gcd': <function math.gcd>,\n", " 'hypot': <function math.hypot>,\n", " 'inf': inf,\n", " 'isclose': <function math.isclose>,\n", " 'isfinite': <function math.isfinite>,\n", " 'isinf': <function math.isinf>,\n", " 'isnan': <function math.isnan>,\n", " 'ldexp': <function math.ldexp>,\n", " 'lgamma': <function math.lgamma>,\n", " 'log': <function math.log>,\n", " 'log10': <function math.log10>,\n", " 'log1p': <function math.log1p>,\n", " 'log2': <function math.log2>,\n", " 'modf': <function math.modf>,\n", " 'nan': nan,\n", " 'pi': 3.141592653589793,\n", " 'pow': <function math.pow>,\n", " 'radians': <function math.radians>,\n", " 'sin': <function math.sin>,\n", " 'sinh': <function math.sinh>,\n", " 'sqrt': <function math.sqrt>,\n", " 'tan': <function math.tan>,\n", " 'tanh': <function math.tanh>,\n", " 'tau': 6.283185307179586,\n", " 'trunc': <function math.trunc>}"]}, "execution_count": 37, "metadata": {}, "output_type": "execute_result"}], "source": ["math.__dict__"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Notice how all the methods and \"constants\" (such as pi) are just members of a dictionary with values being functions or values:"]}, {"cell_type": "code", "execution_count": 40, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 40, "metadata": {}, "output_type": "execute_result"}], "source": ["math.sqrt is math.__dict__['sqrt']"]}, {"cell_type": "markdown", "metadata": {}, "source": ["So, when we write `math.sqrt` we are basically just retrieving the function stored in the `math.__dict__` dictionary at that key (`sqrt`)."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now the `math` module is a little special - it is written in C and actually a built-in.\n", "\n", "Let's look at another module from the standard library:"]}, {"cell_type": "code", "execution_count": 48, "metadata": {}, "outputs": [], "source": ["import fractions"]}, {"cell_type": "code", "execution_count": 49, "metadata": {}, "outputs": [{"data": {"text/plain": ["{'Decimal': decimal.Decimal,\n", " 'Fraction': fractions.Fraction,\n", " '_PyHASH_INF': 314159,\n", " '_PyHASH_MODULUS': 2305843009213693951,\n", " '_RATIONAL_FORMAT': re.compile(r'\\n    \\A\\s*                      # optional whitespace at the start, then\\n    (?P<sign>[-+]?)            # an optional sign, then\\n    (?=\\d|\\.\\d)                # lookahead for digit or .digit\\n    (?P<num>\\d*)               # numerator (possibly empty)\\n    (?:                        # followed by\\n       (?:/(?P<denom>\\d+))?    # an optional denominator\\n    |                          # or\\n       (?:\\.(?P<decimal>\\d*))? # an optional fractional part\\n       (?:E(?P<exp>[-+]?\\d+))? # and optional exponent\\n    )\\n    \\s*\\Z                      # and optional whitespace to finish\\n',\n", " re.IGNORECASE|re.UNICODE|re.VERBOSE),\n", " '__all__': ['Fraction', 'gcd'],\n", " '__builtins__': {'ArithmeticError': ArithmeticError,\n", "  'AssertionError': AssertionError,\n", "  'AttributeError': AttributeError,\n", "  'BaseException': BaseException,\n", "  'BlockingIOError': BlockingIOError,\n", "  'BrokenPipeError': BrokenPipeError,\n", "  'BufferError': BufferError,\n", "  'BytesWarning': BytesWarning,\n", "  'ChildProcessError': ChildProcessError,\n", "  'ConnectionAbortedError': ConnectionAbortedError,\n", "  'ConnectionError': ConnectionError,\n", "  'ConnectionRefusedError': ConnectionRefusedError,\n", "  'ConnectionResetError': ConnectionResetError,\n", "  'DeprecationWarning': DeprecationWarning,\n", "  'EOFError': EOFError,\n", "  'Ellipsis': Ellipsis,\n", "  'EnvironmentError': OSError,\n", "  'Exception': Exception,\n", "  'False': False,\n", "  'FileExistsError': FileExistsError,\n", "  'FileNotFoundError': FileNotFoundError,\n", "  'FloatingPointError': FloatingPointError,\n", "  'FutureWarning': FutureWarning,\n", "  'GeneratorExit': GeneratorExit,\n", "  'IOError': OSError,\n", "  'ImportError': ImportError,\n", "  'ImportWarning': ImportWarning,\n", "  'IndentationError': IndentationError,\n", "  'IndexError': IndexError,\n", "  'InterruptedError': InterruptedError,\n", "  'IsADirectoryError': IsADirectoryError,\n", "  'KeyError': KeyError,\n", "  'KeyboardInterrupt': KeyboardInterrupt,\n", "  'LookupError': LookupError,\n", "  'MemoryError': MemoryError,\n", "  'ModuleNotFoundError': ModuleNotFoundError,\n", "  'NameError': NameError,\n", "  'None': None,\n", "  'NotADirectoryError': NotADirectoryError,\n", "  'NotImplemented': NotImplemented,\n", "  'NotImplementedError': NotImplementedError,\n", "  'OSError': OSError,\n", "  'OverflowError': OverflowError,\n", "  'PendingDeprecationWarning': PendingDeprecationWarning,\n", "  'PermissionError': PermissionError,\n", "  'ProcessLookupError': ProcessLookupError,\n", "  'RecursionError': RecursionError,\n", "  'ReferenceError': ReferenceError,\n", "  'ResourceWarning': ResourceWarning,\n", "  'RuntimeError': RuntimeError,\n", "  'RuntimeWarning': RuntimeWarning,\n", "  'StopAsyncIteration': StopAsyncIteration,\n", "  'StopIteration': StopIteration,\n", "  'SyntaxError': SyntaxError,\n", "  'SyntaxWarning': SyntaxWarning,\n", "  'SystemError': SystemError,\n", "  'SystemExit': SystemExit,\n", "  'TabError': TabError,\n", "  'TimeoutError': TimeoutError,\n", "  'True': True,\n", "  'TypeError': TypeError,\n", "  'UnboundLocalError': UnboundLocalError,\n", "  'UnicodeDecodeError': UnicodeDecodeError,\n", "  'UnicodeEncodeError': UnicodeEncodeError,\n", "  'UnicodeError': UnicodeError,\n", "  'UnicodeTranslateError': UnicodeTranslateError,\n", "  'UnicodeWarning': UnicodeWarning,\n", "  'UserWarning': UserWarning,\n", "  'ValueError': ValueError,\n", "  'Warning': Warning,\n", "  'WindowsError': OSError,\n", "  'ZeroDivisionError': ZeroDivisionError,\n", "  '__IPYTHON__': True,\n", "  '__build_class__': <function __build_class__>,\n", "  '__debug__': True,\n", "  '__doc__': \"Built-in functions, exceptions, and other objects.\\n\\nNoteworthy: None is the `nil' object; Ellipsis represents `...' in slices.\",\n", "  '__import__': <function __import__>,\n", "  '__loader__': _frozen_importlib.BuiltinImporter,\n", "  '__name__': 'builtins',\n", "  '__package__': '',\n", "  '__spec__': ModuleSpec(name='builtins', loader=<class '_frozen_importlib.BuiltinImporter'>),\n", "  'abs': <function abs>,\n", "  'all': <function all>,\n", "  'any': <function any>,\n", "  'ascii': <function ascii>,\n", "  'bin': <function bin>,\n", "  'bool': bool,\n", "  'bytearray': bytearray,\n", "  'bytes': bytes,\n", "  'callable': <function callable>,\n", "  'chr': <function chr>,\n", "  'classmethod': classmethod,\n", "  'compile': <function compile>,\n", "  'complex': complex,\n", "  'copyright': Copyright (c) 2001-2017 Python Software Foundation.\n", "  All Rights Reserved.\n", "  \n", "  Copyright (c) 2000 BeOpen.com.\n", "  All Rights Reserved.\n", "  \n", "  Copyright (c) 1995-2001 Corporation for National Research Initiatives.\n", "  All Rights Reserved.\n", "  \n", "  Copyright (c) 1991-1995 Stichting Mathematisch Centrum, Amsterdam.\n", "  All Rights Reserved.,\n", "  'credits':     Thanks to CWI, CNRI, BeOpen.com, Zope Corporation and a cast of thousands\n", "      for supporting Python development.  See www.python.org for more information.,\n", "  'delattr': <function delattr>,\n", "  'dict': dict,\n", "  'dir': <function dir>,\n", "  'display': <function IPython.core.display.display>,\n", "  'divmod': <function divmod>,\n", "  'enumerate': enumerate,\n", "  'eval': <function eval>,\n", "  'exec': <function exec>,\n", "  'filter': filter,\n", "  'float': float,\n", "  'format': <function format>,\n", "  'frozenset': frozenset,\n", "  'get_ipython': <bound method InteractiveShell.get_ipython of <ipykernel.zmqshell.ZMQInteractiveShell object at 0x000001AE10373208>>,\n", "  'getattr': <function getattr>,\n", "  'globals': <function globals>,\n", "  'hasattr': <function hasattr>,\n", "  'hash': <function hash>,\n", "  'help': Type help() for interactive help, or help(object) for help about object.,\n", "  'hex': <function hex>,\n", "  'id': <function id>,\n", "  'input': <bound method Kernel.raw_input of <ipykernel.ipkernel.IPythonKernel object at 0x000001AE10352EB8>>,\n", "  'int': int,\n", "  'isinstance': <function isinstance>,\n", "  'issubclass': <function issubclass>,\n", "  'iter': <function iter>,\n", "  'len': <function len>,\n", "  'license': See https://www.python.org/psf/license/,\n", "  'list': list,\n", "  'locals': <function locals>,\n", "  'map': map,\n", "  'max': <function max>,\n", "  'memoryview': memoryview,\n", "  'min': <function min>,\n", "  'next': <function next>,\n", "  'object': object,\n", "  'oct': <function oct>,\n", "  'open': <function io.open>,\n", "  'ord': <function ord>,\n", "  'pow': <function pow>,\n", "  'print': <function print>,\n", "  'property': property,\n", "  'range': range,\n", "  'repr': <function repr>,\n", "  'reversed': reversed,\n", "  'round': <function round>,\n", "  'set': set,\n", "  'setattr': <function setattr>,\n", "  'slice': slice,\n", "  'sorted': <function sorted>,\n", "  'staticmethod': staticmethod,\n", "  'str': str,\n", "  'sum': <function sum>,\n", "  'super': super,\n", "  'tuple': tuple,\n", "  'type': type,\n", "  'vars': <function vars>,\n", "  'zip': zip},\n", " '__cached__': 'D:\\\\Users\\\\fbapt\\\\Anaconda3\\\\envs\\\\deepdive\\\\lib\\\\__pycache__\\\\fractions.cpython-36.pyc',\n", " '__doc__': 'Fraction, infinite-precision, real numbers.',\n", " '__file__': 'D:\\\\Users\\\\fbapt\\\\Anaconda3\\\\envs\\\\deepdive\\\\lib\\\\fractions.py',\n", " '__loader__': <_frozen_importlib_external.SourceFileLoader at 0x1ae10e4cf98>,\n", " '__name__': 'fractions',\n", " '__package__': '',\n", " '__spec__': ModuleSpec(name='fractions', loader=<_frozen_importlib_external.SourceFileLoader object at 0x000001AE10E4CF98>, origin='D:\\\\Users\\\\fbapt\\\\Anaconda3\\\\envs\\\\deepdive\\\\lib\\\\fractions.py'),\n", " '_gcd': <function fractions._gcd>,\n", " 'gcd': <function fractions.gcd>,\n", " 'math': <module 'math' (built-in)>,\n", " 'numbers': <module 'numbers' from 'D:\\\\Users\\\\fbapt\\\\Anaconda3\\\\envs\\\\deepdive\\\\lib\\\\numbers.py'>,\n", " 'operator': <module 'operator' from 'D:\\\\Users\\\\fbapt\\\\Anaconda3\\\\envs\\\\deepdive\\\\lib\\\\operator.py'>,\n", " 're': <module 're' from 'D:\\\\Users\\\\fbapt\\\\Anaconda3\\\\envs\\\\deepdive\\\\lib\\\\re.py'>,\n", " 'sys': <module 'sys' (built-in)>}"]}, "execution_count": 49, "metadata": {}, "output_type": "execute_result"}], "source": ["fractions.__dict__"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Notice a few properties here that look interesting:"]}, {"cell_type": "code", "execution_count": 52, "metadata": {}, "outputs": [{"data": {"text/plain": ["'D:\\\\Users\\\\fbapt\\\\Anaconda3\\\\envs\\\\deepdive\\\\lib\\\\fractions.py'"]}, "execution_count": 52, "metadata": {}, "output_type": "execute_result"}], "source": ["fractions.__file__"]}, {"cell_type": "markdown", "metadata": {}, "source": ["That's where the `fractions` module source code resides. I am using a virtual environment (conda), and the module `fractions.py` resides in that directory."]}, {"cell_type": "markdown", "metadata": {}, "source": ["So a module is an object that is:\n", "- loaded from file (maybe! we'll see that in a second)\n", "- has a namespace\n", "- is a container of global variables (that `__dict__` we saw)\n", "- is an execution environment (we'll see that in an upcoming video)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Of course, modules are just specific data types, and like any other data type in Python (think classes, functions, etc) we can create them dynamically - they do not have to be loaded from file (though that is how we do it most of the time)."]}, {"cell_type": "code", "execution_count": 54, "metadata": {"collapsed": true}, "outputs": [], "source": ["import types"]}, {"cell_type": "code", "execution_count": 72, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 72, "metadata": {}, "output_type": "execute_result"}], "source": ["isinstance(fractions, types.ModuleType)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["So, modules are instances of the `ModuleType` class."]}, {"cell_type": "code", "execution_count": 57, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Help on class module in module builtins:\n", "\n", "class module(object)\n", " |  module(name[, doc])\n", " |  \n", " |  Create a module object.\n", " |  The name must be a string; the optional doc argument can have any type.\n", " |  \n", " |  Methods defined here:\n", " |  \n", " |  __delattr__(self, name, /)\n", " |      Implement delattr(self, name).\n", " |  \n", " |  __dir__(...)\n", " |      __dir__() -> list\n", " |      specialized dir() implementation\n", " |  \n", " |  __getattribute__(self, name, /)\n", " |      Return getattr(self, name).\n", " |  \n", " |  __init__(self, /, *args, **kwargs)\n", " |      Initialize self.  See help(type(self)) for accurate signature.\n", " |  \n", " |  __new__(*args, **kwargs) from builtins.type\n", " |      Create and return a new object.  See help(type) for accurate signature.\n", " |  \n", " |  __repr__(self, /)\n", " |      Return repr(self).\n", " |  \n", " |  __setattr__(self, name, value, /)\n", " |      Implement setattr(self, name, value).\n", " |  \n", " |  ----------------------------------------------------------------------\n", " |  Data descriptors defined here:\n", " |  \n", " |  __dict__\n", "\n"]}], "source": ["help(ModuleType)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's go ahead and create a new module:"]}, {"cell_type": "code", "execution_count": 58, "metadata": {"collapsed": true}, "outputs": [], "source": ["mod = types.ModuleType('point', 'A module for handling points.')"]}, {"cell_type": "code", "execution_count": 60, "metadata": {}, "outputs": [{"data": {"text/plain": ["<module 'point'>"]}, "execution_count": 60, "metadata": {}, "output_type": "execute_result"}], "source": ["mod"]}, {"cell_type": "code", "execution_count": 59, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Help on module point:\n", "\n", "NAME\n", "    point - A module for handling points.\n", "\n", "FILE\n", "    (built-in)\n", "\n", "\n"]}], "source": ["help(mod)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["OK, so now let's add some functionality to it by simply setting some attributes:"]}, {"cell_type": "code", "execution_count": 63, "metadata": {}, "outputs": [], "source": ["from collections import namedtuple\n", "mod.Point = namedtuple('Point', 'x y')"]}, {"cell_type": "code", "execution_count": 64, "metadata": {"collapsed": true}, "outputs": [], "source": ["def points_distance(pt1, pt2):\n", "    return math.sqrt((pt1.x - pt2.x) ** 2 + (pt1.y - pt2.y) ** 2)"]}, {"cell_type": "code", "execution_count": 65, "metadata": {"collapsed": true}, "outputs": [], "source": ["mod.distance = points_distance"]}, {"cell_type": "code", "execution_count": 67, "metadata": {}, "outputs": [{"data": {"text/plain": ["{'Point': __main__.Point,\n", " '__doc__': 'A module for handling points.',\n", " '__loader__': None,\n", " '__name__': 'point',\n", " '__package__': None,\n", " '__spec__': None,\n", " 'distance': <function __main__.points_distance>}"]}, "execution_count": 67, "metadata": {}, "output_type": "execute_result"}], "source": ["mod.__dict__"]}, {"cell_type": "code", "execution_count": 68, "metadata": {"collapsed": true}, "outputs": [], "source": ["p1 = mod.Point(0, 0)\n", "p2 = mod.Point(1, 1)"]}, {"cell_type": "code", "execution_count": 69, "metadata": {}, "outputs": [{"data": {"text/plain": ["1.4142135623730951"]}, "execution_count": 69, "metadata": {}, "output_type": "execute_result"}], "source": ["mod.distance(p1, p2)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see it behaves just like an ordinary module.\n", "\n", "However, one major difference here is that it is not located in the `sys.modules` dictionary - so another module in our program would not know anything about it.\n", "\n", "But we can fix that! We'll see this in one of the next videos.\n", "\n", "But first we'll need to take a peek at how Python imports a module from file. COming right up!"]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Imports and `importlib`"]}, {"cell_type": "markdown", "metadata": {}, "source": ["In the last video we saw how we could, in a simplistic manner, mimic Python's import.\n", "\n", "There is absolutely no need to do this since Python itself provides that functionality, both as a built-in function (`import`) and in the standard library module `importlib`.\n", "\n", "In fact, if you want to see how imports are done in pure Python code you can always look at the source code for that library (you should now know where to find that on your local machine - you have to first identify a Pythyon environment (`sys.exec_prefix`) and then look in the `lib` folder:"]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": ["import sys"]}, {"cell_type": "code", "execution_count": null, "metadata": {}, "outputs": [], "source": ["sys.exec_prefix"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Or you can import `importlib` and look at the `__file__` property to get an exact location:"]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": ["import importlib"]}, {"cell_type": "code", "execution_count": null, "metadata": {}, "outputs": [], "source": ["importlib.__file__"]}, {"cell_type": "markdown", "metadata": {}, "source": ["or just see the string representation of the `importlib` object:"]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"data": {"text/plain": ["<module 'importlib' from 'D:\\\\Users\\\\fbapt\\\\Anaconda3\\\\lib\\\\importlib\\\\__init__.py'>"]}, "execution_count": 5, "metadata": {}, "output_type": "execute_result"}], "source": ["importlib"]}, {"cell_type": "markdown", "metadata": {}, "source": ["You'll find something a little different - `importlib` is not actually a pure module (it's still a module type object) - it's actually a package - more on that later."]}, {"cell_type": "markdown", "metadata": {}, "source": ["You should then use the `import_module` function to load a module."]}, {"cell_type": "markdown", "metadata": {}, "source": ["For example, we can load the `fractions` module as follows:"]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [{"data": {"text/plain": ["<module 'fractions' from 'D:\\\\Users\\\\fbapt\\\\Anaconda3\\\\lib\\\\fractions.py'>"]}, "execution_count": 6, "metadata": {}, "output_type": "execute_result"}], "source": ["importlib.import_module('fractions')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The problem doing it this way is that **our** module namespace does not have a symbol for `fractions` (but it **is** in `sys.modules`):"]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"ename": "NameError", "evalue": "name 'fractions' is not defined", "output_type": "error", "traceback": ["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[1;31mNameError\u001b[0m                                 Traceback (most recent call last)", "\u001b[1;32m<ipython-input-7-92ac4b49f1a5>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[1;32m----> 1\u001b[1;33m \u001b[0mf\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mfractions\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mFraction\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;36m2\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;36m3\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m", "\u001b[1;31mNameError\u001b[0m: name 'fractions' is not defined"]}], "source": ["f = fractions.Fraction(2, 3)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["So instead we would have to do it the same way we did it with our own custom importer:"]}, {"cell_type": "code", "execution_count": 8, "metadata": {"collapsed": true}, "outputs": [], "source": ["fractions = importlib.import_module('fractions')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["And now we have a symbol for the `fractions` object."]}, {"cell_type": "code", "execution_count": 9, "metadata": {"collapsed": true}, "outputs": [], "source": ["f = fractions.Fraction(2, 3)"]}, {"cell_type": "code", "execution_count": 10, "metadata": {}, "outputs": [{"data": {"text/plain": ["Fraction(2, 3)"]}, "execution_count": 10, "metadata": {}, "output_type": "execute_result"}], "source": ["f"]}, {"cell_type": "markdown", "metadata": {}, "source": ["One thing I briefly alluded to earlier, we can import from a variety of \"sources\".\n", "\n", "Often it is from file, such as with `fractions`:"]}, {"cell_type": "code", "execution_count": 11, "metadata": {}, "outputs": [{"data": {"text/plain": ["<module 'fractions' from 'D:\\\\Users\\\\fbapt\\\\Anaconda3\\\\lib\\\\fractions.py'>"]}, "execution_count": 11, "metadata": {}, "output_type": "execute_result"}], "source": ["fractions"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Sometimes it is built in to Python directly:"]}, {"cell_type": "code", "execution_count": 12, "metadata": {"collapsed": true}, "outputs": [], "source": ["import math"]}, {"cell_type": "code", "execution_count": 13, "metadata": {}, "outputs": [{"data": {"text/plain": ["<module 'math' (built-in)>"]}, "execution_count": 13, "metadata": {}, "output_type": "execute_result"}], "source": ["math"]}, {"cell_type": "markdown", "metadata": {}, "source": ["In Python there are a number of files that are \"code\" files, such as\n", "\n", "* `.py`: basic text file containing Python code\n", "* `.pyc`: compiled Python code (bytecode)\n", "* `.so`, `.pyd`: think DLL's (Linux / Windows)\n", "\n", "amongst others. Furthermore, Python can reach inside `zip` archives for code (as well as other packaged distribution files such as those used by Egg or Wheel)."]}, {"cell_type": "markdown", "metadata": {}, "source": ["In very broad terms the import system, once the \"source\" code has been located works as we saw in the last video.\n", "\n", "A lot of the complexity comes from locating a module when we try to import it."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Conceptually Python divides the work between **finders** and **loaders**.\n", "\n", "The **finders** are responsible for finding the module/package and returning the module spec, while the **loaders**, are responsible for \"loading\" the source code that is then used in the final steps to compile, execute and cache the module object. An object that implements both is called an **importer** - but they are still two separate concepts."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Python provides a number of standard finders and importers, such as:\n", "\n", "* built-in modules\n", "* frozen modules\n", "* import path finder (finds source code files on the import path - for example the `sys.path` entries we have seen before)\n", "\n", "What's interesting about the import path finder and loader is that they can search (and load from) zip archives.\n", "\n", "In fact it can even be extended to search other resources, including url's, databases, etc. You could theoretically store code in a Mongo or Redis database and import directly from there!"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's look at the module spec for `fractions`:"]}, {"cell_type": "code", "execution_count": 14, "metadata": {}, "outputs": [{"data": {"text/plain": ["ModuleSpec(name='fractions', loader=<_frozen_importlib_external.SourceFileLoader object at 0x00000154B83757F0>, origin='D:\\\\Users\\\\fbapt\\\\Anaconda3\\\\lib\\\\fractions.py')"]}, "execution_count": 14, "metadata": {}, "output_type": "execute_result"}], "source": ["fractions.__spec__"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see the finder determined where the source code was located, and also indicated that the loader to be used is the SourceFileLoader.\n", "\n", "How does Python know which finder to use in the first place?\n", "\n", "It doesn't really - it will go through a bunch of finders, one by one, until one returns a module spec - if it exhausts all the registered finders and finds nothing, then we get the module not found exception:"]}, {"cell_type": "code", "execution_count": 15, "metadata": {}, "outputs": [{"ename": "ModuleNotFoundError", "evalue": "No module named 'foo'", "output_type": "error", "traceback": ["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[1;31mModuleNotFoundError\u001b[0m                       Traceback (most recent call last)", "\u001b[1;32m<ipython-input-15-34d390fb3acc>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[1;32m----> 1\u001b[1;33m \u001b[1;32mimport\u001b[0m \u001b[0mfoo\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m", "\u001b[1;31mModuleNotFoundError\u001b[0m: No module named 'foo'"]}], "source": ["import foo"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Here are the finders currently registered on my system:"]}, {"cell_type": "code", "execution_count": 16, "metadata": {}, "outputs": [{"data": {"text/plain": ["[_frozen_importlib.BuiltinImporter,\n", " _frozen_importlib.FrozenImporter,\n", " _frozen_importlib_external.PathFinder,\n", " <six._SixMetaPathImporter at 0x154b64d0198>,\n", " <pkg_resources.extern.VendorImporter at 0x154b7148f98>,\n", " <pkg_resources._vendor.six._SixMetaPathImporter at 0x154b72a5518>]"]}, "execution_count": 16, "metadata": {}, "output_type": "execute_result"}], "source": ["sys.meta_path"]}, {"cell_type": "markdown", "metadata": {}, "source": ["When we import our custom file-based modules, the `PathFinder` will be used to find the file."]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can also use `importlib` to find the spec for a particular module:"]}, {"cell_type": "code", "execution_count": 17, "metadata": {}, "outputs": [{"data": {"text/plain": ["ModuleSpec(name='math', loader=<class '_frozen_importlib.BuiltinImporter'>, origin='built-in')"]}, "execution_count": 17, "metadata": {}, "output_type": "execute_result"}], "source": ["importlib.util.find_spec('math')"]}, {"cell_type": "code", "execution_count": 18, "metadata": {}, "outputs": [{"data": {"text/plain": ["ModuleSpec(name='fractions', loader=<_frozen_importlib_external.SourceFileLoader object at 0x00000154B83757F0>, origin='D:\\\\Users\\\\fbapt\\\\Anaconda3\\\\lib\\\\fractions.py')"]}, "execution_count": 18, "metadata": {}, "output_type": "execute_result"}], "source": ["importlib.util.find_spec('fractions')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's write out a small source file to disk, called module1.py:"]}, {"cell_type": "code", "execution_count": 19, "metadata": {"collapsed": true}, "outputs": [], "source": ["with open('module1.py', 'w') as code_file:\n", "    code_file.write(\"print('running module1.py...')\\n\")\n", "    code_file.write('a = 100\\n')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now that we have the module on disk, we can ask `importlib` for the module spec:"]}, {"cell_type": "code", "execution_count": 20, "metadata": {}, "outputs": [{"data": {"text/plain": ["ModuleSpec(name='module1', loader=<_frozen_importlib_external.SourceFileLoader object at 0x00000154B8435390>, origin='d:\\\\fbapt\\\\Dropbox\\\\Python Deep Dive\\\\Section 09 - Modules, Packages and Namespaces\\\\04 - Imports and importlib\\\\module1.py')"]}, "execution_count": 20, "metadata": {}, "output_type": "execute_result"}], "source": ["importlib.util.find_spec('module1')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see, it found the file and indicated it would be imported using the SourceFileLoader."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now let's go ahead and actually import it:"]}, {"cell_type": "code", "execution_count": 21, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["running module1.py...\n"]}], "source": ["import module1"]}, {"cell_type": "code", "execution_count": 22, "metadata": {}, "outputs": [{"data": {"text/plain": ["100"]}, "execution_count": 22, "metadata": {}, "output_type": "execute_result"}], "source": ["module1.a"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now let's go ahead and write a file somewhere other than our source folder - you'll have to change this code to specify your path where you want that module file to be created:"]}, {"cell_type": "code", "execution_count": 23, "metadata": {"collapsed": true}, "outputs": [], "source": ["import os\n", "\n", "# you can use this for Mac/Linux:\n", "# ext_module_path = os.environ['HOME']\n", "\n", "# you can use this in Windows 10\n", "#ext_module_path = os.environ['HOMEPATH']\n", "\n", "# or you can just hard code some path\n", "# ext_module_path = 'c:\\\\temp' \n", "\n", "ext_module_path = os.environ.get('HOME', os.environ['HOMEPATH'])"]}, {"cell_type": "code", "execution_count": 24, "metadata": {}, "outputs": [{"data": {"text/plain": ["'\\\\Users\\\\fbapt'"]}, "execution_count": 24, "metadata": {}, "output_type": "execute_result"}], "source": ["ext_module_path"]}, {"cell_type": "code", "execution_count": 25, "metadata": {"collapsed": true}, "outputs": [], "source": ["file_abs_path = os.path.join(ext_module_path, 'module2.py')\n", "with open(file_abs_path, 'w') as code_file:\n", "    code_file.write(\"print('running module2.py...')\\n\")\n", "    code_file.write(\"x = 'python'\\n\")"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's see if Python can figure the module spec:"]}, {"cell_type": "code", "execution_count": 26, "metadata": {"collapsed": true}, "outputs": [], "source": ["importlib.util.find_spec('module2')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Nothing came back - it was not able to locate that module anywhere..."]}, {"cell_type": "code", "execution_count": 27, "metadata": {}, "outputs": [{"ename": "ModuleNotFoundError", "evalue": "No module named 'module2'", "output_type": "error", "traceback": ["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[1;31mModuleNotFoundError\u001b[0m                       Traceback (most recent call last)", "\u001b[1;32m<ipython-input-27-4fbab195dd19>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[1;32m----> 1\u001b[1;33m \u001b[1;32mimport\u001b[0m \u001b[0mmodule2\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m", "\u001b[1;31mModuleNotFoundError\u001b[0m: No module named 'module2'"]}], "source": ["import module2"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As expected, the import failed."]}, {"cell_type": "markdown", "metadata": {}, "source": ["By the way, you can use `try...except` for your imports!"]}, {"cell_type": "code", "execution_count": 28, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Module was not found.\n"]}], "source": ["try:\n", "    import module2\n", "except ModuleNotFoundError:\n", "    # could not find module\n", "    # maybe import an alternative module instead??\n", "    # e.g. import module1 as module2\n", "    # but please do not just silence the exception!\n", "    # if you're importing the module most likely you are\n", "    # using it somewhere in your code - so raise an \n", "    # exception at the precise location where the root cause\n", "    # occurred!\n", "    # so the following is BAD!!\n", "    print('Module was not found.')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The module was not found because `sys.path` knows nothing about `ext_module_path`."]}, {"cell_type": "code", "execution_count": 29, "metadata": {}, "outputs": [{"data": {"text/plain": ["False"]}, "execution_count": 29, "metadata": {}, "output_type": "execute_result"}], "source": ["ext_module_path in sys.path"]}, {"cell_type": "markdown", "metadata": {}, "source": ["So, let's add it!"]}, {"cell_type": "code", "execution_count": 30, "metadata": {"collapsed": true}, "outputs": [], "source": ["sys.path.append(ext_module_path)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now let's try finding the module spec again:"]}, {"cell_type": "code", "execution_count": 31, "metadata": {}, "outputs": [{"data": {"text/plain": ["ModuleSpec(name='module2', loader=<_frozen_importlib_external.SourceFileLoader object at 0x00000154B84356A0>, origin='\\\\Users\\\\fbapt\\\\module2.py')"]}, "execution_count": 31, "metadata": {}, "output_type": "execute_result"}], "source": ["importlib.util.find_spec('module2')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Hurray! Our import should now work..."]}, {"cell_type": "code", "execution_count": 32, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["running module2.py...\n"]}], "source": ["import module2"]}, {"cell_type": "code", "execution_count": 33, "metadata": {}, "outputs": [{"data": {"text/plain": ["'python'"]}, "execution_count": 33, "metadata": {}, "output_type": "execute_result"}], "source": ["module2.x"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can \"hack\" the `sys.path` list by adding our own entries directly - but this means we would have to hard code these paths in our code, or potentially read them from a configuration file.\n", "\n", "It's perfectly fine to do that, but you may prefer using `.pth` files for that.\n", "\n", "I'm not going to get into the details of this - the Python docs are located here:\n", "\n", "https://docs.python.org/3/library/site.html"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Import Variants and Misconceptions"]}, {"cell_type": "markdown", "metadata": {}, "source": ["I would like to briefly discuss the various import variants such as:\n", "\n", "* `import math`\n", "* `from math import sqrt, abs`\n", "* `from math import *`\n", "* `import math as r_math`\n", "* `from math import sqrt as r_sqrt`"]}, {"cell_type": "markdown", "metadata": {}, "source": ["##### import math"]}, {"cell_type": "markdown", "metadata": {}, "source": ["* loads the entire module (`math`) in memory if it's not already there\n", "* adds a reference to it in `sys.modules` with a key of `math`\n", "* adds a symbol of the same name (`math`) in our current namespace referencing the `math` object"]}, {"cell_type": "markdown", "metadata": {}, "source": ["##### import math as r_math"]}, {"cell_type": "markdown", "metadata": {}, "source": ["* loads the entire module (`math`) in memory if it's not already there\n", "* adds a reference to it in `sys.modules` with a key of `math`\n", "* adds the symbol `r_math` to our current namespace referencing the `math` object"]}, {"cell_type": "markdown", "metadata": {}, "source": ["##### from math import sqrt"]}, {"cell_type": "markdown", "metadata": {}, "source": ["* loads the entire module (`math`) in memory if it's not already there\n", "* adds a reference to it in `sys.modules` with a key of `math`\n", "* adds the symbol `sqrt` to our current namespace referencing the `math.sqrt` function\n", "* it **does not** add the symbol `math` to our current namespace"]}, {"cell_type": "markdown", "metadata": {}, "source": ["##### from math import sqrt as r_sqrt"]}, {"cell_type": "markdown", "metadata": {}, "source": ["* loads the entire module (`math`) in memory if it's not already there\n", "* adds a reference to it in `sys.modules` with a key of `math`\n", "* adds the symbol `r_sqrt` to our current namespace referencing the `math.sqrt` function\n", "* it **does not** add the symbol `math` to our current namespace"]}, {"cell_type": "markdown", "metadata": {}, "source": ["##### from math import *"]}, {"cell_type": "markdown", "metadata": {}, "source": ["* loads the entire module (`math`) in memory if it's not already there\n", "* adds a reference to it in `sys.modules` with a key of `math`\n", "* adds symbols for all exported symbols in the `math` module directly to our name space (we'll see how what is exported from a module/package can be controlled using underscores or `__all__` later)\n", "* it **does not** add the symbol `math` to our current namespace"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see, in **every** instance, the module is imported and a reference to it is added to `sys.modules`. The variants really have to do with what is injected into our current **namespace**: the module name, an alias to it, just the specified symbols from the module, or all the exported symbols from the module."]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Misconceptions"]}, {"cell_type": "markdown", "metadata": {}, "source": ["This leads to the first misconception:"]}, {"cell_type": "markdown", "metadata": {}, "source": ["\"You should use\n", "\n", "`from math import sqrt, abs`\n", "\n", "rather than \n", "\n", "`import math`\n", "\n", "because that way you only import what you need and you're not having Python load the entire module?\""]}, {"cell_type": "markdown", "metadata": {}, "source": ["For `math` that's just not true. In fact for any *simple* module.\n", "\n", "For *packages* that have subpackages, that may or may not be true - we'll see that later."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's actually test this out.\n", "\n", "We have to be a little careful, because Jupyter imports a ton of modules and packages:"]}, {"cell_type": "code", "execution_count": 1, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["IPython\n", "IPython.core\n", "IPython.core.alias\n", "IPython.core.application\n", "IPython.core.autocall\n", "IPython.core.builtin_trap\n", "IPython.core.compilerop\n", "IPython.core.completer\n", "IPython.core.completerlib\n", "IPython.core.crashhandler\n", "IPython.core.debugger\n", "IPython.core.display\n", "IPython.core.display_trap\n", "IPython.core.displayhook\n", "IPython.core.displaypub\n", "IPython.core.error\n", "IPython.core.events\n", "IPython.core.excolors\n", "IPython.core.extensions\n", "IPython.core.formatters\n", "IPython.core.getipython\n", "IPython.core.history\n", "IPython.core.hooks\n", "IPython.core.inputsplitter\n", "IPython.core.inputtransformer\n", "IPython.core.interactiveshell\n", "IPython.core.latex_symbols\n", "IPython.core.logger\n", "IPython.core.macro\n", "IPython.core.magic\n", "IPython.core.magic_arguments\n", "IPython.core.magics\n", "IPython.core.magics.auto\n", "IPython.core.magics.basic\n", "IPython.core.magics.code\n", "IPython.core.magics.config\n", "IPython.core.magics.display\n", "IPython.core.magics.execution\n", "IPython.core.magics.extension\n", "IPython.core.magics.history\n", "IPython.core.magics.logging\n", "IPython.core.magics.namespace\n", "IPython.core.magics.osm\n", "IPython.core.magics.pylab\n", "IPython.core.magics.script\n", "IPython.core.oinspect\n", "IPython.core.page\n", "IPython.core.payload\n", "IPython.core.payloadpage\n", "IPython.core.prefilter\n", "IPython.core.profiledir\n", "IPython.core.pylabtools\n", "IPython.core.release\n", "IPython.core.shadowns\n", "IPython.core.shellapp\n", "IPython.core.splitinput\n", "IPython.core.ultratb\n", "IPython.core.usage\n", "IPython.display\n", "IPython.extensions\n", "IPython.extensions.storemagic\n", "IPython.lib\n", "IPython.lib.backgroundjobs\n", "IPython.lib.clipboard\n", "IPython.lib.deepreload\n", "IPython.lib.display\n", "IPython.lib.pretty\n", "IPython.lib.security\n", "IPython.paths\n", "IPython.terminal\n", "IPython.terminal.debugger\n", "IPython.terminal.embed\n", "IPython.terminal.interactiveshell\n", "IPython.terminal.ipapp\n", "IPython.terminal.magics\n", "IPython.terminal.prompts\n", "IPython.terminal.pt_inputhooks\n", "IPython.terminal.ptutils\n", "IPython.terminal.shortcuts\n", "IPython.testing\n", "IPython.testing.skipdoctest\n", "IPython.utils\n", "IPython.utils.PyColorize\n", "IPython.utils._process_common\n", "IPython.utils._process_win32\n", "IPython.utils._sysinfo\n", "IPython.utils._tokenize_py3\n", "IPython.utils.capture\n", "IPython.utils.colorable\n", "IPython.utils.coloransi\n", "IPython.utils.contexts\n", "IPython.utils.data\n", "IPython.utils.decorators\n", "IPython.utils.dir2\n", "IPython.utils.encoding\n", "IPython.utils.frame\n", "IPython.utils.generics\n", "IPython.utils.importstring\n", "IPython.utils.io\n", "IPython.utils.ipstruct\n", "IPython.utils.module_paths\n", "IPython.utils.openpy\n", "IPython.utils.path\n", "IPython.utils.process\n", "IPython.utils.py3compat\n", "IPython.utils.sentinel\n", "IPython.utils.signatures\n", "IPython.utils.strdispatch\n", "IPython.utils.sysinfo\n", "IPython.utils.syspathcontext\n", "IPython.utils.tempdir\n", "IPython.utils.terminal\n", "IPython.utils.text\n", "IPython.utils.timing\n", "IPython.utils.tokenize2\n", "IPython.utils.tokenutil\n", "IPython.utils.ulinecache\n", "IPython.utils.wildcard\n", "__future__\n", "__main__\n", "__mp_main__\n", "_ast\n", "_bisect\n", "_blake2\n", "_bootlocale\n", "_bz2\n", "_codecs\n", "_collections\n", "_collections_abc\n", "_compat_pickle\n", "_compression\n", "_ctypes\n", "_cython_0_25_1\n", "_datetime\n", "_frozen_importlib\n", "_frozen_importlib_external\n", "_functools\n", "_hashlib\n", "_heapq\n", "_imp\n", "_io\n", "_json\n", "_locale\n", "_lsprof\n", "_lzma\n", "_multiprocessing\n", "_opcode\n", "_operator\n", "_pickle\n", "_random\n", "_sha3\n", "_signal\n", "_sitebuiltins\n", "_socket\n", "_sqlite3\n", "_sre\n", "_stat\n", "_string\n", "_strptime\n", "_struct\n", "_thread\n", "_warnings\n", "_weakref\n", "_weakrefset\n", "_win32sysloader\n", "_winapi\n", "abc\n", "argparse\n", "array\n", "ast\n", "atexit\n", "base64\n", "bdb\n", "binascii\n", "bisect\n", "builtins\n", "bz2\n", "cProfile\n", "calendar\n", "cmd\n", "code\n", "codecs\n", "codeop\n", "collections\n", "collections.abc\n", "colorama\n", "colorama.ansi\n", "colorama.ansitowin32\n", "colorama.initialise\n", "colorama.win32\n", "colorama.winterm\n", "concurrent\n", "concurrent.futures\n", "concurrent.futures._base\n", "concurrent.futures.process\n", "concurrent.futures.thread\n", "contextlib\n", "copy\n", "copyreg\n", "ctypes\n", "ctypes._endian\n", "ctypes.util\n", "ctypes.wintypes\n", "datetime\n", "dateutil\n", "dateutil._common\n", "dateutil.parser\n", "dateutil.relativedelta\n", "dateutil.tz\n", "dateutil.tz._common\n", "dateutil.tz.tz\n", "dateutil.tz.win\n", "decorator\n", "dis\n", "email\n", "email._parseaddr\n", "email._policybase\n", "email.base64mime\n", "email.charset\n", "email.encoders\n", "email.errors\n", "email.feedparser\n", "email.header\n", "email.parser\n", "email.quoprimime\n", "email.utils\n", "encodings\n", "encodings.aliases\n", "encodings.cp1252\n", "encodings.cp437\n", "encodings.latin_1\n", "encodings.utf_8\n", "enum\n", "errno\n", "faulthandler\n", "fnmatch\n", "functools\n", "gc\n", "genericpath\n", "getopt\n", "getpass\n", "gettext\n", "glob\n", "hashlib\n", "heapq\n", "hmac\n", "html\n", "html.entities\n", "imp\n", "importlib\n", "importlib._bootstrap\n", "importlib._bootstrap_external\n", "importlib.abc\n", "importlib.machinery\n", "importlib.util\n", "inspect\n", "io\n", "ipykernel\n", "ipykernel._version\n", "ipykernel.codeutil\n", "ipykernel.comm\n", "ipykernel.comm.comm\n", "ipykernel.comm.manager\n", "ipykernel.connect\n", "ipykernel.datapub\n", "ipykernel.displayhook\n", "ipykernel.heartbeat\n", "ipykernel.iostream\n", "ipykernel.ipkernel\n", "ipykernel.jsonutil\n", "ipykernel.kernelapp\n", "ipykernel.kernelbase\n", "ipykernel.parentpoller\n", "ipykernel.pickleutil\n", "ipykernel.serialize\n", "ipykernel.zmqshell\n", "ipython_genutils\n", "ipython_genutils._version\n", "ipython_genutils.encoding\n", "ipython_genutils.importstring\n", "ipython_genutils.path\n", "ipython_genutils.py3compat\n", "ipython_genutils.text\n", "ipywidgets\n", "ipywidgets._version\n", "ipywidgets.widgets\n", "ipywidgets.widgets.domwidget\n", "ipywidgets.widgets.interaction\n", "ipywidgets.widgets.trait_types\n", "ipywidgets.widgets.valuewidget\n", "ipywidgets.widgets.widget\n", "ipywidgets.widgets.widget_bool\n", "ipywidgets.widgets.widget_box\n", "ipywidgets.widgets.widget_button\n", "ipywidgets.widgets.widget_color\n", "ipywidgets.widgets.widget_controller\n", "ipywidgets.widgets.widget_core\n", "ipywidgets.widgets.widget_date\n", "ipywidgets.widgets.widget_float\n", "ipywidgets.widgets.widget_image\n", "ipywidgets.widgets.widget_int\n", "ipywidgets.widgets.widget_layout\n", "ipywidgets.widgets.widget_link\n", "ipywidgets.widgets.widget_output\n", "ipywidgets.widgets.widget_selection\n", "ipywidgets.widgets.widget_selectioncontainer\n", "ipywidgets.widgets.widget_string\n", "ipywidgets.widgets.widget_style\n", "itertools\n", "json\n", "json.decoder\n", "json.encoder\n", "json.scanner\n", "jupyter_client\n", "jupyter_client._version\n", "jupyter_client.adapter\n", "jupyter_client.blocking\n", "jupyter_client.blocking.channels\n", "jupyter_client.blocking.client\n", "jupyter_client.channels\n", "jupyter_client.channelsabc\n", "jupyter_client.client\n", "jupyter_client.clientabc\n", "jupyter_client.connect\n", "jupyter_client.jsonutil\n", "jupyter_client.kernelspec\n", "jupyter_client.launcher\n", "jupyter_client.localinterfaces\n", "jupyter_client.manager\n", "jupyter_client.managerabc\n", "jupyter_client.multikernelmanager\n", "jupyter_client.session\n", "jupyter_core\n", "jupyter_core.paths\n", "jupyter_core.version\n", "keyword\n", "linecache\n", "locale\n", "logging\n", "logging.handlers\n", "lzma\n", "marshal\n", "math\n", "mimetypes\n", "msvcrt\n", "multiprocessing\n", "multiprocessing.connection\n", "multiprocessing.context\n", "multiprocessing.process\n", "multiprocessing.reduction\n", "multiprocessing.util\n", "nt\n", "ntpath\n", "numbers\n", "opcode\n", "operator\n", "optparse\n", "os\n", "os.path\n", "pathlib\n", "pdb\n", "pickle\n", "pickleshare\n", "pkg_resources\n", "pkg_resources._vendor\n", "pkg_resources._vendor.packaging.__about__\n", "pkg_resources._vendor.six\n", "pkg_resources._vendor.six.moves\n", "pkg_resources.extern\n", "pkg_resources.extern.appdirs\n", "pkg_resources.extern.packaging\n", "pkg_resources.extern.packaging._compat\n", "pkg_resources.extern.packaging._structures\n", "pkg_resources.extern.packaging.markers\n", "pkg_resources.extern.packaging.requirements\n", "pkg_resources.extern.packaging.specifiers\n", "pkg_resources.extern.packaging.version\n", "pkg_resources.extern.pyparsing\n", "pkg_resources.extern.six\n", "pkg_resources.extern.six.moves\n", "pkg_resources.extern.six.moves.urllib\n", "pkgutil\n", "platform\n", "plistlib\n", "posixpath\n", "pprint\n", "profile\n", "prompt_toolkit\n", "prompt_toolkit.application\n", "prompt_toolkit.auto_suggest\n", "prompt_toolkit.buffer\n", "prompt_toolkit.buffer_mapping\n", "prompt_toolkit.cache\n", "prompt_toolkit.clipboard\n", "prompt_toolkit.clipboard.base\n", "prompt_toolkit.clipboard.in_memory\n", "prompt_toolkit.completion\n", "prompt_toolkit.document\n", "prompt_toolkit.enums\n", "prompt_toolkit.eventloop\n", "prompt_toolkit.eventloop.base\n", "prompt_toolkit.eventloop.callbacks\n", "prompt_toolkit.filters\n", "prompt_toolkit.filters.base\n", "prompt_toolkit.filters.cli\n", "prompt_toolkit.filters.types\n", "prompt_toolkit.filters.utils\n", "prompt_toolkit.history\n", "prompt_toolkit.input\n", "prompt_toolkit.interface\n", "prompt_toolkit.key_binding\n", "prompt_toolkit.key_binding.bindings\n", "prompt_toolkit.key_binding.bindings.basic\n", "prompt_toolkit.key_binding.bindings.completion\n", "prompt_toolkit.key_binding.bindings.emacs\n", "prompt_toolkit.key_binding.bindings.named_commands\n", "prompt_toolkit.key_binding.bindings.scroll\n", "prompt_toolkit.key_binding.bindings.vi\n", "prompt_toolkit.key_binding.defaults\n", "prompt_toolkit.key_binding.digraphs\n", "prompt_toolkit.key_binding.input_processor\n", "prompt_toolkit.key_binding.manager\n", "prompt_toolkit.key_binding.registry\n", "prompt_toolkit.key_binding.vi_state\n", "prompt_toolkit.keys\n", "prompt_toolkit.layout\n", "prompt_toolkit.layout.containers\n", "prompt_toolkit.layout.controls\n", "prompt_toolkit.layout.dimension\n", "prompt_toolkit.layout.lexers\n", "prompt_toolkit.layout.margins\n", "prompt_toolkit.layout.menus\n", "prompt_toolkit.layout.mouse_handlers\n", "prompt_toolkit.layout.processors\n", "prompt_toolkit.layout.prompt\n", "prompt_toolkit.layout.screen\n", "prompt_toolkit.layout.toolbars\n", "prompt_toolkit.layout.utils\n", "prompt_toolkit.mouse_events\n", "prompt_toolkit.output\n", "prompt_toolkit.reactive\n", "prompt_toolkit.renderer\n", "prompt_toolkit.search_state\n", "prompt_toolkit.selection\n", "prompt_toolkit.shortcuts\n", "prompt_toolkit.styles\n", "prompt_toolkit.styles.base\n", "prompt_toolkit.styles.defaults\n", "prompt_toolkit.styles.from_dict\n", "prompt_toolkit.styles.from_pygments\n", "prompt_toolkit.styles.utils\n", "prompt_toolkit.terminal\n", "prompt_toolkit.terminal.conemu_output\n", "prompt_toolkit.terminal.vt100_output\n", "prompt_toolkit.terminal.win32_input\n", "prompt_toolkit.terminal.win32_output\n", "prompt_toolkit.token\n", "prompt_toolkit.utils\n", "prompt_toolkit.validation\n", "prompt_toolkit.win32_types\n", "pstats\n", "pydoc\n", "pyexpat\n", "pyexpat.errors\n", "pyexpat.model\n", "pygments\n", "pygments.filter\n", "pygments.filters\n", "pygments.formatter\n", "pygments.formatters\n", "pygments.formatters._mapping\n", "pygments.formatters.html\n", "pygments.lexer\n", "pygments.lexers\n", "pygments.lexers._mapping\n", "pygments.lexers.python\n", "pygments.modeline\n", "pygments.plugin\n", "pygments.regexopt\n", "pygments.style\n", "pygments.styles\n", "pygments.styles.default\n", "pygments.token\n", "pygments.unistring\n", "pygments.util\n", "pythoncom\n", "pywintypes\n", "queue\n", "quopri\n", "random\n", "re\n", "reprlib\n", "runpy\n", "select\n", "selectors\n", "shlex\n", "shutil\n", "signal\n", "simplegeneric\n", "site\n", "six\n", "six.moves\n", "socket\n", "sqlite3\n", "sqlite3.dbapi2\n", "sre_compile\n", "sre_constants\n", "sre_parse\n", "stat\n", "storemagic\n", "string\n", "struct\n", "subprocess\n", "sys\n", "sysconfig\n", "tempfile\n", "textwrap\n", "threading\n", "time\n", "timeit\n", "token\n", "tokenize\n", "tornado\n", "tornado.concurrent\n", "tornado.escape\n", "tornado.ioloop\n", "tornado.log\n", "tornado.platform\n", "tornado.platform.auto\n", "tornado.platform.common\n", "tornado.platform.interface\n", "tornado.platform.windows\n", "tornado.speedups\n", "tornado.stack_context\n", "tornado.util\n", "traceback\n", "traitlets\n", "traitlets._version\n", "traitlets.config\n", "traitlets.config.application\n", "traitlets.config.configurable\n", "traitlets.config.loader\n", "traitlets.log\n", "traitlets.traitlets\n", "traitlets.utils\n", "traitlets.utils.bunch\n", "traitlets.utils.getargspec\n", "traitlets.utils.importstring\n", "traitlets.utils.sentinel\n", "types\n", "typing\n", "typing.io\n", "typing.re\n", "unicodedata\n", "urllib\n", "urllib.parse\n", "uuid\n", "warnings\n", "wcwidth\n", "wcwidth.table_wide\n", "wcwidth.table_zero\n", "wcwidth.wcwidth\n", "weakref\n", "win32api\n", "win32com\n", "win32com.gen_py\n", "win32com.shell\n", "winreg\n", "xml\n", "xml.parsers\n", "xml.parsers.expat\n", "xml.parsers.expat.errors\n", "xml.parsers.expat.model\n", "zipfile\n", "zipimport\n", "zlib\n", "zmq\n", "zmq.backend\n", "zmq.backend.cython\n", "zmq.backend.cython._device\n", "zmq.backend.cython._poll\n", "zmq.backend.cython._version\n", "zmq.backend.cython.constants\n", "zmq.backend.cython.context\n", "zmq.backend.cython.error\n", "zmq.backend.cython.message\n", "zmq.backend.cython.socket\n", "zmq.backend.cython.utils\n", "zmq.backend.select\n", "zmq.error\n", "zmq.eventloop\n", "zmq.eventloop.ioloop\n", "zmq.eventloop.zmqstream\n", "zmq.libzmq\n", "zmq.sugar\n", "zmq.sugar.attrsettr\n", "zmq.sugar.constants\n", "zmq.sugar.context\n", "zmq.sugar.frame\n", "zmq.sugar.poll\n", "zmq.sugar.socket\n", "zmq.sugar.stopwatch\n", "zmq.sugar.tracker\n", "zmq.sugar.version\n", "zmq.utils\n", "zmq.utils.constant_names\n", "zmq.utils.jsonapi\n", "zmq.utils.strtypes\n"]}], "source": ["import sys\n", "for key in sorted(sys.modules.keys()):\n", "    print(key)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["so they're already loaded and in the `sys.modules` dictionary.\n", "\n", "\n", "Fortunately `cmath` is not one of them, so we'll use that one."]}, {"cell_type": "code", "execution_count": 2, "metadata": {}, "outputs": [{"data": {"text/plain": ["False"]}, "execution_count": 2, "metadata": {}, "output_type": "execute_result"}], "source": ["'cmath' in sys.modules"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's go ahead and just import a single symbol from `cmath`, the `exp` function:"]}, {"cell_type": "code", "execution_count": 3, "metadata": {"collapsed": true}, "outputs": [], "source": ["from cmath import exp"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now let's see if `cmath` and `exp` are in our module (global) namespace:"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"data": {"text/plain": ["False"]}, "execution_count": 4, "metadata": {}, "output_type": "execute_result"}], "source": ["'cmath' in globals()"]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 5, "metadata": {}, "output_type": "execute_result"}], "source": ["'exp' in globals()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["OK, so basically what that import did was create a symbol for `exp` in our namespace, but not for `cmath`.\n", "\n", "Does this mean that `cmath` was only \"partially\" loaded?"]}, {"cell_type": "markdown", "metadata": {}, "source": ["How can Python \"partially\" load a (simple) module? How would it even know what to load up? Sure, maybe it could do some fancy kind of introspection and determine all the dependencies the symbols we are importing require. But it does not.\n", "\n", "It simply imports the entire module (using the techniques we have been covering in the last few videos)\n", "\n", "If we really want to partially load something, we would use a package, which, while still a `module` type, can be composed of several sub-packages. More on that later."]}, {"cell_type": "markdown", "metadata": {}, "source": ["In, fact let's look at it in `sys.modules`:"]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [{"data": {"text/plain": ["<module 'cmath' (built-in)>"]}, "execution_count": 6, "metadata": {}, "output_type": "execute_result"}], "source": ["sys.modules['cmath']"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Yep, it's there...\n", "\n", "We can even get a handle to the `cmath` module:"]}, {"cell_type": "code", "execution_count": 7, "metadata": {"collapsed": true}, "outputs": [], "source": ["cmath = sys.modules['cmath']"]}, {"cell_type": "code", "execution_count": 8, "metadata": {}, "outputs": [{"data": {"text/plain": ["<module 'cmath' (built-in)>"]}, "execution_count": 8, "metadata": {}, "output_type": "execute_result"}], "source": ["cmath"]}, {"cell_type": "markdown", "metadata": {}, "source": ["And now we can use `cmath` just as if we had done \n", "\n", "`import cmath`\n", "\n", "But you'll note that in this case we did not import the module, we did `from cmath import exp` only."]}, {"cell_type": "markdown", "metadata": {}, "source": ["So we can use `exp` directly because of how we imported that specific symbol:"]}, {"cell_type": "code", "execution_count": 9, "metadata": {}, "outputs": [{"data": {"text/plain": ["(-7.315110094901103+1.0427436562359045j)"]}, "execution_count": 9, "metadata": {}, "output_type": "execute_result"}], "source": ["exp(2+3j)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But we can also use the `cmath` module directly now that we retrieved it from `sys.modules`:"]}, {"cell_type": "code", "execution_count": 10, "metadata": {}, "outputs": [{"data": {"text/plain": ["(1.09868411346781+0.45508986056222733j)"]}, "execution_count": 10, "metadata": {}, "output_type": "execute_result"}], "source": ["cmath.sqrt(1+1j)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["So, the **entire** `cmath` module was loaded when we ran `from cmath import exp`, not just a portion of it!"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The only thing that happened is that Python put `cmath` in `sys.modules`, but **did not** add a `cmath` symbol to our module namespace, and **only added** the function `exp` to our namespace."]}, {"cell_type": "markdown", "metadata": {}, "source": ["What about doing something like this:\n", "\n", "`from cmath import *`"]}, {"cell_type": "markdown", "metadata": {}, "source": ["This is often frowned upon, and sometimes for good reason - but this is not a universal truth either.\n", "\n", "Let's see why, in our current context, it's maybe not such a good thing.\n", "\n", "First let's see what our global namespace looks like:"]}, {"cell_type": "code", "execution_count": 11, "metadata": {}, "outputs": [{"data": {"text/plain": ["{'In': ['',\n", "  'import sys\\nfor key in sorted(sys.modules.keys()):\\n    print(key)',\n", "  \"'cmath' in sys.modules\",\n", "  'from cmath import exp',\n", "  \"'cmath' in globals()\",\n", "  \"'exp' in globals()\",\n", "  \"sys.modules['cmath']\",\n", "  \"cmath = sys.modules['cmath']\",\n", "  'cmath',\n", "  'exp(2+3j)',\n", "  'cmath.sqrt(1+1j)',\n", "  'globals()'],\n", " 'Out': {2: False,\n", "  4: False,\n", "  5: True,\n", "  6: <module 'cmath' (built-in)>,\n", "  8: <module 'cmath' (built-in)>,\n", "  9: (-7.315110094901103+1.0427436562359045j),\n", "  10: (1.09868411346781+0.45508986056222733j)},\n", " '_': (1.09868411346781+0.45508986056222733j),\n", " '_10': (1.09868411346781+0.45508986056222733j),\n", " '_2': False,\n", " '_4': False,\n", " '_5': True,\n", " '_6': <module 'cmath' (built-in)>,\n", " '_8': <module 'cmath' (built-in)>,\n", " '_9': (-7.315110094901103+1.0427436562359045j),\n", " '__': (-7.315110094901103+1.0427436562359045j),\n", " '___': <module 'cmath' (built-in)>,\n", " '__builtin__': <module 'builtins' (built-in)>,\n", " '__builtins__': <module 'builtins' (built-in)>,\n", " '__doc__': 'Automatically created module for IPython interactive environment',\n", " '__loader__': None,\n", " '__name__': '__main__',\n", " '__package__': None,\n", " '__spec__': None,\n", " '_dh': ['d:\\\\fbapt\\\\Dropbox\\\\Python Deep Dive\\\\Section 09 - Modules, Packages and Namespaces\\\\05 - Import Variants and Misconceptions'],\n", " '_i': 'cmath.sqrt(1+1j)',\n", " '_i1': 'import sys\\nfor key in sorted(sys.modules.keys()):\\n    print(key)',\n", " '_i10': 'cmath.sqrt(1+1j)',\n", " '_i11': 'globals()',\n", " '_i2': \"'cmath' in sys.modules\",\n", " '_i3': 'from cmath import exp',\n", " '_i4': \"'cmath' in globals()\",\n", " '_i5': \"'exp' in globals()\",\n", " '_i6': \"sys.modules['cmath']\",\n", " '_i7': \"cmath = sys.modules['cmath']\",\n", " '_i8': 'cmath',\n", " '_i9': 'exp(2+3j)',\n", " '_ih': ['',\n", "  'import sys\\nfor key in sorted(sys.modules.keys()):\\n    print(key)',\n", "  \"'cmath' in sys.modules\",\n", "  'from cmath import exp',\n", "  \"'cmath' in globals()\",\n", "  \"'exp' in globals()\",\n", "  \"sys.modules['cmath']\",\n", "  \"cmath = sys.modules['cmath']\",\n", "  'cmath',\n", "  'exp(2+3j)',\n", "  'cmath.sqrt(1+1j)',\n", "  'globals()'],\n", " '_ii': 'exp(2+3j)',\n", " '_iii': 'cmath',\n", " '_oh': {2: False,\n", "  4: False,\n", "  5: True,\n", "  6: <module 'cmath' (built-in)>,\n", "  8: <module 'cmath' (built-in)>,\n", "  9: (-7.315110094901103+1.0427436562359045j),\n", "  10: (1.09868411346781+0.45508986056222733j)},\n", " '_sh': <module 'IPython.core.shadowns' from 'D:\\\\Users\\\\fbapt\\\\Anaconda3\\\\lib\\\\site-packages\\\\IPython\\\\core\\\\shadowns.py'>,\n", " 'cmath': <module 'cmath' (built-in)>,\n", " 'exit': <IPython.core.autocall.ZMQExitAutocall at 0x1b7b61ecb00>,\n", " 'exp': <function cmath.exp>,\n", " 'get_ipython': <bound method InteractiveShell.get_ipython of <ipykernel.zmqshell.ZMQInteractiveShell object at 0x000001B7B61A84A8>>,\n", " 'key': 'zmq.utils.strtypes',\n", " 'quit': <IPython.core.autocall.ZMQExitAutocall at 0x1b7b61ecb00>,\n", " 'sys': <module 'sys' (built-in)>}"]}, "execution_count": 11, "metadata": {}, "output_type": "execute_result"}], "source": ["globals()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now let's do that import:"]}, {"cell_type": "code", "execution_count": 12, "metadata": {"collapsed": true}, "outputs": [], "source": ["from cmath import *"]}, {"cell_type": "markdown", "metadata": {}, "source": ["And let's see our namespace now:"]}, {"cell_type": "code", "execution_count": 13, "metadata": {}, "outputs": [{"data": {"text/plain": ["{'In': ['',\n", "  'import sys\\nfor key in sorted(sys.modules.keys()):\\n    print(key)',\n", "  \"'cmath' in sys.modules\",\n", "  'from cmath import exp',\n", "  \"'cmath' in globals()\",\n", "  \"'exp' in globals()\",\n", "  \"sys.modules['cmath']\",\n", "  \"cmath = sys.modules['cmath']\",\n", "  'cmath',\n", "  'exp(2+3j)',\n", "  'cmath.sqrt(1+1j)',\n", "  'globals()',\n", "  'from cmath import *',\n", "  'globals()'],\n", " 'Out': {2: False,\n", "  4: False,\n", "  5: True,\n", "  6: <module 'cmath' (built-in)>,\n", "  8: <module 'cmath' (built-in)>,\n", "  9: (-7.315110094901103+1.0427436562359045j),\n", "  10: (1.09868411346781+0.45508986056222733j),\n", "  11: {...}},\n", " '_': {...},\n", " '_10': (1.09868411346781+0.45508986056222733j),\n", " '_11': {...},\n", " '_2': False,\n", " '_4': False,\n", " '_5': True,\n", " '_6': <module 'cmath' (built-in)>,\n", " '_8': <module 'cmath' (built-in)>,\n", " '_9': (-7.315110094901103+1.0427436562359045j),\n", " '__': (1.09868411346781+0.45508986056222733j),\n", " '___': (-7.315110094901103+1.0427436562359045j),\n", " '__builtin__': <module 'builtins' (built-in)>,\n", " '__builtins__': <module 'builtins' (built-in)>,\n", " '__doc__': 'Automatically created module for IPython interactive environment',\n", " '__loader__': None,\n", " '__name__': '__main__',\n", " '__package__': None,\n", " '__spec__': None,\n", " '_dh': ['d:\\\\fbapt\\\\Dropbox\\\\Python Deep Dive\\\\Section 09 - Modules, Packages and Namespaces\\\\05 - Import Variants and Misconceptions'],\n", " '_i': 'from cmath import *',\n", " '_i1': 'import sys\\nfor key in sorted(sys.modules.keys()):\\n    print(key)',\n", " '_i10': 'cmath.sqrt(1+1j)',\n", " '_i11': 'globals()',\n", " '_i12': 'from cmath import *',\n", " '_i13': 'globals()',\n", " '_i2': \"'cmath' in sys.modules\",\n", " '_i3': 'from cmath import exp',\n", " '_i4': \"'cmath' in globals()\",\n", " '_i5': \"'exp' in globals()\",\n", " '_i6': \"sys.modules['cmath']\",\n", " '_i7': \"cmath = sys.modules['cmath']\",\n", " '_i8': 'cmath',\n", " '_i9': 'exp(2+3j)',\n", " '_ih': ['',\n", "  'import sys\\nfor key in sorted(sys.modules.keys()):\\n    print(key)',\n", "  \"'cmath' in sys.modules\",\n", "  'from cmath import exp',\n", "  \"'cmath' in globals()\",\n", "  \"'exp' in globals()\",\n", "  \"sys.modules['cmath']\",\n", "  \"cmath = sys.modules['cmath']\",\n", "  'cmath',\n", "  'exp(2+3j)',\n", "  'cmath.sqrt(1+1j)',\n", "  'globals()',\n", "  'from cmath import *',\n", "  'globals()'],\n", " '_ii': 'globals()',\n", " '_iii': 'cmath.sqrt(1+1j)',\n", " '_oh': {2: False,\n", "  4: False,\n", "  5: True,\n", "  6: <module 'cmath' (built-in)>,\n", "  8: <module 'cmath' (built-in)>,\n", "  9: (-7.315110094901103+1.0427436562359045j),\n", "  10: (1.09868411346781+0.45508986056222733j),\n", "  11: {...}},\n", " '_sh': <module 'IPython.core.shadowns' from 'D:\\\\Users\\\\fbapt\\\\Anaconda3\\\\lib\\\\site-packages\\\\IPython\\\\core\\\\shadowns.py'>,\n", " 'acos': <function cmath.acos>,\n", " 'acosh': <function cmath.acosh>,\n", " 'asin': <function cmath.asin>,\n", " 'asinh': <function cmath.asinh>,\n", " 'atan': <function cmath.atan>,\n", " 'atanh': <function cmath.atanh>,\n", " 'cmath': <module 'cmath' (built-in)>,\n", " 'cos': <function cmath.cos>,\n", " 'cosh': <function cmath.cosh>,\n", " 'e': 2.718281828459045,\n", " 'exit': <IPython.core.autocall.ZMQExitAutocall at 0x1b7b61ecb00>,\n", " 'exp': <function cmath.exp>,\n", " 'get_ipython': <bound method InteractiveShell.get_ipython of <ipykernel.zmqshell.ZMQInteractiveShell object at 0x000001B7B61A84A8>>,\n", " 'inf': inf,\n", " 'infj': infj,\n", " 'isclose': <function cmath.isclose>,\n", " 'isfinite': <function cmath.isfinite>,\n", " 'isinf': <function cmath.isinf>,\n", " 'isnan': <function cmath.isnan>,\n", " 'key': 'zmq.utils.strtypes',\n", " 'log': <function cmath.log>,\n", " 'log10': <function cmath.log10>,\n", " 'nan': nan,\n", " 'nanj': nanj,\n", " 'phase': <function cmath.phase>,\n", " 'pi': 3.141592653589793,\n", " 'polar': <function cmath.polar>,\n", " 'quit': <IPython.core.autocall.ZMQExitAutocall at 0x1b7b61ecb00>,\n", " 'rect': <function cmath.rect>,\n", " 'sin': <function cmath.sin>,\n", " 'sinh': <function cmath.sinh>,\n", " 'sqrt': <function cmath.sqrt>,\n", " 'sys': <module 'sys' (built-in)>,\n", " 'tan': <function cmath.tan>,\n", " 'tanh': <function cmath.tanh>,\n", " 'tau': 6.283185307179586}"]}, "execution_count": 13, "metadata": {}, "output_type": "execute_result"}], "source": ["globals()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Some people say the namespace was \"polluted\". In a way I guess that's true, but it does mean I can now access **all** attributes in `cmath` without prefixing them with `cmath` all the time: "]}, {"cell_type": "code", "execution_count": 14, "metadata": {}, "outputs": [{"data": {"text/plain": ["(1.5537739740300374+0.6435942529055826j)"]}, "execution_count": 14, "metadata": {}, "output_type": "execute_result"}], "source": ["sqrt(2+2j)"]}, {"cell_type": "code", "execution_count": 15, "metadata": {}, "outputs": [{"data": {"text/plain": ["3.141592653589793"]}, "execution_count": 15, "metadata": {}, "output_type": "execute_result"}], "source": ["pi"]}, {"cell_type": "code", "execution_count": 16, "metadata": {}, "outputs": [{"data": {"text/plain": ["(9.15449914691143+4.168906959966565j)"]}, "execution_count": 16, "metadata": {}, "output_type": "execute_result"}], "source": ["sin(2-3j)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["In and of itself, there's nothing wrong with that...\n", "\n", "But a couple of issues:"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The first one is that when I call `sin` just like that, someone reading my code does not immediately know where that function came from. Was it a function I implemented in my module? some other custom module? the `cmath` module? the `math` module?"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The second one is that you can run into serious problems if you also need to import the `math` module:"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Currently the `sqrt` symbol is the `cmath.sqrt` function:"]}, {"cell_type": "code", "execution_count": 17, "metadata": {}, "outputs": [{"data": {"text/plain": ["<function cmath.sqrt>"]}, "execution_count": 17, "metadata": {}, "output_type": "execute_result"}], "source": ["sqrt"]}, {"cell_type": "code", "execution_count": 18, "metadata": {"collapsed": true}, "outputs": [], "source": ["from math import *"]}, {"cell_type": "markdown", "metadata": {}, "source": ["What just happened to the `sqrt` function that was in our namespace?"]}, {"cell_type": "code", "execution_count": 19, "metadata": {}, "outputs": [{"data": {"text/plain": ["<function math.sqrt>"]}, "execution_count": 19, "metadata": {}, "output_type": "execute_result"}], "source": ["sqrt"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see, the symbol `sqrt` in our namespace no longer refers to the `sqrt` function in `cmath` but rather to the one in `math`.\n", "\n", "It just got replaced by the `sqrt` function in the `math` module because it has the same name (`sqrt`)."]}, {"cell_type": "markdown", "metadata": {}, "source": ["This is one of the reasons why `from ... import *` is sometimes frowned upon.\n", "\n", "But the same problem can happen if you use a `from` import this way:"]}, {"cell_type": "code", "execution_count": 20, "metadata": {"collapsed": true}, "outputs": [], "source": ["from cmath import sqrt\n", "from math import sqrt"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Same thing happened here, the `math.sqrt` function just clobbered the `cmath.sqrt` function.\n", "\n", "One option here is to use:"]}, {"cell_type": "code", "execution_count": 21, "metadata": {"collapsed": true}, "outputs": [], "source": ["import cmath\n", "import math"]}, {"cell_type": "code", "execution_count": 22, "metadata": {}, "outputs": [{"data": {"text/plain": ["1.4142135623730951"]}, "execution_count": 22, "metadata": {}, "output_type": "execute_result"}], "source": ["math.sqrt(2)"]}, {"cell_type": "code", "execution_count": 23, "metadata": {}, "outputs": [{"data": {"text/plain": ["(1.5537739740300374+0.6435942529055826j)"]}, "execution_count": 23, "metadata": {}, "output_type": "execute_result"}], "source": ["cmath.sqrt(2+2j)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But Python also allows us to alias our imports using the `as` keyword.\n", "\n", "We can alias either the entire module, or just the symbols being imported from the module:"]}, {"cell_type": "code", "execution_count": 24, "metadata": {"collapsed": true}, "outputs": [], "source": ["import math as r_math\n", "import cmath as c_math"]}, {"cell_type": "code", "execution_count": 25, "metadata": {}, "outputs": [{"data": {"text/plain": ["<module 'math' (built-in)>"]}, "execution_count": 25, "metadata": {}, "output_type": "execute_result"}], "source": ["r_math"]}, {"cell_type": "code", "execution_count": 26, "metadata": {}, "outputs": [{"data": {"text/plain": ["<module 'cmath' (built-in)>"]}, "execution_count": 26, "metadata": {}, "output_type": "execute_result"}], "source": ["c_math"]}, {"cell_type": "code", "execution_count": 27, "metadata": {}, "outputs": [{"data": {"text/plain": ["1.4142135623730951"]}, "execution_count": 27, "metadata": {}, "output_type": "execute_result"}], "source": ["r_math.sqrt(2)"]}, {"cell_type": "code", "execution_count": 28, "metadata": {}, "outputs": [{"data": {"text/plain": ["(1.4142135623730951+0j)"]}, "execution_count": 28, "metadata": {}, "output_type": "execute_result"}], "source": ["c_math.sqrt(2)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["By the way, this is the **exact** same result as doing:"]}, {"cell_type": "code", "execution_count": 29, "metadata": {"collapsed": true}, "outputs": [], "source": ["import importlib"]}, {"cell_type": "code", "execution_count": 30, "metadata": {"collapsed": true}, "outputs": [], "source": ["r_math = importlib.import_module('math')\n", "c_math = importlib.import_module('cmath')"]}, {"cell_type": "code", "execution_count": 31, "metadata": {}, "outputs": [{"data": {"text/plain": ["<module 'math' (built-in)>"]}, "execution_count": 31, "metadata": {}, "output_type": "execute_result"}], "source": ["r_math"]}, {"cell_type": "code", "execution_count": 32, "metadata": {}, "outputs": [{"data": {"text/plain": ["<module 'cmath' (built-in)>"]}, "execution_count": 32, "metadata": {}, "output_type": "execute_result"}], "source": ["c_math"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can also alias symbols from the imported module:"]}, {"cell_type": "code", "execution_count": 33, "metadata": {"collapsed": true}, "outputs": [], "source": ["from math import sqrt as r_sqrt\n", "from cmath import sqrt as c_sqrt"]}, {"cell_type": "code", "execution_count": 34, "metadata": {}, "outputs": [{"data": {"text/plain": ["<function math.sqrt>"]}, "execution_count": 34, "metadata": {}, "output_type": "execute_result"}], "source": ["r_sqrt"]}, {"cell_type": "code", "execution_count": 35, "metadata": {}, "outputs": [{"data": {"text/plain": ["<function cmath.sqrt>"]}, "execution_count": 35, "metadata": {}, "output_type": "execute_result"}], "source": ["c_sqrt"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Again, we can reproduce this using the following:"]}, {"cell_type": "code", "execution_count": 36, "metadata": {"collapsed": true}, "outputs": [], "source": ["r_sqrt = importlib.import_module('math').sqrt\n", "c_sqrt = importlib.import_module('cmath').sqrt"]}, {"cell_type": "code", "execution_count": 37, "metadata": {}, "outputs": [{"data": {"text/plain": ["<function math.sqrt>"]}, "execution_count": 37, "metadata": {}, "output_type": "execute_result"}], "source": ["r_sqrt"]}, {"cell_type": "code", "execution_count": 38, "metadata": {}, "outputs": [{"data": {"text/plain": ["<function cmath.sqrt>"]}, "execution_count": 38, "metadata": {}, "output_type": "execute_result"}], "source": ["c_sqrt"]}, {"cell_type": "markdown", "metadata": {}, "source": ["At the end of the day, the module is always loaded and cached (`sys.modules`), these different variants of the `import` statement merely determine what symbols are added to our module (global) namespace. That's it.\n", "\n", "It's a little different for packages as we'll see later."]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Efficiency"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The final thing we need to look at is often mentioned in various blog posts and online discussions.\n", "\n", "`import variant #1` is more \"efficient\" than `import variant #2`\n", "\n", "Maybe so, but realistically by how much?\n", "\n", "Or even how the following is terribly wrong because it re-imports the `math` module **every** time `my_func` is called:"]}, {"cell_type": "code", "execution_count": 39, "metadata": {"collapsed": true}, "outputs": [], "source": ["def my_func(a):\n", "    import math\n", "    return math.sqrt(a)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["From a readability standpoint, yes, that is **not** a good idea. Much better to put all your imports at the top of the module once in a location where any reader can easily see all your module dependencies.\n", "\n", "But as far as reloading the module, you should now understand that's absolutely not true. Instead, it has to do a dictionary lookup in the `sys.modules` dictionary, not reload the entire module after the first load has occurred!\n", "\n", "Dictionary lookups are blazingly fast in Python - so, yes, there is some overhead, but not as much as you may think."]}, {"cell_type": "markdown", "metadata": {}, "source": ["So, let's write some timing code to test these things and see how they compare.\n", "\n", "We shoudl consider both relative speed differences as well as absilute speed differences.\n", "\n", "If you try to optimize your code and end up reducing that code's speed by 50% that sounds good. But what if the original code ran in `1`s. Now it runs in `0.5`s. How long does the total program run? Down from `30`s to `29.5`s? Things are relative..."]}, {"cell_type": "code", "execution_count": 40, "metadata": {"collapsed": true}, "outputs": [], "source": ["from time import perf_counter"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Yes, I'm using a `from` import - for readability and typing reasons. How many other modules are out there where I run the risk of clobbering `perf_counter`? I can't think of one. Certainly not in any imports I'm going to be using here. It's such a unique name, I feel pretty safe!"]}, {"cell_type": "markdown", "metadata": {}, "source": ["I'm also going to write a small utility function that compares two timings to each other:"]}, {"cell_type": "code", "execution_count": 41, "metadata": {"collapsed": true}, "outputs": [], "source": ["from collections import namedtuple\n", "\n", "Timings = namedtuple('Timings', 'timing_1 timing_2 abs_diff rel_diff_perc')\n", "def compare_timings(timing1, timing2):\n", "    rel_diff = (timing2 - timing1)/timing1 * 100\n", "    \n", "    timings = Timings(round(timing1, 1),\n", "                     round(timing2, 1),\n", "                     round(timing2 - timing1, 2),\n", "                     round(rel_diff, 2))\n", "    return timings"]}, {"cell_type": "markdown", "metadata": {}, "source": ["##### Timing using fully qualified `module.symbol` "]}, {"cell_type": "code", "execution_count": 42, "metadata": {"collapsed": true}, "outputs": [], "source": ["test_repeats = 10_000_000"]}, {"cell_type": "code", "execution_count": 43, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Elapsed: 2.057656398357829\n"]}], "source": ["import math\n", "\n", "start = perf_counter()\n", "for _ in range(test_repeats):\n", "    math.sqrt(2)\n", "end = perf_counter()\n", "elapsed_fully_qualified = end - start\n", "print(f'Elapsed: {elapsed_fully_qualified}')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["##### Timing using a directly imported symbol name:"]}, {"cell_type": "code", "execution_count": 44, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Elapsed: 1.603430354697538\n"]}], "source": ["from math import sqrt\n", "\n", "start = perf_counter()\n", "for _ in range(test_repeats):\n", "    sqrt(2)\n", "end = perf_counter()\n", "elapsed_direct_symbol = end - start\n", "print(f'Elapsed: {elapsed_direct_symbol}')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's see the relative and absolute time differences:"]}, {"cell_type": "code", "execution_count": 45, "metadata": {}, "outputs": [{"data": {"text/plain": ["Timings(timing_1=2.1, timing_2=1.6, abs_diff=-0.45, rel_diff_perc=-22.07)"]}, "execution_count": 45, "metadata": {}, "output_type": "execute_result"}], "source": ["compare_timings(elapsed_fully_qualified, elapsed_direct_symbol)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Definitely faster - but in absolute terms I really did not save a whole lot - over `10,000,000` iterations!"]}, {"cell_type": "markdown", "metadata": {}, "source": ["##### Timing using a function (fully qualified symbol)"]}, {"cell_type": "code", "execution_count": 46, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Elapsed: 3.2668947610088703\n"]}], "source": ["import math\n", "\n", "def func():\n", "    math.sqrt(2)\n", "    \n", "start = perf_counter()\n", "for _ in range(test_repeats):\n", "    func()\n", "end = perf_counter()\n", "elapsed_func_fully_qualified = end - start\n", "print(f'Elapsed: {elapsed_func_fully_qualified}') "]}, {"cell_type": "code", "execution_count": 47, "metadata": {}, "outputs": [{"data": {"text/plain": ["Timings(timing_1=2.1, timing_2=3.3, abs_diff=1.21, rel_diff_perc=58.77)"]}, "execution_count": 47, "metadata": {}, "output_type": "execute_result"}], "source": ["compare_timings(elapsed_fully_qualified, elapsed_func_fully_qualified)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["That was slower because of the function call overhead, but not by much in absolute terms considering I called `func()` `10,000,000` times!"]}, {"cell_type": "markdown", "metadata": {}, "source": ["##### Timing using a function (direct symbol)"]}, {"cell_type": "code", "execution_count": 48, "metadata": {"scrolled": true}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Elapsed: 2.80123663975316\n"]}], "source": ["from math import sqrt\n", "\n", "def func():\n", "    sqrt(2)\n", "    \n", "start = perf_counter()\n", "for _ in range(test_repeats):\n", "    func()\n", "end = perf_counter()\n", "elapsed_func_direct_symbol = end - start\n", "print(f'Elapsed: {elapsed_func_direct_symbol}')"]}, {"cell_type": "code", "execution_count": 49, "metadata": {}, "outputs": [{"data": {"text/plain": ["Timings(timing_1=3.3, timing_2=2.8, abs_diff=-0.47, rel_diff_perc=-14.25)"]}, "execution_count": 49, "metadata": {}, "output_type": "execute_result"}], "source": ["compare_timings(elapsed_func_fully_qualified, elapsed_func_direct_symbol)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Slower, but again not by much in absolute terms considering this was for `10,000,000` iterations."]}, {"cell_type": "markdown", "metadata": {}, "source": ["##### Timing using a nested import (fully qualified symbol)"]}, {"cell_type": "code", "execution_count": 50, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Elapsed: 5.041648347331877\n"]}], "source": ["def func():\n", "    import math\n", "    math.sqrt(2)\n", "    \n", "start = perf_counter()\n", "for _ in range(test_repeats):\n", "    func()\n", "end = perf_counter()\n", "elapsed_nested_fully_qualified = end - start\n", "print(f'Elapsed: {elapsed_nested_fully_qualified}')"]}, {"cell_type": "code", "execution_count": 51, "metadata": {}, "outputs": [{"data": {"text/plain": ["Timings(timing_1=3.3, timing_2=5.0, abs_diff=1.77, rel_diff_perc=54.33)"]}, "execution_count": 51, "metadata": {}, "output_type": "execute_result"}], "source": ["compare_timings(elapsed_func_fully_qualified, elapsed_nested_fully_qualified)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["So definitely slower. But in absolute terms, for `10,000,000` iterations?"]}, {"cell_type": "markdown", "metadata": {}, "source": ["##### Timing using a nested import (direct symbol)"]}, {"cell_type": "code", "execution_count": 52, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Elapsed: 14.60262281403945\n"]}], "source": ["def func():\n", "    from math import sqrt\n", "    sqrt(2)\n", "    \n", "start = perf_counter()\n", "for _ in range(test_repeats):\n", "    func()\n", "end = perf_counter()\n", "elapsed_nested_direct_symbol = end - start\n", "print(f'Elapsed: {elapsed_nested_direct_symbol}')"]}, {"cell_type": "code", "execution_count": 53, "metadata": {}, "outputs": [{"data": {"text/plain": ["Timings(timing_1=5.0, timing_2=14.6, abs_diff=9.56, rel_diff_perc=189.64)"]}, "execution_count": 53, "metadata": {}, "output_type": "execute_result"}], "source": ["compare_timings(elapsed_nested_fully_qualified, elapsed_nested_direct_symbol)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["That was significantly slower! Even in absolute terms this is starting to get sloooow."]}, {"cell_type": "markdown", "metadata": {}, "source": ["So does this mean you should put imports inside functions?\n", "\n", "No, of course not - follow the convention, it makes code far more readable, and of course optimize your code only once you have identified the bottlenecks. \n", "\n", "Does this mean you shouldn't care at all about the performance of your code based on the import variants?\n", "\n", "Again, of course not - you absolutely should.\n", "\n", "But, there is absolutely no reason to re-write your code from \n", "\n", "`import math\n", "math.sqrt(2)`\n", "\n", "to \n", "\n", "`from math import sqrt\n", "sqrt(2)\n", "`\n", "\n", "for **speed** reasons if during the entire lifetime of your application you only call that function `100` times... or `10,000,000` times.\n", "\n", "Really depends on your circumstance - be aware of it, but don't try to optimize code until you know **where** you **need** to optimize!\n", "\n", "*[I've seen people refactor parts of their code for sub-second improvements, when, in fact, the largest bottleneck was that they were opening and closing database connections at every read and write instead of pooling connections or something like that]*"]}, {"cell_type": "markdown", "metadata": {}, "source": ["And\n", "\n", "`from module import *`\n", "\n", "has its uses as we'll see later when we discuss packages.\n", "\n", "It's not evil, just not very safe - again depends on your circumstance."]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Reloading Modules"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Reloading modules is something you may find yourself wanting to do if you modify the code for a module while your program is running."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Although you technically can do so, and I'll show you two ways of doing it, it's not recommended. Let me show you how to do it first, and then the pitfalls with both methods.\n", "\n", "The safest is just to make your code changes, and restart your app.\n", "\n", "Even if you are trying to monkey patch (change at run-time) a code module and you want everyone who uses that module to \"see\" the change, they very well may not, depending on how they are accessing your module."]}, {"cell_type": "markdown", "metadata": {}, "source": ["As usual, working with external modules in Jupyter is not the easiest thing in the world, so I'm just going to create simple modules right from inside the notebook. You can just create files in the same folder as your notebook/main app instead."]}, {"cell_type": "code", "execution_count": 1, "metadata": {}, "outputs": [], "source": ["import os\n", "\n", "def create_module_file(module_name, **kwargs):\n", "    '''Create a module file named <module_name>.py.\n", "    Module has a single function (print_values) that will print\n", "    out the supplied (stringified) kwargs.\n", "    '''\n", "    \n", "    module_file_name = f'{module_name}.py'\n", "    module_rel_file_path = module_file_name\n", "    module_abs_file_path = os.path.abspath(module_rel_file_path)\n", "    \n", "    with open(module_abs_file_path, 'w') as f:\n", "        f.write(f'# {module_name}.py\\n\\n')\n", "        f.write(f\"print('running {module_file_name}...')\\n\\n\")\n", "        f.write(f'def print_values():\\n')\n", "        for key, value in kwargs.items():\n", "            f.write(f\"\\tprint('{str(key)}', '{str(value)}')\\n\")    "]}, {"cell_type": "code", "execution_count": 2, "metadata": {}, "outputs": [], "source": ["create_module_file('test', k1=10, k2='python')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["This should have resulted in the creation of a file named `test.py` in your notebook/project directory that should look like this:\n", "\n", "`# test.py`\n", "\n", "`print('running test.py...')`\n", "\n", "``def print_values():\n", "\tprint('k1', '10')\n", "\tprint('k2', 'python')\n", "``"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now let's go ahead and import it using a plain `import`:"]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["running test.py...\n"]}], "source": ["import test"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"data": {"text/plain": ["<module 'test' from '/Users/fbaptiste/Desktop/Notebooks/test.py'>"]}, "execution_count": 4, "metadata": {}, "output_type": "execute_result"}], "source": ["test"]}, {"cell_type": "markdown", "metadata": {}, "source": ["And we can now call the `print_values` function:"]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["k1 10\n", "k2 python\n"]}], "source": ["test.print_values()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now suppose, we modify the module by adding an extra key:"]}, {"cell_type": "code", "execution_count": 6, "metadata": {"collapsed": true}, "outputs": [], "source": ["create_module_file('test', k1=10, k2='python', k3='cheese')"]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["k1 10\n", "k2 python\n"]}], "source": ["test.print_values()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Nope, nothing changed..."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Maybe we can just re-import it?? You shoudl know the answer to that one..."]}, {"cell_type": "code", "execution_count": 8, "metadata": {"collapsed": true}, "outputs": [], "source": ["import test"]}, {"cell_type": "code", "execution_count": 9, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["k1 10\n", "k2 python\n"]}], "source": ["test.print_values()"]}, {"cell_type": "code", "execution_count": 10, "metadata": {}, "outputs": [{"data": {"text/plain": ["4532635512"]}, "execution_count": 10, "metadata": {}, "output_type": "execute_result"}], "source": ["id(test)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The module object is the same one we initially loaded - our namespace and `sys.modules` still points to that old one. Somehow we have to force Python to *reload* the module."]}, {"cell_type": "markdown", "metadata": {}, "source": ["At this point, I hope you're thinking \"let's just remove it from `sys.modules`, this way Python will not see it in the cache and rerun the import.\n", "\n", "That's a good idea - let's try that."]}, {"cell_type": "code", "execution_count": 11, "metadata": {}, "outputs": [], "source": ["import sys\n", "del sys.modules['test']"]}, {"cell_type": "code", "execution_count": 12, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["running test.py...\n"]}], "source": ["import test"]}, {"cell_type": "code", "execution_count": 13, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["k1 10\n", "k2 python\n", "k3 cheese\n"]}], "source": ["test.print_values()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["and, in fact, the `id` has also changed:"]}, {"cell_type": "code", "execution_count": 14, "metadata": {}, "outputs": [{"data": {"text/plain": ["4532720568"]}, "execution_count": 14, "metadata": {}, "output_type": "execute_result"}], "source": ["id(test)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["That worked!"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But here's the problem with that approach.\n", "\n", "Suppose some other module in your program has already loaded that module using \n", "\n", "`import test`.\n", "\n", "What is in their namespace? A variable (symbol) called `test` that points to which object? The one that was first loaded, not the second one we just put back into the `sys.modules` dict.\n", "\n", "In other words, they have no idea the module changed and they'll just keep using the old object at the original memory address."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Fortunately, `importlib` has a way to reload the contents of the module object without affecting the memory address.\n", "\n", "That is already much better.\n", "\n", "Let's try it:"]}, {"cell_type": "code", "execution_count": 15, "metadata": {}, "outputs": [{"data": {"text/plain": ["4532720568"]}, "execution_count": 15, "metadata": {}, "output_type": "execute_result"}], "source": ["id(test)"]}, {"cell_type": "code", "execution_count": 16, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["k1 10\n", "k2 python\n", "k3 cheese\n"]}], "source": ["test.print_values()"]}, {"cell_type": "code", "execution_count": 17, "metadata": {"collapsed": true}, "outputs": [], "source": ["create_module_file('test', k1=10, k2='python', \n", "                   k3='cheese', k4='parrots')"]}, {"cell_type": "code", "execution_count": 18, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["running test.py...\n"]}, {"data": {"text/plain": ["<module 'test' from '/Users/fbaptiste/Desktop/Notebooks/test.py'>"]}, "execution_count": 18, "metadata": {}, "output_type": "execute_result"}], "source": ["import importlib\n", "\n", "importlib.reload(test)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As we can see the module was executed..."]}, {"cell_type": "markdown", "metadata": {}, "source": ["what about the `id`?"]}, {"cell_type": "code", "execution_count": 19, "metadata": {}, "outputs": [{"data": {"text/plain": ["4532720568"]}, "execution_count": 19, "metadata": {}, "output_type": "execute_result"}], "source": ["id(test)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Stayed the same..."]}, {"cell_type": "markdown", "metadata": {}, "source": ["So now, let's call that function:"]}, {"cell_type": "code", "execution_count": 20, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["k1 10\n", "k2 python\n", "k3 cheese\n", "k4 parrots\n"]}], "source": ["test.print_values()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see, we have the correct output. And we did not have to reimport the module, which means any other module that had imported the old object, now is going to automatically be using the new \"version\" of the same object (same memory address)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["So, all's well that ends well...\n", "\n", "Not quite. :-)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Consider this example instead, were we use a `from` style import:"]}, {"cell_type": "code", "execution_count": 21, "metadata": {"collapsed": true}, "outputs": [], "source": ["create_module_file('test2', k1='python')"]}, {"cell_type": "code", "execution_count": 22, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["running test2.py...\n"]}], "source": ["from test2 import print_values"]}, {"cell_type": "code", "execution_count": 23, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["k1 python\n"]}], "source": ["print_values()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Works great.\n", "\n", "What's the `id` of `print_values`?"]}, {"cell_type": "code", "execution_count": 24, "metadata": {}, "outputs": [{"data": {"text/plain": ["4532625752"]}, "execution_count": 24, "metadata": {}, "output_type": "execute_result"}], "source": ["id(print_values)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now let's modify `test2.py`:"]}, {"cell_type": "code", "execution_count": 25, "metadata": {"collapsed": true}, "outputs": [], "source": ["create_module_file('test2', k1='python', k2='cheese')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["And reload it using `importlib.reload`:"]}, {"cell_type": "code", "execution_count": 26, "metadata": {}, "outputs": [{"ename": "NameError", "evalue": "name 'test2' is not defined", "output_type": "error", "traceback": ["\u001b[0;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[0;31mNameError\u001b[0m                                 Traceback (most recent call last)", "\u001b[0;32m<ipython-input-26-7b4c6fe87427>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m()\u001b[0m\n\u001b[0;32m----> 1\u001b[0;31m \u001b[0mimportlib\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mreload\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mtest2\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m", "\u001b[0;31mNameError\u001b[0m: name 'test2' is not defined"]}], "source": ["importlib.reload(test2)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Ok, so we don't have `test2` in our namespace... Easy enough, let's import it directly (or get it out of `sys.modules`):"]}, {"cell_type": "code", "execution_count": 27, "metadata": {"collapsed": true}, "outputs": [], "source": ["import test2"]}, {"cell_type": "code", "execution_count": 28, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["k1 python\n"]}], "source": ["test2.print_values()"]}, {"cell_type": "code", "execution_count": 29, "metadata": {}, "outputs": [{"data": {"text/plain": ["4532625752"]}, "execution_count": 29, "metadata": {}, "output_type": "execute_result"}], "source": ["id(test2.print_values)"]}, {"cell_type": "code", "execution_count": 30, "metadata": {}, "outputs": [{"data": {"text/plain": ["4532625752"]}, "execution_count": 30, "metadata": {}, "output_type": "execute_result"}], "source": ["id(print_values)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now let's try the reload:"]}, {"cell_type": "code", "execution_count": 31, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["running test2.py...\n"]}, {"data": {"text/plain": ["<module 'test2' from '/Users/fbaptiste/Desktop/Notebooks/test2.py'>"]}, "execution_count": 31, "metadata": {}, "output_type": "execute_result"}], "source": ["importlib.reload(test2)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["OK, the module was re-imported..."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now let's run the `print_values` function:"]}, {"cell_type": "code", "execution_count": 32, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["k1 python\n", "k2 cheese\n"]}], "source": ["test2.print_values()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But remember how we actually imported `print_values` from `test2`?"]}, {"cell_type": "code", "execution_count": 33, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["k1 python\n"]}], "source": ["print_values()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Ouch - that's not right!"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's look at the `id`s of those two functions, and compare them to what we had before we ran the reload:"]}, {"cell_type": "code", "execution_count": 34, "metadata": {}, "outputs": [{"data": {"text/plain": ["4533545976"]}, "execution_count": 34, "metadata": {}, "output_type": "execute_result"}], "source": ["id(test2.print_values)"]}, {"cell_type": "code", "execution_count": 35, "metadata": {}, "outputs": [{"data": {"text/plain": ["4532625752"]}, "execution_count": 35, "metadata": {}, "output_type": "execute_result"}], "source": ["id(print_values)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see the `test2.print_values` function is a new object, but `print_values` **still** points to the old function that exists in the first \"version\" of `test2`."]}, {"cell_type": "markdown", "metadata": {}, "source": ["And that is why reloading is just not safe.\n", "\n", "If someone using your module binds directly to an attribute in your module, either via how they import:\n", "\n", "`from test2 import print_values`\n", "\n", "or even by doing something like this:\n", "\n", "`pv = test2.print_values`\n", "\n", "their binding is now set to a specific memory address.\n", "\n", "When you reload the module, the object `test2` has ben mutated, and the `print_values` function is now a new object, but any bindings to the \"old\" version of the function remain."]}, {"cell_type": "markdown", "metadata": {}, "source": ["So, in general, stay away from reloading modules dynamically."]}, {"cell_type": "markdown", "metadata": {}, "source": ["### What's New in Python 3.6"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Here are just a few highlights.\n", "\n", "For the full monty (python), read it here:\n", "\n", "`https://docs.python.org/3/whatsnew/3.6.html`"]}, {"cell_type": "markdown", "metadata": {}, "source": ["I will create some additional videos looking at each of these in more detail."]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Dictionaries maintain sort order"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Dictionaries will maintain their key order based on when items were inserted. \n", "This is an implementation detail in 3.6 (i.e. the behavior happens because of the new implementation of dicts, but not guaranteed in the sense that a future release could change that). However, there seems to be official confirmation from GvR that starting in 3.7 it will be guaranteed.\n", "If you use `prettyprint` be careful as that sorts the dictionary keys lexicographically before printing and this will still be the case in 3.7 (after much debate over it in the Python dev community!)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Preserving Order of **kwargs in Function Arguments"]}, {"cell_type": "markdown", "metadata": {}, "source": ["This is actually unrelated to the dict key order preservation. \n", "The order in which `**kwarg` arguments are passed to a function is retained when you iterate the `kwarg` parameter inside the called function.\n", "\n", "This is actually a big deal. I'll show you how this allows us to easily create a named tuple factory function with default values for example."]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Underscores in Numeric Literals"]}, {"cell_type": "markdown", "metadata": {}, "source": ["This one is also really nice to help readability. You can now use underscores in numeric literals.\n", "\n", "For example:"]}, {"cell_type": "code", "execution_count": 1, "metadata": {}, "outputs": [{"data": {"text/plain": ["1000000"]}, "execution_count": 1, "metadata": {}, "output_type": "execute_result"}], "source": ["1_000_000"]}, {"cell_type": "code", "execution_count": 2, "metadata": {}, "outputs": [{"data": {"text/plain": ["4294967295"]}, "execution_count": 2, "metadata": {}, "output_type": "execute_result"}], "source": ["0x_FFFF_FFFF"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### f-Strings"]}, {"cell_type": "markdown", "metadata": {}, "source": ["A much simpler string interpolation. You can embed Python expressions directly into strings (including multi-line) as well as the usual string formatting directives just by preceding the string with an `f` or `F`.\n", "\n", "For example:"]}, {"cell_type": "code", "execution_count": 3, "metadata": {"scrolled": true}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["10/3 = 3.333\n"]}], "source": ["numerator = 10\n", "denominator = 3\n", "response = f'{numerator}/{denominator} = {numerator / denominator:0.3f}'\n", "print(response)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Type Annotations"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Basically allows us to provide type information to function arguments, class variables, etc.\n", "\n", "More info in PEP 484 and PEP 526."]}, {"cell_type": "markdown", "metadata": {}, "source": ["According to PEP 484:\n", "\n", "\"It should also be emphasized that **Python will remain a dynamically typed language, and the authors have no desire to ever make type hints mandatory, even by convention**.\""]}, {"cell_type": "markdown", "metadata": {}, "source": ["Tools that make use of these type annotations include `mypy`, `PyCharm`. Probably others too."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Here's an example of type annotations:"]}, {"cell_type": "code", "execution_count": 4, "metadata": {"collapsed": true}, "outputs": [], "source": ["from typing import List"]}, {"cell_type": "code", "execution_count": 5, "metadata": {"collapsed": true}, "outputs": [], "source": ["def squares(l: List[int]) -> List[int]:\n", "    return [e ** 2 for e in l]"]}, {"cell_type": "code", "execution_count": 6, "metadata": {"collapsed": true}, "outputs": [], "source": ["my_list: List[int] = [1, 2, 3, 4]"]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"data": {"text/plain": ["([1, 2, 3, 4], [1, 4, 9, 16])"]}, "execution_count": 7, "metadata": {}, "output_type": "execute_result"}], "source": ["my_list, squares(my_list)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But Python does not use those annotations - here I am passing a dictionary to the function (with integer keys so the function still works properly). Obviously dictionaries are not lists!"]}, {"cell_type": "code", "execution_count": 8, "metadata": {}, "outputs": [{"data": {"text/plain": ["[1, 4, 9, 16]"]}, "execution_count": 8, "metadata": {}, "output_type": "execute_result"}], "source": ["d = {1: 'a', 2: 'b', 3:'c', 4:'d'}\n", "squares(d)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The type annotations **do not affect** Python itself - it is simply a set of syntactic additions that allows **external** tools such as `mypy` or `PyCharm` to perform static type checking."]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Asynchronous Enhancements"]}, {"cell_type": "markdown", "metadata": {}, "source": ["This is beyond the scope of Part 1, but really useful additions worth at least mentioning have been added to the Python language to better support asynchronous programming (I'll cover that in detail in subsequent parts of the course series - most likely Part 4)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Plus a LOT more"]}, {"cell_type": "markdown", "metadata": {}, "source": ["There's a lot more to really love in 3.6, and you can read all about it here:\n", "\n", "`https://docs.python.org/3/whatsnew/3.6.html#whatsnew36-pep526`"]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Python 3.6 - Dictionary Ordering"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Python 3.6 sees a new implementation of the standard `dict` that preserves key ordering (based on the order in which new keys are added into or removed from the dictionary)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Although this is an implementation detail in 3.6, it is supposed to become official in Python 3.7. \n", "\n", "`https://mail.python.org/pipermail/python-dev/2017-December/151283.html`\n", "\n", "So it should be safe to now assume dictionary keys will retain order , and using an `OrderedDict` might no longer be needed for certain cases. I'll come back to `OrderedDict` in a bit...\n", "\n", "**Use for Python 3.6 and higher only!**\n", "\n", "If you use that ordering feature with standard `dict` objects and then try to run your code in a prior version, things will break :-)\n", "\n"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Also means that `keys()` (that iterate from left to right) preserves order as does `values()`. On the other hand `popitem()` will pop right-most element from dictionary. Sounds like stack behavior to me - but does not mean you should use it as such - I'm pretty sure that's not going to be as efficient as say using a list!."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's see some of this (just make sure you're running 3.6 or higher)"]}, {"cell_type": "code", "execution_count": 1, "metadata": {"collapsed": true}, "outputs": [], "source": ["from sys import version_info"]}, {"cell_type": "code", "execution_count": 2, "metadata": {}, "outputs": [{"data": {"text/plain": ["sys.version_info(major=3, minor=6, micro=2, releaselevel='final', serial=0)"]}, "execution_count": 2, "metadata": {}, "output_type": "execute_result"}], "source": ["version_info"]}, {"cell_type": "code", "execution_count": 3, "metadata": {"collapsed": true}, "outputs": [], "source": ["d = {'a': 1, 'b': 2}"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"data": {"text/plain": ["(dict_keys(['a', 'b']), dict_values([1, 2]), dict_items([('a', 1), ('b', 2)]))"]}, "execution_count": 4, "metadata": {}, "output_type": "execute_result"}], "source": ["d.keys(), d.values(), d.items()"]}, {"cell_type": "code", "execution_count": 5, "metadata": {"collapsed": true}, "outputs": [], "source": ["d['x'] = 3"]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [{"data": {"text/plain": ["(dict_keys(['a', 'b', 'x']),\n", " dict_values([1, 2, 3]),\n", " dict_items([('a', 1), ('b', 2), ('x', 3)]))"]}, "execution_count": 6, "metadata": {}, "output_type": "execute_result"}], "source": ["d.keys(), d.values(), d.items()"]}, {"cell_type": "code", "execution_count": 7, "metadata": {"collapsed": true}, "outputs": [], "source": ["del d['b']"]}, {"cell_type": "code", "execution_count": 8, "metadata": {}, "outputs": [{"data": {"text/plain": ["(dict_keys(['a', 'x']), dict_values([1, 3]), dict_items([('a', 1), ('x', 3)]))"]}, "execution_count": 8, "metadata": {}, "output_type": "execute_result"}], "source": ["d.keys(), d.values(), d.items()"]}, {"cell_type": "code", "execution_count": 9, "metadata": {"collapsed": true}, "outputs": [], "source": ["d['b'] = 4"]}, {"cell_type": "code", "execution_count": 10, "metadata": {}, "outputs": [{"data": {"text/plain": ["(dict_keys(['a', 'x', 'b']),\n", " dict_values([1, 3, 4]),\n", " dict_items([('a', 1), ('x', 3), ('b', 4)]))"]}, "execution_count": 10, "metadata": {}, "output_type": "execute_result"}], "source": ["d.keys(), d.values(), d.items()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["What about replacing a value for an existing key?"]}, {"cell_type": "code", "execution_count": 11, "metadata": {"collapsed": true}, "outputs": [], "source": ["d['x'] =100"]}, {"cell_type": "code", "execution_count": 12, "metadata": {}, "outputs": [{"data": {"text/plain": ["(dict_keys(['a', 'x', 'b']),\n", " dict_values([1, 100, 4]),\n", " dict_items([('a', 1), ('x', 100), ('b', 4)]))"]}, "execution_count": 12, "metadata": {}, "output_type": "execute_result"}], "source": ["d.keys(), d.values(), d.items()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Order maintained..."]}, {"cell_type": "markdown", "metadata": {}, "source": ["And if we pop:"]}, {"cell_type": "code", "execution_count": 13, "metadata": {}, "outputs": [{"data": {"text/plain": ["('b', 4)"]}, "execution_count": 13, "metadata": {}, "output_type": "execute_result"}], "source": ["d.popitem()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We popped the last item."]}, {"cell_type": "markdown", "metadata": {}, "source": ["So now I'm left wondering how to pick a *random* item from the dictionary?\n", "(Not that we could before - it might have looked random when we popped an item but it wasn't)\n", "\n", "Sounds like another video :-)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["**Important note:** Be careful of Jupyter notebooks - something I just realized - take a look:"]}, {"cell_type": "code", "execution_count": 14, "metadata": {"collapsed": true}, "outputs": [], "source": ["d = {'x': 1, 'a': 2}"]}, {"cell_type": "code", "execution_count": 15, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["{'x': 1, 'a': 2}\n"]}], "source": ["print(d)"]}, {"cell_type": "code", "execution_count": 16, "metadata": {}, "outputs": [{"data": {"text/plain": ["{'a': 2, 'x': 1}"]}, "execution_count": 16, "metadata": {}, "output_type": "execute_result"}], "source": ["d"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Notice how just letting Jupyter display `d` changed the display order of the keys? (I'm guessing its doing something similar to `prettyprint` (or maybe even using it), which changes the displayed key order to be lexicographical."]}, {"cell_type": "markdown", "metadata": {}, "source": ["What about using `update` to update one dict based on another (inserting missing keys, and updating common ones - but especially the insertion bit) - I'm guessing the order is retained with any insertions appearing at the end and ordered according to the dict being merged in. Let's see:"]}, {"cell_type": "code", "execution_count": 17, "metadata": {"collapsed": true}, "outputs": [], "source": ["d1 = {'a': 1, 'b': 200}\n", "d2 = {'a': 100, 'd':300, 'c':400}"]}, {"cell_type": "code", "execution_count": 18, "metadata": {"collapsed": true}, "outputs": [], "source": ["d1.update(d2)"]}, {"cell_type": "code", "execution_count": 19, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["{'a': 100, 'b': 200, 'd': 300, 'c': 400}\n"]}], "source": ["print(d1)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Back to `OrderedDict` for a second:"]}, {"cell_type": "markdown", "metadata": {}, "source": ["`OrderedDict` has a few methods that afaik have no equivalent (yet) in standard dicts:\n", "* `move_to_end(key, last=True)` - either move to front or back\n", "* `popitem(last=True)` - that can pop either from front or back of dict\n", "* supports reverse iteration using `reversed()`"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's take each one of those one by one:"]}, {"cell_type": "markdown", "metadata": {}, "source": ["**move to end:**"]}, {"cell_type": "code", "execution_count": 20, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["start: {'a': 1, 'b': 2, 'c': 3}\n", "moved a to end: {'b': 2, 'c': 3, 'a': 1}\n"]}], "source": ["d = {'a':1, 'b':2, 'c':3}\n", "print('start:', d)\n", "d['a'] = d.pop('a')\n", "print('moved a to end:',d)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["**move to front:**"]}, {"cell_type": "markdown", "metadata": {}, "source": ["That's one not so easy, the only option I can think of is to move all the keys around to re-order. Maybe something like this:"]}, {"cell_type": "code", "execution_count": 21, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["start: {'a': 1, 'b': 2, 'c': 3, 'x': 100, 'y': 200}\n", "moved c to end: {'a': 1, 'b': 2, 'x': 100, 'y': 200, 'c': 3}\n", "moved c to front: {'c': 3, 'a': 1, 'b': 2, 'x': 100, 'y': 200}\n"]}], "source": ["d = {'a':1, 'b':2, 'c':3, 'x':100, 'y':200}\n", "print('start:', d)\n", "d['c'] = d.pop('c')\n", "print('moved c to end:', d)\n", "\n", "for i in range(len(d)-1):\n", "    key = next(iter(d.keys()))\n", "    d[key] = d.pop(key)\n", "print('moved c to front:', d)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["**pop last item:**"]}, {"cell_type": "markdown", "metadata": {}, "source": ["That one's trivial - just use `popitem`:"]}, {"cell_type": "code", "execution_count": 22, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["start: {'a': 1, 'b': 2, 'c': 3, 'x': 100, 'y': 200}\n", "pop last item: {'a': 1, 'b': 2, 'c': 3, 'x': 100}\n"]}], "source": ["d = {'a':1, 'b':2, 'c':3, 'x':100, 'y':200}\n", "print('start:', d)\n", "d.popitem()\n", "print('pop last item:', d)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["**pop first item:**"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Not too difficult - we just need to identify the *first* key, and pop it."]}, {"cell_type": "code", "execution_count": 23, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["start: {'a': 1, 'b': 2, 'c': 3, 'x': 100, 'y': 200}\n", "pop first item: {'b': 2, 'c': 3, 'x': 100, 'y': 200}\n"]}], "source": ["d = {'a':1, 'b':2, 'c':3, 'x':100, 'y':200}\n", "print('start:', d)\n", "key = next(iter(d.keys()))\n", "d.pop(key)\n", "print('pop first item:', d)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["If you're interested, here's Raymond Hettinger's pure Python \"version\" of his C dict implementation:\n", "`http://code.activestate.com/recipes/578375/`"]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Python 3.6: Preserved Order of **kwargs"]}, {"cell_type": "markdown", "metadata": {}, "source": ["PEP468 was accepted into 3.6, and this means that the order in which keyword arguments are collected into `**kwargs` is now maintained.\n", "\n", "Why does that matter you ask?\n", "\n", "Well, how about a function that takes in kwargs and needs to build an ordered type based on the *order* of the kwargs. In the past you would have had to use some workaround (often using an ordered dict) instead of the far more convenient `**kwargs` approach."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let me show you what I mean:"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Suppose we want to write a `namedtuple` factory of our own where we can specify default values:\n", "    "]}, {"cell_type": "code", "execution_count": 52, "metadata": {"collapsed": true}, "outputs": [], "source": ["from collections import namedtuple\n", "\n", "def defaulted_namedtuple(class_name, **fields):\n", "    Struct = namedtuple(class_name, fields.keys())\n", "    Struct.__new__.__defaults__ = tuple(fields.values())\n", "    return Struct    "]}, {"cell_type": "code", "execution_count": 53, "metadata": {"collapsed": true}, "outputs": [], "source": ["Vector2D = defaulted_namedtuple('Vector2D', \n", "                                x1=None, y1=None,\n", "                                x2=None, y2=None,\n", "                                origin_x=0, origin_y=0)"]}, {"cell_type": "code", "execution_count": 54, "metadata": {}, "outputs": [{"data": {"text/plain": ["('x1', 'y1', 'x2', 'y2', 'origin_x', 'origin_y')"]}, "execution_count": 54, "metadata": {}, "output_type": "execute_result"}], "source": ["Vector2D._fields"]}, {"cell_type": "code", "execution_count": 55, "metadata": {"collapsed": true}, "outputs": [], "source": ["v1 = Vector2D(10, 10, 20, 20)"]}, {"cell_type": "code", "execution_count": 56, "metadata": {}, "outputs": [{"data": {"text/plain": ["Vector2D(x1=10, y1=10, x2=20, y2=20, origin_x=0, origin_y=0)"]}, "execution_count": 56, "metadata": {}, "output_type": "execute_result"}], "source": ["v1"]}, {"cell_type": "markdown", "metadata": {}, "source": ["This only works if the order of the keyword arguments passed to the function is retained in the `fields` dictionary!"]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Python 3.6 - Underscores in Numeric Literals"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can now intersperse underscores (`_`) in numeric literals."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Makes things easier to read:\n", "\n", "`10_000_000` vs `10000000`"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Works for floats as well:"]}, {"cell_type": "code", "execution_count": 1, "metadata": {}, "outputs": [{"data": {"text/plain": ["30000.05"]}, "execution_count": 1, "metadata": {}, "output_type": "execute_result"}], "source": ["30_000.05"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But don't lead or end with the underscore!"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Works for hex numbers too:"]}, {"cell_type": "code", "execution_count": 2, "metadata": {}, "outputs": [{"data": {"text/plain": ["(16777215, 16777215)"]}, "execution_count": 2, "metadata": {}, "output_type": "execute_result"}], "source": ["0x_FF_FFFF, 0x_F_F_F_F_F_F"]}, {"cell_type": "markdown", "metadata": {}, "source": ["(Just to show it does not matter how many digits are between the underscores)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["By the way, string formatting now supports that too - thousand separators for decimal integers and floats and every 4 digits for binary(`b`), octal(`o`), and hex(`x`, `X`)."]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [{"data": {"text/plain": ["'10_000'"]}, "execution_count": 3, "metadata": {}, "output_type": "execute_result"}], "source": ["'{:_}'.format(10000)"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"data": {"text/plain": ["'FF_FFFF'"]}, "execution_count": 4, "metadata": {}, "output_type": "execute_result"}], "source": ["'{:_X}'.format(16777215)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Works in string conversions too:"]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"data": {"text/plain": ["65535"]}, "execution_count": 5, "metadata": {}, "output_type": "execute_result"}], "source": ["int('FF_FF', 16)"]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [{"data": {"text/plain": ["256"]}, "execution_count": 6, "metadata": {}, "output_type": "execute_result"}], "source": ["int('0b_1_0000_0000', 2)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Pretty cool!"]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Python 3.6 - f-Strings"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Last highlight I want to mention are the new f-strings. For more details see PEP498.\n", "\n", "f-Strings is short for *formatted string literals*"]}, {"cell_type": "markdown", "metadata": {}, "source": ["You should already know how to format strings using the `format` method:"]}, {"cell_type": "code", "execution_count": 1, "metadata": {}, "outputs": [{"data": {"text/plain": ["'10 % 3 = 1'"]}, "execution_count": 1, "metadata": {}, "output_type": "execute_result"}], "source": ["# Using {}\n", "'{} % {} = {}'.format(10, 3, 10 % 3)"]}, {"cell_type": "code", "execution_count": 2, "metadata": {}, "outputs": [{"data": {"text/plain": ["'10 % 3 = 1'"]}, "execution_count": 2, "metadata": {}, "output_type": "execute_result"}], "source": ["# Using {number}\n", "'{1} % {2} = {0}'.format(10 % 3, 10, 3)"]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [{"data": {"text/plain": ["'10 % 3 = 1'"]}, "execution_count": 3, "metadata": {}, "output_type": "execute_result"}], "source": ["# Using {name}\n", "'{a} % {b} = {mod}'.format(a=10, b=3, mod=10 % 3)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But now we can also do this:"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"data": {"text/plain": ["'10 % 3 = 1'"]}, "execution_count": 4, "metadata": {}, "output_type": "execute_result"}], "source": ["a = 10\n", "b = 3\n", "f'{a} % {b} = {a % b}'"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Basically in f-strings you can use expressions and reference variables inside your string which Python will then interpolate. Also uses all the existing string formatting options (`:0.5f` for example):"]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"data": {"text/plain": ["'3.33333'"]}, "execution_count": 5, "metadata": {}, "output_type": "execute_result"}], "source": ["a = 10 / 3\n", "\n", "f'{a:0.5f}'"]}, {"cell_type": "markdown", "metadata": {}, "source": ["So now, instead of writing:"]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [{"data": {"text/plain": ["'Python rocks'"]}, "execution_count": 6, "metadata": {}, "output_type": "execute_result"}], "source": ["name = 'Python'\n", "'{name} rocks'.format(name=name)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["which used the word `name` **three** times, we can simply say:"]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"data": {"text/plain": ["'Python rocks!'"]}, "execution_count": 7, "metadata": {}, "output_type": "execute_result"}], "source": ["name = 'Python'\n", "f'{name} rocks!'"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Much more concise!"]}, {"cell_type": "markdown", "metadata": {}, "source": ["How about with closures?"]}, {"cell_type": "code", "execution_count": 8, "metadata": {"collapsed": true}, "outputs": [], "source": ["def outer():\n", "    name = 'Python'\n", "    \n", "    def inner():\n", "        return f'{name} rocks!'\n", "    \n", "    return inner"]}, {"cell_type": "code", "execution_count": 9, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Python rocks!\n"]}], "source": ["print(outer()())"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Woohoo!! That works too - note that we did not have to reference `name` (to make it a free variable in `inner`) before using it **inside** the f-string."]}, {"cell_type": "markdown", "metadata": {}, "source": ["I can see this open to abuse though..."]}, {"cell_type": "code", "execution_count": 10, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["10\n", "100\n"]}], "source": ["sq = lambda x: x**2\n", "a = 10\n", "b=1\n", "print(f'{sq(a) if b > 5 else a}')\n", "\n", "b=10\n", "print(f'{sq(a) if b > 5 else a}')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Or even this:"]}, {"cell_type": "code", "execution_count": 11, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["10\n", "100\n"]}], "source": ["a = 10\n", "b = 1\n", "print(f'{(lambda x: x**2)(a) if b > 5 else a}')\n", "\n", "b=10\n", "print(f'{(lambda x: x**2)(a) if b > 5 else a}')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Lord help us... :-)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Random Seeds"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The `random` module provides a variety of functions related to (pseudo) random numbers.\n", "\n", "The problem when you use random numbers in your code is that it can be difficult to debug because the same random number sequence is not the same from run to run of your program. If your code fails somewhere in the middle of a run it is difficult to make the problem **repeatable**. Debugging intermittent and non-repeatable failures is one of the worst things to do!\n", "\n", "Fortunately, when using the `random` module, we can set the `seed` for the random underlying random number generator.\n", "\n", "Random numbers are not truly random - they are generated in such a way that the numbers *appear* random and evenly distributed, but in fact they are being generated using a specific algorithm.\n", "\n", "That algorithm depends on a **seed** value. That seed value will determine the exact sequence of randomly generated numbers (so as you can see, it's not truly random). Setting different seeds will result in different random sequences, but setting the seed to the same value will result in the same sequence being generated.\n", "\n", "By default, the seed uses the system time, hence every time you run your program a different seed is set. But we can easily set the seed to something specific - very useful for debugging purposes."]}, {"cell_type": "code", "execution_count": 4, "metadata": {"collapsed": true}, "outputs": [], "source": ["import random"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["15 0.2744539473546337\n", "13 0.8696250242406662\n", "14 0.3697144258854075\n", "18 0.5945778682818538\n", "15 0.7694636962835182\n", "17 0.820862450549917\n", "10 0.6467347679589829\n", "20 0.8048988506681894\n", "12 0.5880472380199475\n", "20 0.8715275342775027\n"]}], "source": ["for _ in range(10):\n", "    print(random.randint(10, 20), random.random())"]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["14 0.931305656287958\n", "10 0.23039405306234007\n", "12 0.8337388005835649\n", "18 0.4590462920405187\n", "10 0.36743475564890316\n", "13 0.7100875772566404\n", "12 0.9750441656612154\n", "12 0.7442020027100001\n", "18 0.23667309950795434\n", "20 0.41553858798609267\n"]}], "source": ["for _ in range(10):\n", "    print(random.randint(10, 20), random.random())"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see the sequence of numbers is not the same (and even restarting the kernel will result in different numbers)."]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can set the **seed** as follows:"]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["16 0.7579544029403025\n", "16 0.04048437818077755\n", "18 0.48592769656281265\n", "14 0.9677999949201714\n", "15 0.5833820394550312\n", "13 0.5046868558173903\n", "14 0.1397457849666789\n", "11 0.6183689966753316\n", "14 0.9872592010330129\n", "18 0.9827854760376531\n"]}], "source": ["random.seed(0)\n", "for i in range(10):\n", "    print(random.randint(10, 20), random.random())"]}, {"cell_type": "markdown", "metadata": {}, "source": ["If we run this code again, the sequence will still be different:"]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["19 0.9021659504395827\n", "14 0.09876334465914771\n", "11 0.8988382879679935\n", "20 0.33019721859799855\n", "18 0.1007012080683658\n", "16 0.31619669952159346\n", "20 0.9130110532378982\n", "18 0.47700977655271704\n", "18 0.2604923103919594\n", "18 0.9159944803568847\n"]}], "source": ["for i in range(10):\n", "    print(random.randint(10, 20), random.random())"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Instead what we have to do is reset the seed (which happens if you set the seed to a specific number at the start of running your program - then evey random number generated will be repeatable from run to run).\n", "\n", "Here, we just need to reset the seed before running that loop to get the same effect:"]}, {"cell_type": "code", "execution_count": 8, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["16 0.7579544029403025\n", "16 0.04048437818077755\n", "18 0.48592769656281265\n", "14 0.9677999949201714\n", "15 0.5833820394550312\n", "13 0.5046868558173903\n", "14 0.1397457849666789\n", "11 0.6183689966753316\n", "14 0.9872592010330129\n", "18 0.9827854760376531\n", "19 0.9021659504395827\n", "14 0.09876334465914771\n", "11 0.8988382879679935\n", "20 0.33019721859799855\n", "18 0.1007012080683658\n", "16 0.31619669952159346\n", "20 0.9130110532378982\n", "18 0.47700977655271704\n", "18 0.2604923103919594\n", "18 0.9159944803568847\n"]}], "source": ["random.seed(0)\n", "for i in range(20):\n", "    print(random.randint(10, 20), random.random())"]}, {"cell_type": "code", "execution_count": 9, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["16 0.7579544029403025\n", "16 0.04048437818077755\n", "18 0.48592769656281265\n", "14 0.9677999949201714\n", "15 0.5833820394550312\n", "13 0.5046868558173903\n", "14 0.1397457849666789\n", "11 0.6183689966753316\n", "14 0.9872592010330129\n", "18 0.9827854760376531\n", "19 0.9021659504395827\n", "14 0.09876334465914771\n", "11 0.8988382879679935\n", "20 0.33019721859799855\n", "18 0.1007012080683658\n", "16 0.31619669952159346\n", "20 0.9130110532378982\n", "18 0.47700977655271704\n", "18 0.2604923103919594\n", "18 0.9159944803568847\n"]}], "source": ["random.seed(0)\n", "for i in range(20):\n", "    print(random.randint(10, 20), random.random())"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see, the sequence of random numbers generated is now the same every time."]}, {"cell_type": "markdown", "metadata": {}, "source": ["What's interesting is that even functions like `shuffle` will shuffle in the same order!\n", "\n", "Let's see this:"]}, {"cell_type": "code", "execution_count": 10, "metadata": {"collapsed": true}, "outputs": [], "source": ["def generate_random_stuff(seed=None):\n", "    random.seed(seed)\n", "    results = []\n", "    \n", "    # randint will generate the same sequence (for same seed)\n", "    for _ in range(5):\n", "        results.append(random.randint(0, 5))\n", "    \n", "    # even shuffling generates in the same way (for same seed)\n", "    characters = ['a', 'b', 'c']\n", "    random.shuffle(characters)\n", "    results.append(characters)\n", "    \n", "    # same with the Gaussian distribution\n", "    for _ in range(5):\n", "        results.append(random.gauss(0, 1))\n", "        \n", "    return results"]}, {"cell_type": "code", "execution_count": 11, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["[4, 3, 2, 0, 5, ['b', 'c', 'a'], 0.2753548343351636, -0.5989933403172317, -0.6515943978936821, 1.7412073870280294, 0.24161779723044724]\n"]}], "source": ["print(generate_random_stuff())"]}, {"cell_type": "code", "execution_count": 12, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["[3, 5, 1, 5, 3, ['c', 'a', 'b'], -0.6334510789171736, -0.3564859849845763, 0.46562328656890606, -2.1891281426767746, -1.1983958517185107]\n"]}], "source": ["print(generate_random_stuff())"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now let's use a seed value:"]}, {"cell_type": "code", "execution_count": 13, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["[3, 3, 0, 2, 4, ['a', 'c', 'b'], 1.6391095109274887, -0.9249345372119703, 0.9223306019157185, -0.1891931090669293, 0.5456115709634167]\n"]}], "source": ["print(generate_random_stuff(0))"]}, {"cell_type": "code", "execution_count": 14, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["[3, 3, 0, 2, 4, ['a', 'c', 'b'], 1.6391095109274887, -0.9249345372119703, 0.9223306019157185, -0.1891931090669293, 0.5456115709634167]\n"]}], "source": ["print(generate_random_stuff(0))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As long as we use the same seed value the results are repeatable. But if we set different seed values the sequences will be different (but still be the same for the same seed):"]}, {"cell_type": "code", "execution_count": 15, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["[1, 3, 3, 1, 5, ['a', 'c', 'b'], -1.639893943131093, 0.7278930291928233, -0.4000719319137612, -0.08390378703116254, -0.3013546798244102]\n"]}], "source": ["print(generate_random_stuff(100))"]}, {"cell_type": "code", "execution_count": 16, "metadata": {"scrolled": true}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["[1, 3, 3, 1, 5, ['a', 'c', 'b'], -1.639893943131093, 0.7278930291928233, -0.4000719319137612, -0.08390378703116254, -0.3013546798244102]\n"]}], "source": ["print(generate_random_stuff(100))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Lastly let's see how we would calculate the frequency of randomly generated integers, just to see how even the distribution is.\n", "\n", "Basically, given a sequence of random integers, we are going to create a dictionary that contains the integers as keys, and the values will the frequency of each:"]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [], "source": ["def freq_analysis(lst):\n", "    return {k: lst.count(k) for k in set(lst)}"]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [], "source": ["lst = [random.randint(0, 10) for _ in range(100)]"]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["[7, 8, 6, 1, 6, 1, 2, 6, 7, 9, 1, 5, 4, 6, 1, 9, 4, 10, 5, 5, 4, 0, 8, 3, 1, 7, 7, 3, 6, 1, 8, 0, 5, 7, 3, 5, 0, 7, 6, 1, 4, 9, 3, 6, 9, 4, 3, 2, 5, 0, 1, 6, 5, 7, 9, 1, 0, 5, 6, 2, 10, 2, 4, 0, 2, 1, 8, 9, 7, 3, 5, 7, 2, 10, 4, 8, 1, 10, 4, 10, 6, 10, 0, 5, 8, 8, 10, 7, 4, 8, 10, 3, 9, 8, 3, 9, 3, 5, 8, 8]\n"]}], "source": ["print(lst)"]}, {"cell_type": "code", "execution_count": 11, "metadata": {}, "outputs": [{"data": {"text/plain": ["{0: 7, 1: 11, 2: 6, 3: 9, 4: 9, 5: 11, 6: 10, 7: 10, 8: 11, 9: 8, 10: 8}"]}, "execution_count": 11, "metadata": {}, "output_type": "execute_result"}], "source": ["random.seed(0)\n", "freq_analysis(lst)"]}, {"cell_type": "code", "execution_count": 14, "metadata": {}, "outputs": [{"data": {"text/plain": ["{0: 90935,\n", " 1: 91184,\n", " 2: 91002,\n", " 3: 91042,\n", " 4: 90766,\n", " 5: 91072,\n", " 6: 90678,\n", " 7: 90985,\n", " 8: 90409,\n", " 9: 91383,\n", " 10: 90544}"]}, "execution_count": 14, "metadata": {}, "output_type": "execute_result"}], "source": ["random.seed(0)\n", "freq_analysis([random.randint(0, 10) for _ in range(1_000_000)])"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Of course, it usually pays to know what's in the standard library :-)\n", "\n", "The collections library has a Counter class that can be used to do this precise thing!"]}, {"cell_type": "code", "execution_count": 17, "metadata": {}, "outputs": [], "source": ["from collections import Counter"]}, {"cell_type": "code", "execution_count": 21, "metadata": {}, "outputs": [{"data": {"text/plain": ["Counter({0: 90935,\n", "         1: 91184,\n", "         2: 91002,\n", "         3: 91042,\n", "         4: 90766,\n", "         5: 91072,\n", "         6: 90678,\n", "         7: 90985,\n", "         8: 90409,\n", "         9: 91383,\n", "         10: 90544})"]}, "execution_count": 21, "metadata": {}, "output_type": "execute_result"}], "source": ["random.seed(0)\n", "Counter([random.randint(0, 10) for _ in range(1_000_000)])"]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": []}, {"cell_type": "markdown", "metadata": {}, "source": ["### Random Choices"]}, {"cell_type": "markdown", "metadata": {}, "source": ["How would you pick a random element from a list?\n", "\n", "You might be tempted to use the `random` library to pick a random index (integer) and use that random index to retrieve the element from the list (or more genrally sequence).\n", "\n", "Something like this:"]}, {"cell_type": "code", "execution_count": 1, "metadata": {}, "outputs": [], "source": ["import random"]}, {"cell_type": "markdown", "metadata": {}, "source": ["I'm going to set a seed so we always generate the same random sequences:"]}, {"cell_type": "code", "execution_count": 2, "metadata": {}, "outputs": [], "source": ["random.seed(0)"]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [], "source": ["l = [10, 20, 30, 40, 50, 60]"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [], "source": ["random_index = random.randrange(len(l))"]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"data": {"text/plain": ["40"]}, "execution_count": 5, "metadata": {}, "output_type": "execute_result"}], "source": ["l[random_index]"]}, {"cell_type": "markdown", "metadata": {}, "source": ["So to do this 10 times we would write:"]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["40\n", "40\n", "10\n", "30\n", "50\n", "40\n", "40\n", "30\n", "40\n", "30\n"]}], "source": ["random.seed(0)\n", "for i in range(10):\n", "    print(l[random.randrange(len(l))])"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Although this certainly works, it's not very Pythonic. Instead we can use the `choice` function in the `random` module that picks a random element from any given sequence. (Again I'm going to set a seed so we can generate the same random sequence)."]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["40\n", "40\n", "10\n", "30\n", "50\n", "40\n", "40\n", "30\n", "40\n", "30\n"]}], "source": ["random.seed(0)\n", "for _ in range(10):\n", "    print(random.choice(l))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Wasn't that much cleaner code?\n", "\n", "But still, there has to be a better way to generate 10 random choices without resorting to a \"common\" loop :-)"]}, {"cell_type": "markdown", "metadata": {"collapsed": true}, "source": ["The `random` module also has a `choices` method which allows us to choose multiple random choices (as opposed to `choice` which only picks one)."]}, {"cell_type": "markdown", "metadata": {}, "source": ["The thing is, `choices` has a few more advanced features built in.\n", "\n", "Let's start with the basics."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Suppose I want to choose n elements randomly from some sequence:"]}, {"cell_type": "code", "execution_count": 8, "metadata": {}, "outputs": [], "source": ["list_1 = list(range(1000))"]}, {"cell_type": "code", "execution_count": 9, "metadata": {}, "outputs": [{"data": {"text/plain": ["[583, 908, 504, 281, 755]"]}, "execution_count": 9, "metadata": {}, "output_type": "execute_result"}], "source": ["random.choices(list_1, k=5)"]}, {"cell_type": "code", "execution_count": 10, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["[618, 250, 909]\n", "[982, 810, 902]\n", "[310, 729, 898]\n", "[683, 472, 100]\n", "[434, 610, 913]\n"]}], "source": ["for _ in range(5):\n", "    print(random.choices(list_1, k=3))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now the thing about `choices` is that it does the selection *with replacement*. This means that the same item could show up more than once in the same call to `choices`. To see this, let's use a shorter list:"]}, {"cell_type": "code", "execution_count": 11, "metadata": {}, "outputs": [], "source": ["list_2 = ['a', 'b', 'c']"]}, {"cell_type": "code", "execution_count": 12, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["['c', 'c']\n", "['b', 'a']\n", "['b', 'b']\n", "['c', 'a']\n", "['b', 'b']\n", "['c', 'b']\n", "['a', 'c']\n", "['b', 'a']\n", "['c', 'c']\n", "['c', 'c']\n"]}], "source": ["random.seed(0)\n", "for _ in range(10):\n", "    print(random.choices(list_2, k=2))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see we have some results that contain the same element twice.\n", "\n", "What this means, is that we can make the sample size *larger* than the population:"]}, {"cell_type": "code", "execution_count": 13, "metadata": {}, "outputs": [{"data": {"text/plain": ["['a', 'b', 'c']"]}, "execution_count": 13, "metadata": {}, "output_type": "execute_result"}], "source": ["list_2"]}, {"cell_type": "code", "execution_count": 14, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["['a', 'c', 'c', 'c', 'b']\n", "['a', 'b', 'b', 'c', 'c']\n", "['b', 'c', 'a', 'c', 'b']\n", "['a', 'c', 'b', 'c', 'c']\n", "['a', 'b', 'c', 'a', 'a']\n", "['c', 'a', 'b', 'a', 'c']\n", "['c', 'b', 'a', 'a', 'b']\n", "['c', 'a', 'b', 'c', 'b']\n", "['c', 'b', 'c', 'b', 'b']\n", "['b', 'b', 'b', 'b', 'a']\n"]}], "source": ["for _ in range(10):\n", "    print(random.choices(list_2, k=5))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["In addition, we can also specify a weight for each item in the population. This essentially allows us to have certain items be picked more often than others. The weight list must be the same length as the population."]}, {"cell_type": "code", "execution_count": 15, "metadata": {}, "outputs": [], "source": ["weights_2 = [10, 1, 1]"]}, {"cell_type": "code", "execution_count": 16, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["['a', 'a', 'a', 'a', 'a']\n", "['a', 'a', 'b', 'c', 'b']\n", "['b', 'c', 'a', 'a', 'a']\n", "['a', 'a', 'b', 'b', 'a']\n", "['c', 'a', 'a', 'a', 'c']\n", "['c', 'a', 'a', 'a', 'a']\n", "['a', 'b', 'a', 'a', 'a']\n", "['a', 'a', 'a', 'a', 'a']\n", "['a', 'a', 'a', 'a', 'b']\n", "['a', 'a', 'a', 'a', 'a']\n"]}], "source": ["for _ in range(10):\n", "    print(random.choices(list_2, k=5, weights=weights_2))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see, we see a whole lot more of `a` than the other characters."]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can skew the results even more, simply by increasing the weight for `a`:"]}, {"cell_type": "code", "execution_count": 17, "metadata": {}, "outputs": [], "source": ["weights_2 = [100, 1, 1]"]}, {"cell_type": "code", "execution_count": 18, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["['a', 'a', 'a', 'b', 'a']\n", "['a', 'a', 'a', 'a', 'a']\n", "['a', 'a', 'a', 'a', 'a']\n", "['a', 'a', 'a', 'a', 'a']\n", "['a', 'a', 'a', 'b', 'a']\n", "['a', 'a', 'a', 'a', 'a']\n", "['a', 'a', 'a', 'a', 'a']\n", "['a', 'a', 'a', 'a', 'a']\n", "['a', 'a', 'a', 'a', 'a']\n", "['a', 'a', 'a', 'a', 'a']\n"]}], "source": ["for _ in range(10):\n", "    print(random.choices(list_2, k=5, weights=weights_2))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's see if we can count the frequency of each element that is returned by `choices`.\n", "\n", "To do that we are going to use a comprehension. While we're at it we'll calculate also the relative frequency of each item."]}, {"cell_type": "code", "execution_count": 19, "metadata": {}, "outputs": [], "source": ["from collections import namedtuple\n", "\n", "Freq = namedtuple('Freq', 'count freq')\n", "\n", "def freq_counts(list_):\n", "    total = len(list_)\n", "    return {k: Freq(list_.count(k), 100 * list_.count(k)/total) for k in set(list_)}"]}, {"cell_type": "code", "execution_count": 20, "metadata": {}, "outputs": [{"data": {"text/plain": ["{'c': Freq(count=335, freq=33.5),\n", " 'b': Freq(count=334, freq=33.4),\n", " 'a': Freq(count=331, freq=33.1)}"]}, "execution_count": 20, "metadata": {}, "output_type": "execute_result"}], "source": ["freq_counts(random.choices(list_2, k=1000))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see, the distribution is pretty even. Now let's skew thing a little:"]}, {"cell_type": "code", "execution_count": 21, "metadata": {}, "outputs": [{"data": {"text/plain": ["{'c': Freq(count=104, freq=10.4),\n", " 'b': Freq(count=86, freq=8.6),\n", " 'a': Freq(count=810, freq=81.0)}"]}, "execution_count": 21, "metadata": {}, "output_type": "execute_result"}], "source": ["random.seed(0)\n", "freq_counts(random.choices(list_2, k=1_000, weights=(8, 1, 1)))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["And the relative frequency of `a` is:"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Which matches what we would expect since we gave `a` a weight of `8` out of a total sum of weights of `10` - so 80%."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Of course, the more elements we pick, the closer this value should get to the theoretical:"]}, {"cell_type": "code", "execution_count": 22, "metadata": {}, "outputs": [{"data": {"text/plain": ["{'c': Freq(count=942, freq=9.42),\n", " 'b': Freq(count=1062, freq=10.62),\n", " 'a': Freq(count=7996, freq=79.96)}"]}, "execution_count": 22, "metadata": {}, "output_type": "execute_result"}], "source": ["freq_counts(random.choices(list_2, k=10_000, weights=(8, 1, 1)))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["You can also specify the weights as cumulative weights:\n", "\n", "So instead of `8, 1, 1` as weights, we could provide cumulative weights as `8, 9, 10`:"]}, {"cell_type": "code", "execution_count": 23, "metadata": {}, "outputs": [{"data": {"text/plain": ["{'c': Freq(count=104, freq=10.4),\n", " 'b': Freq(count=86, freq=8.6),\n", " 'a': Freq(count=810, freq=81.0)}"]}, "execution_count": 23, "metadata": {}, "output_type": "execute_result"}], "source": ["random.seed(0)\n", "freq_counts(random.choices(list_2, k=1_000, cum_weights = (8, 9, 10)))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["And we get the same thing."]}, {"cell_type": "markdown", "metadata": {}, "source": ["As a bonus, how would we go about generating 50 evenly distributed random numbers between 0 and 100 (inclusive) say?"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We could certainly use the `randint` function and put that into a loop 50 times:"]}, {"cell_type": "code", "execution_count": 24, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["[85, 84, 99, 32, 95, 78, 24, 8, 70, 54, 35, 22, 67, 21, 8, 84, 81, 20, 74, 14, 64, 80, 69, 77, 49, 96, 55, 34, 39, 36, 1, 54, 99, 91, 35, 33, 68, 67, 70, 40, 43, 24, 90, 100, 55, 18, 0, 96, 65, 19]\n"]}], "source": ["l = []\n", "for _ in range(50):\n", "    l.append(random.randrange(101))\n", "print(l)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But we could just use the `choices` method instead with a range(101):"]}, {"cell_type": "code", "execution_count": 25, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["[79, 70, 78, 38, 46, 3, 92, 64, 80, 76, 90, 36, 99, 16, 19, 35, 70, 1, 74, 57, 24, 18, 76, 42, 57, 23, 72, 87, 90, 81, 10, 19, 44, 6, 43, 39, 27, 44, 76, 35, 33, 31, 49, 77, 20, 40, 43, 64, 67, 70]\n"]}], "source": ["l = random.choices(range(101), k=50)\n", "print(l)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Only caution here is if you are generating random things on multiple threads - in which case you don't know when what thread is going to run and in that case you very well may end up with different random results from the various threads from run to run - even if you use a specific seed."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Here's one practical application of being able to skew random selections.\n", "\n", "Let's say you want to know what's more efficient - guarding a divide by zero exception using a LBYL (look before you leap) approach, or EAFP (easier to ask for forgiveness than permission):"]}, {"cell_type": "code", "execution_count": 26, "metadata": {}, "outputs": [], "source": ["from time import perf_counter"]}, {"cell_type": "code", "execution_count": 27, "metadata": {}, "outputs": [], "source": ["denominators = random.choices([0, 1], k=1_000_000)"]}, {"cell_type": "code", "execution_count": 28, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Avg elapsed time: 1.5108646599946952e-07\n"]}], "source": ["start = perf_counter()\n", "for denominator in denominators:\n", "    if denominator == 0:\n", "        continue\n", "    else:\n", "        10 / denominator\n", "end = perf_counter()\n", "print(f'Avg elapsed time: {(end-start)/len(denominators)}')   "]}, {"cell_type": "code", "execution_count": 29, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Avg elapsed time: 3.9199999800075604e-07\n"]}], "source": ["start = perf_counter()\n", "for denominator in denominators:\n", "    try:\n", "        10 / denominator\n", "    except ZeroDivisionError:\n", "        continue\n", "\n", "end = perf_counter()\n", "print(f'Avg elapsed time: {(end-start)/len(denominators)}')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As we can see it looks like the `try... except...` appeoach is slower.\n", "\n", "But in reality, we expect that a zero will only occur 10% of the time.\n", "\n", "So now we can test this using a skewed set of random denominators:"]}, {"cell_type": "code", "execution_count": 30, "metadata": {}, "outputs": [], "source": ["denominators = random.choices([0, 1], k=1_000_000, weights=[1, 9])"]}, {"cell_type": "code", "execution_count": 31, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Avg elapsed time: 1.9064371899912659e-07\n"]}], "source": ["start = perf_counter()\n", "for denominator in denominators:\n", "    if denominator == 0:\n", "        continue\n", "    else:\n", "        10 / denominator\n", "end = perf_counter()\n", "print(f'Avg elapsed time: {(end-start)/len(denominators)}')"]}, {"cell_type": "code", "execution_count": 32, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Avg elapsed time: 1.7348390699953599e-07\n"]}], "source": ["start = perf_counter()\n", "for denominator in denominators:\n", "    try:\n", "        10 / denominator\n", "    except ZeroDivisionError:\n", "        continue\n", "        \n", "end = perf_counter()\n", "print(f'Avg elapsed time: {(end-start)/len(denominators)}')"]}, {"cell_type": "code", "execution_count": null, "metadata": {}, "outputs": [], "source": []}, {"cell_type": "markdown", "metadata": {}, "source": ["### Random Samples"]}, {"cell_type": "markdown", "metadata": {}, "source": ["I just want to show you a variant on `random.choices` that we saw in the previous video."]}, {"cell_type": "markdown", "metadata": {}, "source": ["`choices` chooses `k` random elements from some sequence, **with replacement**.\n", "\n", "This means we could create a random selection containing more elements than we started off with:"]}, {"cell_type": "code", "execution_count": 8, "metadata": {"collapsed": true}, "outputs": [], "source": ["import random"]}, {"cell_type": "code", "execution_count": 9, "metadata": {}, "outputs": [{"data": {"text/plain": ["['c', 'c', 'a', 'c', 'c', 'b', 'b', 'b', 'b', 'c']"]}, "execution_count": 9, "metadata": {}, "output_type": "execute_result"}], "source": ["random.choices(list('abc'), k=10)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Sometimes however, we do not want that replacement - instead we want a population sample (so once an element has been randomly selected, it cannot be selected again).\n", "\n", "This is where the `sample` function comes in - it does exactly that. Of course, we can no longer pick more elements than we have in our population. Also, picking a sample equal in size to the population basically returns a \"shuffled\" population."]}, {"cell_type": "code", "execution_count": 10, "metadata": {"collapsed": true}, "outputs": [], "source": ["l = range(20)"]}, {"cell_type": "code", "execution_count": 11, "metadata": {}, "outputs": [{"data": {"text/plain": ["[15, 6, 3, 14, 17, 2, 13, 10, 12, 1]"]}, "execution_count": 11, "metadata": {}, "output_type": "execute_result"}], "source": ["random.sample(l, k=10)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can even set the sample size equal to the population size:"]}, {"cell_type": "code", "execution_count": 12, "metadata": {}, "outputs": [{"data": {"text/plain": ["[8, 12, 2, 5, 0, 11, 13, 15, 6, 10, 14, 16, 1, 9, 19, 18, 17, 7, 4, 3]"]}, "execution_count": 12, "metadata": {}, "output_type": "execute_result"}], "source": ["random.sample(l, k=20)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But no larger than the population size:"]}, {"cell_type": "code", "execution_count": 13, "metadata": {}, "outputs": [{"ename": "ValueError", "evalue": "Sample larger than population or is negative", "output_type": "error", "traceback": ["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[1;31mValueError\u001b[0m                                Traceback (most recent call last)", "\u001b[1;32m<ipython-input-13-68df5ccfcccb>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[1;32m----> 1\u001b[1;33m \u001b[0mrandom\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0msample\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0ml\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;36m50\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m", "\u001b[1;32mD:\\Users\\fbapt\\Anaconda3\\envs\\deepdive\\lib\\random.py\u001b[0m in \u001b[0;36msample\u001b[1;34m(self, population, k)\u001b[0m\n\u001b[0;32m    315\u001b[0m         \u001b[0mn\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mlen\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mpopulation\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    316\u001b[0m         \u001b[1;32mif\u001b[0m \u001b[1;32mnot\u001b[0m \u001b[1;36m0\u001b[0m \u001b[1;33m<=\u001b[0m \u001b[0mk\u001b[0m \u001b[1;33m<=\u001b[0m \u001b[0mn\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 317\u001b[1;33m             \u001b[1;32mraise\u001b[0m \u001b[0mValueError\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34m\"Sample larger than population or is negative\"\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    318\u001b[0m         \u001b[0mresult\u001b[0m \u001b[1;33m=\u001b[0m \u001b[1;33m[\u001b[0m\u001b[1;32mNone\u001b[0m\u001b[1;33m]\u001b[0m \u001b[1;33m*\u001b[0m \u001b[0mk\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    319\u001b[0m         \u001b[0msetsize\u001b[0m \u001b[1;33m=\u001b[0m \u001b[1;36m21\u001b[0m        \u001b[1;31m# size of a small set minus size of an empty list\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n", "\u001b[1;31mValueError\u001b[0m: Sample larger than population or is negative"]}], "source": ["random.sample(l, 50)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Also worth pointing out is that if you set a specific seed, you will get repeatability of your sample selection:"]}, {"cell_type": "code", "execution_count": 14, "metadata": {}, "outputs": [{"data": {"text/plain": ["[12, 13, 1, 8, 15]"]}, "execution_count": 14, "metadata": {}, "output_type": "execute_result"}], "source": ["random.seed(0)\n", "random.sample(l, k=5)"]}, {"cell_type": "code", "execution_count": 15, "metadata": {"scrolled": true}, "outputs": [{"data": {"text/plain": ["[12, 13, 1, 8, 15]"]}, "execution_count": 15, "metadata": {}, "output_type": "execute_result"}], "source": ["random.seed(0)\n", "random.sample(l, k=5)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's see how we might use this to select some cards from a deck - obviously we don't want replacement here - once a card has ben picked from a deck it's no longer available for a second random pick."]}, {"cell_type": "code", "execution_count": 16, "metadata": {"collapsed": true}, "outputs": [], "source": ["suits = 'C', 'D', 'H', 'A'\n", "ranks = tuple(range(2,11)) + tuple('JQKA')"]}, {"cell_type": "code", "execution_count": 17, "metadata": {}, "outputs": [{"data": {"text/plain": ["('C', 'D', 'H', 'A')"]}, "execution_count": 17, "metadata": {}, "output_type": "execute_result"}], "source": ["suits"]}, {"cell_type": "code", "execution_count": 18, "metadata": {}, "outputs": [{"data": {"text/plain": ["(2, 3, 4, 5, 6, 7, 8, 9, 10, 'J', 'Q', 'K', 'A')"]}, "execution_count": 18, "metadata": {}, "output_type": "execute_result"}], "source": ["ranks"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now we have to combine suits and ranks to form a deck."]}, {"cell_type": "code", "execution_count": 19, "metadata": {"collapsed": true}, "outputs": [], "source": ["deck = [str(rank) + suit for suit in suits for rank in ranks]"]}, {"cell_type": "code", "execution_count": 20, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["['2C', '3C', '4C', '5C', '6C', '7C', '8C', '9C', '10C', 'JC', 'QC', 'KC', 'AC', '2D', '3D', '4D', '5D', '6D', '7D', '8D', '9D', '10D', 'JD', 'QD', 'KD', 'AD', '2H', '3H', '4H', '5H', '6H', '7H', '8H', '9H', '10H', 'JH', 'QH', 'KH', 'AH', '2A', '3A', '4A', '5A', '6A', '7A', '8A', '9A', '10A', 'JA', 'QA', 'KA', 'AA']\n"]}], "source": ["print(deck)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's import `Counter` from the collections module to make sure we have no repitition when we pull a sample vs when we use `choices`."]}, {"cell_type": "code", "execution_count": 21, "metadata": {"collapsed": true}, "outputs": [], "source": ["from collections import Counter"]}, {"cell_type": "code", "execution_count": 22, "metadata": {}, "outputs": [{"data": {"text/plain": ["Counter({'10C': 1,\n", "         '10D': 1,\n", "         '10H': 1,\n", "         '2A': 1,\n", "         '2D': 1,\n", "         '3A': 1,\n", "         '5D': 1,\n", "         '6A': 1,\n", "         '6C': 1,\n", "         '6H': 1,\n", "         '7D': 1,\n", "         '8C': 1,\n", "         '8D': 1,\n", "         '8H': 1,\n", "         'AD': 1,\n", "         'JC': 1,\n", "         'JD': 1,\n", "         'KA': 1,\n", "         'KH': 1,\n", "         'QA': 1})"]}, "execution_count": 22, "metadata": {}, "output_type": "execute_result"}], "source": ["Counter(random.sample(deck, k=20))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But if we used `choices` most likely we'll get some repetitions:"]}, {"cell_type": "code", "execution_count": 23, "metadata": {}, "outputs": [{"data": {"text/plain": ["Counter({'10A': 1,\n", "         '10H': 1,\n", "         '2C': 2,\n", "         '2D': 1,\n", "         '4A': 1,\n", "         '4H': 1,\n", "         '5A': 1,\n", "         '7A': 1,\n", "         '7C': 1,\n", "         '7H': 1,\n", "         '8A': 1,\n", "         '9D': 1,\n", "         'AC': 1,\n", "         'AD': 1,\n", "         'JD': 1,\n", "         'KA': 1,\n", "         'KD': 2,\n", "         'KH': 1})"]}, "execution_count": 23, "metadata": {}, "output_type": "execute_result"}], "source": ["Counter(random.choices(deck, k=20))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Timing code using timeit"]}, {"cell_type": "markdown", "metadata": {}, "source": ["When we were looking at decorators we wrote a timing decorator. It could even take a number of repititions as a parameter. This can be handy to time functions directly in your code without affecting the result of the function. But it wrote the results out to the console, and sometimes we just want to access the timing data right inside our Python code.\n", "\n", "The `timeit` module in Python is an alternative that works well for some things. It is a little more complicated to use because it runs 'outside' of our local namespace, and you have to pass just small snippets of code to it (well you pass multi-line chunks of code, but it gets tedious), and you also have to make it aware of you global or local scope if that's needed by the code you want to time. One thing it does that we did not do was *temporarily disable* the garbage collector. Still, there are a lot of pitfalls to benchmarking, and this approach like ours, is good enough for most cases. YMMV.\n", "\n", "It has the advantage that it can also be run directly from the command line.\n", "\n", "Let's take a look at it."]}, {"cell_type": "code", "execution_count": 5, "metadata": {"collapsed": true}, "outputs": [], "source": ["from timeit import timeit"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We look at the `timeit` function. There are a few others but this is the main one and the remaining are slight variations that you may find useful, so check out the Python docs for more info."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Basically the `timeit` function needs to know a few things:\n", "\n", "- the Python statement to run (the **stmt** argument)\n", "- how many times to run the same code (the **number** argument - watch out, the default is `1_000_000` times!)\n", "- any setup code (like imports) (the **setup** argument)\n", "- an optional scope that acts like a global scope to the statement (the **globals** argument)\n", "\n", "It will then execute the test `number` of times and return the **total** time elapsed (not an average per test)."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's start with a simple example, where we want to time how long it takes to run the `sqrt` function in the `math` module using two different ways of importing it:"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The first case we want to time is the following:"]}, {"cell_type": "code", "execution_count": 1, "metadata": {}, "outputs": [{"data": {"text/plain": ["1.4142135623730951"]}, "execution_count": 1, "metadata": {}, "output_type": "execute_result"}], "source": ["import math\n", "math.sqrt(2)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["vs"]}, {"cell_type": "code", "execution_count": 2, "metadata": {}, "outputs": [{"data": {"text/plain": ["1.4142135623730951"]}, "execution_count": 2, "metadata": {}, "output_type": "execute_result"}], "source": ["from math import sqrt\n", "sqrt(2)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see in the first example we have to specify `name.sqrt` every time we want to call the `sqrt` function. Is there a time difference between those two approaches?"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's timeit!"]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"ename": "NameError", "evalue": "name 'math' is not defined", "output_type": "error", "traceback": ["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[1;31mNameError\u001b[0m                                 Traceback (most recent call last)", "\u001b[1;32m<ipython-input-7-1d802ee02f1d>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[1;32m----> 1\u001b[1;33m \u001b[0mtimeit\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mstmt\u001b[0m\u001b[1;33m=\u001b[0m\u001b[1;34m'math.sqrt(2)'\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m", "\u001b[1;32mD:\\Users\\fbapt\\Anaconda3\\envs\\deepdive\\lib\\timeit.py\u001b[0m in \u001b[0;36mtimeit\u001b[1;34m(stmt, setup, timer, number, globals)\u001b[0m\n\u001b[0;32m    231\u001b[0m            number=default_number, globals=None):\n\u001b[0;32m    232\u001b[0m     \u001b[1;34m\"\"\"Convenience function to create Timer object and call timeit method.\"\"\"\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 233\u001b[1;33m     \u001b[1;32mreturn\u001b[0m \u001b[0mTimer\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mstmt\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0msetup\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mtimer\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mglobals\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mtimeit\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mnumber\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    234\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    235\u001b[0m def repeat(stmt=\"pass\", setup=\"pass\", timer=default_timer,\n", "\u001b[1;32mD:\\Users\\fbapt\\Anaconda3\\envs\\deepdive\\lib\\timeit.py\u001b[0m in \u001b[0;36mtimeit\u001b[1;34m(self, number)\u001b[0m\n\u001b[0;32m    176\u001b[0m         \u001b[0mgc\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mdisable\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    177\u001b[0m         \u001b[1;32mtry\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 178\u001b[1;33m             \u001b[0mtiming\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0minner\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mit\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mtimer\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    179\u001b[0m         \u001b[1;32mfinally\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    180\u001b[0m             \u001b[1;32mif\u001b[0m \u001b[0mgcold\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n", "\u001b[1;32mD:\\Users\\fbapt\\Anaconda3\\envs\\deepdive\\lib\\timeit.py\u001b[0m in \u001b[0;36minner\u001b[1;34m(_it, _timer)\u001b[0m\n", "\u001b[1;31mNameError\u001b[0m: name 'math' is not defined"]}], "source": ["timeit(stmt='math.sqrt(2)')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["UhOh... we get an exception. Basically `timeit` has no idea what the `math` module is! Remember what I said that it runs inside its own name space?"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can fix this in three ways:"]}, {"cell_type": "markdown", "metadata": {}, "source": ["**First** way we can simply add the import to the statement we want to time."]}, {"cell_type": "code", "execution_count": 15, "metadata": {}, "outputs": [{"data": {"text/plain": ["0.31814690955189917"]}, "execution_count": 15, "metadata": {}, "output_type": "execute_result"}], "source": ["timeit(stmt = 'import math\\nmath.sqrt(2)')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["This is bad for two reasons: readability obviously, but also the timing is now going to include timing the `import math` statement **every time** as well. That's not how our imports work in Python. We import once and then use that imported module over and over again. "]}, {"cell_type": "markdown", "metadata": {}, "source": ["**Second** way is to use the `setup` argument - basically that allows us to setup the runtime environment of whatever code snippet we want to run. That setup code is only run once, not for every test:"]}, {"cell_type": "code", "execution_count": 16, "metadata": {}, "outputs": [{"data": {"text/plain": ["0.15629067671147823"]}, "execution_count": 16, "metadata": {}, "output_type": "execute_result"}], "source": ["timeit(stmt = 'math.sqrt(2)', setup='import math')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see this ran faster than importing at every test."]}, {"cell_type": "markdown", "metadata": {}, "source": ["**Third** way is to provide `timeit` with a global namespace that already contains the import - as we have in our case. Our `global` namespace already has the import:"]}, {"cell_type": "code", "execution_count": 17, "metadata": {}, "outputs": [{"data": {"text/plain": ["0.16592102572019485"]}, "execution_count": 17, "metadata": {}, "output_type": "execute_result"}], "source": ["timeit(stmt='math.sqrt(2)', globals=globals())"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see that was a little less efficient (but what's about `0.01` seconds over `1_000_000` repetitions between friends...)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["So let's go with the `setup` approach and now time the difference between using the two import styles:"]}, {"cell_type": "code", "execution_count": 18, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Result 1 = 0.1496401825296516\n", "Result 2 = 0.10674273423342129\n"]}], "source": ["result_1 = timeit(stmt='math.sqrt(2)', setup='import math')\n", "result_2 = timeit(stmt='sqrt(2)', setup='from math import sqrt')\n", "print(f'Result 1 = {result_1}')\n", "print(f'Result 2 = {result_2}')"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see the `from math import sqrt` was slightly more efficient. But again, what's a about `0.4` seconds over `1_000_000` iterations. \n", "\n", "If that's what you're optimizing before you even profile your application you're doing things wrong!\n", "\n", "Explicit is better than implicit.\n", "\n", "So when someone sees `math.sqrt` they know `sqrt` comes from the `math` module. If they see `sqrt` they have to look at your imports to double check which module `sqrt` came from.\n", "\n", "If the module name is long and you don't want to always type it, you can always alias it. Or use the `from` style of import. Whatever reads best since optimization is not really a concern at that point."]}, {"cell_type": "markdown", "metadata": {}, "source": ["One last thing, what if the statement(s) you want to time require something from the scope in which it is running? How do you \"pass\" that variable to the `timeit` statement?\n", "\n", "That's where the `globals` argument comes in - we already saw it in action for the imports, but the `globals()` and `locals()` functions can reference the global and local name spaces."]}, {"cell_type": "code", "execution_count": 19, "metadata": {}, "outputs": [{"data": {"text/plain": ["{'In': ['',\n", "  'import math\\nmath.sqrt(2)',\n", "  'from math import sqrt\\nsqrt(2)',\n", "  'get_ipython().magic(\"timeit (stmt=\\'math.sqrt(2)\\')\")',\n", "  'help(timeit)',\n", "  'from timeit import timeit',\n", "  'help(timeit)',\n", "  \"timeit(stmt='math.sqrt(2)')\",\n", "  \"timeit(stmt='math.sqrt(2)', globals=globals())\",\n", "  \"timeit(stmt = 'import math' 'math.sqrt(2)')\",\n", "  \"timeit(stmt = 'import math\\\\nmath.sqrt(2)')\",\n", "  \"timeit(stmt = 'math.sqrt(2)', setup='import math')\",\n", "  \"timeit(stmt='math.sqrt(2)', globals=globals())\",\n", "  \"timeit(stmt = 'math.sqrt(2)', setup='import math', number=2_000_000)\",\n", "  \"timeit(stmt = 'math.sqrt(2)', setup='import math')\",\n", "  \"timeit(stmt = 'import math\\\\nmath.sqrt(2)')\",\n", "  \"timeit(stmt = 'math.sqrt(2)', setup='import math')\",\n", "  \"timeit(stmt='math.sqrt(2)', globals=globals())\",\n", "  \"result_1 = timeit(stmt='math.sqrt(2)', setup='import math')\\nresult_2 = timeit(stmt='sqrt(2)', setup='from math import sqrt')\\nprint(f'Result 1 = {result_1}')\\nprint(f'Result 2 = {result_2}')\",\n", "  'globals()'],\n", " 'Out': {1: 1.4142135623730951,\n", "  2: 1.4142135623730951,\n", "  8: 0.1674586308108843,\n", "  10: 0.3324981612941258,\n", "  11: 0.15236431163322095,\n", "  12: 0.1631630346299744,\n", "  13: 0.3154899626299539,\n", "  14: 0.15821755920092073,\n", "  15: 0.31814690955189917,\n", "  16: 0.15629067671147823,\n", "  17: 0.16592102572019485},\n", " '_': 0.16592102572019485,\n", " '_1': 1.4142135623730951,\n", " '_10': 0.3324981612941258,\n", " '_11': 0.15236431163322095,\n", " '_12': 0.1631630346299744,\n", " '_13': 0.3154899626299539,\n", " '_14': 0.15821755920092073,\n", " '_15': 0.31814690955189917,\n", " '_16': 0.15629067671147823,\n", " '_17': 0.16592102572019485,\n", " '_2': 1.4142135623730951,\n", " '_8': 0.1674586308108843,\n", " '__': 0.15629067671147823,\n", " '___': 0.31814690955189917,\n", " '__builtin__': <module 'builtins' (built-in)>,\n", " '__builtins__': <module 'builtins' (built-in)>,\n", " '__doc__': 'Automatically created module for IPython interactive environment',\n", " '__loader__': None,\n", " '__name__': '__main__',\n", " '__package__': None,\n", " '__spec__': None,\n", " '_dh': ['d:\\\\fbapt\\\\Dropbox\\\\Python Deep Dive\\\\Section 09 - Extras\\\\10 - Timing things using timeit'],\n", " '_i': \"result_1 = timeit(stmt='math.sqrt(2)', setup='import math')\\nresult_2 = timeit(stmt='sqrt(2)', setup='from math import sqrt')\\nprint(f'Result 1 = {result_1}')\\nprint(f'Result 2 = {result_2}')\",\n", " '_i1': 'import math\\nmath.sqrt(2)',\n", " '_i10': \"timeit(stmt = 'import math\\\\nmath.sqrt(2)')\",\n", " '_i11': \"timeit(stmt = 'math.sqrt(2)', setup='import math')\",\n", " '_i12': \"timeit(stmt='math.sqrt(2)', globals=globals())\",\n", " '_i13': \"timeit(stmt = 'math.sqrt(2)', setup='import math', number=2_000_000)\",\n", " '_i14': \"timeit(stmt = 'math.sqrt(2)', setup='import math')\",\n", " '_i15': \"timeit(stmt = 'import math\\\\nmath.sqrt(2)')\",\n", " '_i16': \"timeit(stmt = 'math.sqrt(2)', setup='import math')\",\n", " '_i17': \"timeit(stmt='math.sqrt(2)', globals=globals())\",\n", " '_i18': \"result_1 = timeit(stmt='math.sqrt(2)', setup='import math')\\nresult_2 = timeit(stmt='sqrt(2)', setup='from math import sqrt')\\nprint(f'Result 1 = {result_1}')\\nprint(f'Result 2 = {result_2}')\",\n", " '_i19': 'globals()',\n", " '_i2': 'from math import sqrt\\nsqrt(2)',\n", " '_i3': \"timeit(stmt='math.sqrt(2)')\",\n", " '_i4': 'help(timeit)',\n", " '_i5': 'from timeit import timeit',\n", " '_i6': 'help(timeit)',\n", " '_i7': \"timeit(stmt='math.sqrt(2)')\",\n", " '_i8': \"timeit(stmt='math.sqrt(2)', globals=globals())\",\n", " '_i9': \"timeit(stmt = 'import math' 'math.sqrt(2)')\",\n", " '_ih': ['',\n", "  'import math\\nmath.sqrt(2)',\n", "  'from math import sqrt\\nsqrt(2)',\n", "  'get_ipython().magic(\"timeit (stmt=\\'math.sqrt(2)\\')\")',\n", "  'help(timeit)',\n", "  'from timeit import timeit',\n", "  'help(timeit)',\n", "  \"timeit(stmt='math.sqrt(2)')\",\n", "  \"timeit(stmt='math.sqrt(2)', globals=globals())\",\n", "  \"timeit(stmt = 'import math' 'math.sqrt(2)')\",\n", "  \"timeit(stmt = 'import math\\\\nmath.sqrt(2)')\",\n", "  \"timeit(stmt = 'math.sqrt(2)', setup='import math')\",\n", "  \"timeit(stmt='math.sqrt(2)', globals=globals())\",\n", "  \"timeit(stmt = 'math.sqrt(2)', setup='import math', number=2_000_000)\",\n", "  \"timeit(stmt = 'math.sqrt(2)', setup='import math')\",\n", "  \"timeit(stmt = 'import math\\\\nmath.sqrt(2)')\",\n", "  \"timeit(stmt = 'math.sqrt(2)', setup='import math')\",\n", "  \"timeit(stmt='math.sqrt(2)', globals=globals())\",\n", "  \"result_1 = timeit(stmt='math.sqrt(2)', setup='import math')\\nresult_2 = timeit(stmt='sqrt(2)', setup='from math import sqrt')\\nprint(f'Result 1 = {result_1}')\\nprint(f'Result 2 = {result_2}')\",\n", "  'globals()'],\n", " '_ii': \"timeit(stmt='math.sqrt(2)', globals=globals())\",\n", " '_iii': \"timeit(stmt = 'math.sqrt(2)', setup='import math')\",\n", " '_oh': {1: 1.4142135623730951,\n", "  2: 1.4142135623730951,\n", "  8: 0.1674586308108843,\n", "  10: 0.3324981612941258,\n", "  11: 0.15236431163322095,\n", "  12: 0.1631630346299744,\n", "  13: 0.3154899626299539,\n", "  14: 0.15821755920092073,\n", "  15: 0.31814690955189917,\n", "  16: 0.15629067671147823,\n", "  17: 0.16592102572019485},\n", " 'exit': <IPython.core.autocall.ZMQExitAutocall at 0x1e343645518>,\n", " 'get_ipython': <bound method InteractiveShell.get_ipython of <ipykernel.zmqshell.ZMQInteractiveShell object at 0x000001E3434E31D0>>,\n", " 'math': <module 'math' (built-in)>,\n", " 'quit': <IPython.core.autocall.ZMQExitAutocall at 0x1e343645518>,\n", " 'result_1': 0.1496401825296516,\n", " 'result_2': 0.10674273423342129,\n", " 'sqrt': <function math.sqrt>,\n", " 'timeit': <function timeit.timeit>}"]}, "execution_count": 19, "metadata": {}, "output_type": "execute_result"}], "source": ["globals()"]}, {"cell_type": "code", "execution_count": 20, "metadata": {}, "outputs": [{"data": {"text/plain": ["{'In': ['',\n", "  'import math\\nmath.sqrt(2)',\n", "  'from math import sqrt\\nsqrt(2)',\n", "  'get_ipython().magic(\"timeit (stmt=\\'math.sqrt(2)\\')\")',\n", "  'help(timeit)',\n", "  'from timeit import timeit',\n", "  'help(timeit)',\n", "  \"timeit(stmt='math.sqrt(2)')\",\n", "  \"timeit(stmt='math.sqrt(2)', globals=globals())\",\n", "  \"timeit(stmt = 'import math' 'math.sqrt(2)')\",\n", "  \"timeit(stmt = 'import math\\\\nmath.sqrt(2)')\",\n", "  \"timeit(stmt = 'math.sqrt(2)', setup='import math')\",\n", "  \"timeit(stmt='math.sqrt(2)', globals=globals())\",\n", "  \"timeit(stmt = 'math.sqrt(2)', setup='import math', number=2_000_000)\",\n", "  \"timeit(stmt = 'math.sqrt(2)', setup='import math')\",\n", "  \"timeit(stmt = 'import math\\\\nmath.sqrt(2)')\",\n", "  \"timeit(stmt = 'math.sqrt(2)', setup='import math')\",\n", "  \"timeit(stmt='math.sqrt(2)', globals=globals())\",\n", "  \"result_1 = timeit(stmt='math.sqrt(2)', setup='import math')\\nresult_2 = timeit(stmt='sqrt(2)', setup='from math import sqrt')\\nprint(f'Result 1 = {result_1}')\\nprint(f'Result 2 = {result_2}')\",\n", "  'globals()',\n", "  'locals()'],\n", " 'Out': {1: 1.4142135623730951,\n", "  2: 1.4142135623730951,\n", "  8: 0.1674586308108843,\n", "  10: 0.3324981612941258,\n", "  11: 0.15236431163322095,\n", "  12: 0.1631630346299744,\n", "  13: 0.3154899626299539,\n", "  14: 0.15821755920092073,\n", "  15: 0.31814690955189917,\n", "  16: 0.15629067671147823,\n", "  17: 0.16592102572019485,\n", "  19: {...}},\n", " '_': {...},\n", " '_1': 1.4142135623730951,\n", " '_10': 0.3324981612941258,\n", " '_11': 0.15236431163322095,\n", " '_12': 0.1631630346299744,\n", " '_13': 0.3154899626299539,\n", " '_14': 0.15821755920092073,\n", " '_15': 0.31814690955189917,\n", " '_16': 0.15629067671147823,\n", " '_17': 0.16592102572019485,\n", " '_19': {...},\n", " '_2': 1.4142135623730951,\n", " '_8': 0.1674586308108843,\n", " '__': 0.16592102572019485,\n", " '___': 0.15629067671147823,\n", " '__builtin__': <module 'builtins' (built-in)>,\n", " '__builtins__': <module 'builtins' (built-in)>,\n", " '__doc__': 'Automatically created module for IPython interactive environment',\n", " '__loader__': None,\n", " '__name__': '__main__',\n", " '__package__': None,\n", " '__spec__': None,\n", " '_dh': ['d:\\\\fbapt\\\\Dropbox\\\\Python Deep Dive\\\\Section 09 - Extras\\\\10 - Timing things using timeit'],\n", " '_i': 'globals()',\n", " '_i1': 'import math\\nmath.sqrt(2)',\n", " '_i10': \"timeit(stmt = 'import math\\\\nmath.sqrt(2)')\",\n", " '_i11': \"timeit(stmt = 'math.sqrt(2)', setup='import math')\",\n", " '_i12': \"timeit(stmt='math.sqrt(2)', globals=globals())\",\n", " '_i13': \"timeit(stmt = 'math.sqrt(2)', setup='import math', number=2_000_000)\",\n", " '_i14': \"timeit(stmt = 'math.sqrt(2)', setup='import math')\",\n", " '_i15': \"timeit(stmt = 'import math\\\\nmath.sqrt(2)')\",\n", " '_i16': \"timeit(stmt = 'math.sqrt(2)', setup='import math')\",\n", " '_i17': \"timeit(stmt='math.sqrt(2)', globals=globals())\",\n", " '_i18': \"result_1 = timeit(stmt='math.sqrt(2)', setup='import math')\\nresult_2 = timeit(stmt='sqrt(2)', setup='from math import sqrt')\\nprint(f'Result 1 = {result_1}')\\nprint(f'Result 2 = {result_2}')\",\n", " '_i19': 'globals()',\n", " '_i2': 'from math import sqrt\\nsqrt(2)',\n", " '_i20': 'locals()',\n", " '_i3': \"timeit(stmt='math.sqrt(2)')\",\n", " '_i4': 'help(timeit)',\n", " '_i5': 'from timeit import timeit',\n", " '_i6': 'help(timeit)',\n", " '_i7': \"timeit(stmt='math.sqrt(2)')\",\n", " '_i8': \"timeit(stmt='math.sqrt(2)', globals=globals())\",\n", " '_i9': \"timeit(stmt = 'import math' 'math.sqrt(2)')\",\n", " '_ih': ['',\n", "  'import math\\nmath.sqrt(2)',\n", "  'from math import sqrt\\nsqrt(2)',\n", "  'get_ipython().magic(\"timeit (stmt=\\'math.sqrt(2)\\')\")',\n", "  'help(timeit)',\n", "  'from timeit import timeit',\n", "  'help(timeit)',\n", "  \"timeit(stmt='math.sqrt(2)')\",\n", "  \"timeit(stmt='math.sqrt(2)', globals=globals())\",\n", "  \"timeit(stmt = 'import math' 'math.sqrt(2)')\",\n", "  \"timeit(stmt = 'import math\\\\nmath.sqrt(2)')\",\n", "  \"timeit(stmt = 'math.sqrt(2)', setup='import math')\",\n", "  \"timeit(stmt='math.sqrt(2)', globals=globals())\",\n", "  \"timeit(stmt = 'math.sqrt(2)', setup='import math', number=2_000_000)\",\n", "  \"timeit(stmt = 'math.sqrt(2)', setup='import math')\",\n", "  \"timeit(stmt = 'import math\\\\nmath.sqrt(2)')\",\n", "  \"timeit(stmt = 'math.sqrt(2)', setup='import math')\",\n", "  \"timeit(stmt='math.sqrt(2)', globals=globals())\",\n", "  \"result_1 = timeit(stmt='math.sqrt(2)', setup='import math')\\nresult_2 = timeit(stmt='sqrt(2)', setup='from math import sqrt')\\nprint(f'Result 1 = {result_1}')\\nprint(f'Result 2 = {result_2}')\",\n", "  'globals()',\n", "  'locals()'],\n", " '_ii': \"result_1 = timeit(stmt='math.sqrt(2)', setup='import math')\\nresult_2 = timeit(stmt='sqrt(2)', setup='from math import sqrt')\\nprint(f'Result 1 = {result_1}')\\nprint(f'Result 2 = {result_2}')\",\n", " '_iii': \"timeit(stmt='math.sqrt(2)', globals=globals())\",\n", " '_oh': {1: 1.4142135623730951,\n", "  2: 1.4142135623730951,\n", "  8: 0.1674586308108843,\n", "  10: 0.3324981612941258,\n", "  11: 0.15236431163322095,\n", "  12: 0.1631630346299744,\n", "  13: 0.3154899626299539,\n", "  14: 0.15821755920092073,\n", "  15: 0.31814690955189917,\n", "  16: 0.15629067671147823,\n", "  17: 0.16592102572019485,\n", "  19: {...}},\n", " 'exit': <IPython.core.autocall.ZMQExitAutocall at 0x1e343645518>,\n", " 'get_ipython': <bound method InteractiveShell.get_ipython of <ipykernel.zmqshell.ZMQInteractiveShell object at 0x000001E3434E31D0>>,\n", " 'math': <module 'math' (built-in)>,\n", " 'quit': <IPython.core.autocall.ZMQExitAutocall at 0x1e343645518>,\n", " 'result_1': 0.1496401825296516,\n", " 'result_2': 0.10674273423342129,\n", " 'sqrt': <function math.sqrt>,\n", " 'timeit': <function timeit.timeit>}"]}, "execution_count": 20, "metadata": {}, "output_type": "execute_result"}], "source": ["locals()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Let's use globals first:"]}, {"cell_type": "code", "execution_count": 21, "metadata": {"collapsed": true}, "outputs": [], "source": ["import random"]}, {"cell_type": "code", "execution_count": 22, "metadata": {"collapsed": true}, "outputs": [], "source": ["l = random.choices(list('python'), k=500)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The variable `l` is now in our global name space."]}, {"cell_type": "code", "execution_count": 24, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 24, "metadata": {}, "output_type": "execute_result"}], "source": ["'l' in globals()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["And technically in our local name space too:"]}, {"cell_type": "code", "execution_count": 25, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 25, "metadata": {}, "output_type": "execute_result"}], "source": ["'l' in locals()"]}, {"cell_type": "code", "execution_count": 27, "metadata": {}, "outputs": [{"data": {"text/plain": ["1.1323987425012092"]}, "execution_count": 27, "metadata": {}, "output_type": "execute_result"}], "source": ["timeit(stmt='random.choice(l)', setup='import random', globals=globals())"]}, {"cell_type": "markdown", "metadata": {}, "source": ["As you can see the statement was able to access `l` from the `globals()` that as passed to the `global` argument."]}, {"cell_type": "markdown", "metadata": {}, "source": ["Sometimes though you may have to use the local namespace, for exampele inside a function:"]}, {"cell_type": "code", "execution_count": 30, "metadata": {"collapsed": true}, "outputs": [], "source": ["def random_choices():\n", "    randoms = random.choices(list('python'), k=500)\n", "    \n", "    return timeit(stmt='random.choice(randoms)', \n", "                  setup='import random', \n", "                  globals=locals())"]}, {"cell_type": "code", "execution_count": 31, "metadata": {}, "outputs": [{"data": {"text/plain": ["1.0808561935605212"]}, "execution_count": 31, "metadata": {}, "output_type": "execute_result"}], "source": ["random_choices()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["I hope you saw that running the code using a local `randoms` ran slightly faster than using it from the global scope!\n", "\n", "We'll come back to that in a later video, but in fact running code from the global namespace (i.e. at the module level) is slightly slower in general than running it in a local namespace (i.e. inside a function)."]}, {"cell_type": "markdown", "metadata": {}, "source": ["If we had passed it `globals()` instead it would not have worked since `randoms` is not in the global namespace:"]}, {"cell_type": "code", "execution_count": 32, "metadata": {}, "outputs": [{"data": {"text/plain": ["False"]}, "execution_count": 32, "metadata": {}, "output_type": "execute_result"}], "source": ["'randoms' in globals()"]}, {"cell_type": "code", "execution_count": 33, "metadata": {"collapsed": true}, "outputs": [], "source": ["def random_choices():\n", "    randoms = random.choices(list('python'), k=500)\n", "    \n", "    return timeit(stmt='random.choice(randoms)', \n", "                  setup='import random', \n", "                  globals=globals())"]}, {"cell_type": "code", "execution_count": 34, "metadata": {}, "outputs": [{"ename": "NameError", "evalue": "name 'randoms' is not defined", "output_type": "error", "traceback": ["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m", "\u001b[1;31mNameError\u001b[0m                                 Traceback (most recent call last)", "\u001b[1;32m<ipython-input-34-9e88504addca>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[1;32m----> 1\u001b[1;33m \u001b[0mrandom_choices\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m", "\u001b[1;32m<ipython-input-33-2aaae2461319>\u001b[0m in \u001b[0;36mrandom_choices\u001b[1;34m()\u001b[0m\n\u001b[0;32m      4\u001b[0m     return timeit(stmt='random.choice(randoms)', \n\u001b[0;32m      5\u001b[0m                   \u001b[0msetup\u001b[0m\u001b[1;33m=\u001b[0m\u001b[1;34m'import random'\u001b[0m\u001b[1;33m,\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m----> 6\u001b[1;33m                   globals=globals())\n\u001b[0m", "\u001b[1;32mD:\\Users\\fbapt\\Anaconda3\\envs\\deepdive\\lib\\timeit.py\u001b[0m in \u001b[0;36mtimeit\u001b[1;34m(stmt, setup, timer, number, globals)\u001b[0m\n\u001b[0;32m    231\u001b[0m            number=default_number, globals=None):\n\u001b[0;32m    232\u001b[0m     \u001b[1;34m\"\"\"Convenience function to create Timer object and call timeit method.\"\"\"\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 233\u001b[1;33m     \u001b[1;32mreturn\u001b[0m \u001b[0mTimer\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mstmt\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0msetup\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mtimer\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mglobals\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mtimeit\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mnumber\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    234\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    235\u001b[0m def repeat(stmt=\"pass\", setup=\"pass\", timer=default_timer,\n", "\u001b[1;32mD:\\Users\\fbapt\\Anaconda3\\envs\\deepdive\\lib\\timeit.py\u001b[0m in \u001b[0;36mtimeit\u001b[1;34m(self, number)\u001b[0m\n\u001b[0;32m    176\u001b[0m         \u001b[0mgc\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mdisable\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    177\u001b[0m         \u001b[1;32mtry\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 178\u001b[1;33m             \u001b[0mtiming\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0minner\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mit\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mtimer\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    179\u001b[0m         \u001b[1;32mfinally\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    180\u001b[0m             \u001b[1;32mif\u001b[0m \u001b[0mgcold\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n", "\u001b[1;32m<timeit-src>\u001b[0m in \u001b[0;36minner\u001b[1;34m(_it, _timer)\u001b[0m\n", "\u001b[1;31mNameError\u001b[0m: name 'randoms' is not defined"]}], "source": ["random_choices()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["One more thing to point out is that functions defined at the module level are actually in our global namespace as well:"]}, {"cell_type": "code", "execution_count": 35, "metadata": {"collapsed": true}, "outputs": [], "source": ["def pick_random(lst):\n", "    return random.choice(lst)"]}, {"cell_type": "code", "execution_count": 36, "metadata": {}, "outputs": [{"data": {"text/plain": ["True"]}, "execution_count": 36, "metadata": {}, "output_type": "execute_result"}], "source": ["'pick_random' in globals()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["This means that technically we can write the function we want to time in our global/local scope, and pass the scope in and then reference the function from that scope in our statement. It will be slower though since it has to find the function in the scope first - but you could do it to test relative performance differences:"]}, {"cell_type": "code", "execution_count": 37, "metadata": {}, "outputs": [{"data": {"text/plain": ["1.216267840187811"]}, "execution_count": 37, "metadata": {}, "output_type": "execute_result"}], "source": ["timeit(stmt='pick_random(l)', globals=globals())"]}, {"cell_type": "markdown", "metadata": {}, "source": ["And there you go, `timeit` was able to access both `pick_random` and the variable `l`."]}, {"cell_type": "markdown", "metadata": {}, "source": ["### Don't Use *args and **kwargs Names Blindly"]}, {"cell_type": "markdown", "metadata": {}, "source": ["In most of the code we have been working with we used `*args` and `**kwargs`. But these were small code snippets where the argument names did not necessarily have meaning, or were used very generically such as with decorators.\n", "\n", "In your code, if those variable positional and keyword-only arguments have meaning, then use a meaningful name instead of just `*args` and `**kwargs`."]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Example 1"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Here, using the conventional names `args` and `kwargs` makes sense since we have no idea what those are - we are simply using them as a pass through to call another function in our decorator:"]}, {"cell_type": "code", "execution_count": 1, "metadata": {"collapsed": true}, "outputs": [], "source": ["def audit(f):\n", "    def inner(*args, **kwargs):\n", "        print(f'Called {f.__name__}')\n", "        return f(*args, **kwargs)\n", "    return inner"]}, {"cell_type": "markdown", "metadata": {}, "source": ["But for the following `product` function, it makes more sense to use `*values` than `*args`."]}, {"cell_type": "code", "execution_count": 2, "metadata": {"collapsed": true}, "outputs": [], "source": ["@audit\n", "def say_hello(name):\n", "    return f'Hello {name}'\n", "\n", "from operator import mul\n", "from functools import reduce\n", "\n", "@audit\n", "def product(*values):\n", "    return reduce(mul, values)"]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Called say_hello\n"]}, {"data": {"text/plain": ["'Hello Polly'"]}, "execution_count": 3, "metadata": {}, "output_type": "execute_result"}], "source": ["say_hello('Polly')"]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Called product\n"]}, {"data": {"text/plain": ["24"]}, "execution_count": 4, "metadata": {}, "output_type": "execute_result"}], "source": ["product(1, 2, 3, 4)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Example 2"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Same thing here - using `*item_values` makes more sense than `*args`:"]}, {"cell_type": "code", "execution_count": 5, "metadata": {"collapsed": true}, "outputs": [], "source": ["def count_multi(lst, *item_values):\n", "    return sum(lst.count(value) for value in item_values)"]}, {"cell_type": "code", "execution_count": 6, "metadata": {"collapsed": true}, "outputs": [], "source": ["l = 1, 1, 2, 3, 4, 5, 6, 6, 7, 8, 9, 10"]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [{"data": {"text/plain": ["5"]}, "execution_count": 7, "metadata": {}, "output_type": "execute_result"}], "source": ["count_multi(l, 1, 6, 7)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["#### Example 3"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Suppose we want our class init to allow people to send in additional arbitrary (custom) instance attributes:"]}, {"cell_type": "code", "execution_count": 8, "metadata": {"collapsed": true}, "outputs": [], "source": ["class Person:\n", "    def __init__(self, name, age, **custom_attributes):\n", "        self.name = name\n", "        self.age = age\n", "        for attr_name, attr_value in custom_attributes.items():\n", "            setattr(self, attr_name, attr_value)        "]}, {"cell_type": "code", "execution_count": 9, "metadata": {"collapsed": true}, "outputs": [], "source": ["parrot = Person('Polly', 101, status='stiff', vooms=False)"]}, {"cell_type": "code", "execution_count": 10, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["{'name': 'Polly', 'age': 101, 'status': 'stiff', 'vooms': False}\n"]}], "source": ["print(vars(parrot))"]}, {"cell_type": "code", "execution_count": 11, "metadata": {"collapsed": true}, "outputs": [], "source": ["michael = Person('Michael', 42, role='shopkeeper', crooked=True)"]}, {"cell_type": "code", "execution_count": 12, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["{'name': 'Michael', 'age': 42, 'role': 'shopkeeper', 'crooked': True}\n"]}], "source": ["print(vars(michael))"]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": []}, {"cell_type": "markdown", "metadata": {}, "source": ["### Sentinel Values for Parameter Defaults"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Often we specify the default for a function parameter as `None`. This allows to determine if the user specified an argument for that parameter or not. \n", "\n", "There's a potential issue here!\n", "\n", "What happens if we need to differentiate between the following:\n", "* a non-`None` value was provided for the argument\n", "* a `None` value *was* provided for the argument\n", "* the argument was not provided at all"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Obviously, if we write our function this way, it will not work as intended:"]}, {"cell_type": "code", "execution_count": 14, "metadata": {"collapsed": true}, "outputs": [], "source": ["def validate(a=None):\n", "    if a is not None:\n", "       print('Argument was provided')\n", "    else:\n", "        print('Argument was not provided')"]}, {"cell_type": "code", "execution_count": 15, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Argument was provided\n"]}], "source": ["validate(100)"]}, {"cell_type": "code", "execution_count": 16, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Argument was not provided\n"]}], "source": ["validate()"]}, {"cell_type": "code", "execution_count": 17, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Argument was not provided\n"]}], "source": ["validate(None)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Instead, we need to use a different **sentinel** value. But which one?\n", "\n", "How can we **guarantee** that whatever sentinel we use will not be explicitly passed in by the user?"]}, {"cell_type": "markdown", "metadata": {}, "source": ["For example we could try to use something like an unlikely string or integer. But that does not guarantee that the caller won't use that precise sentinel value at some point."]}, {"cell_type": "markdown", "metadata": {}, "source": ["The easiest thing to do is to create an instance of the `object` class. This is guaranteed to result in an object that the user cannot pass to us (they have no way of getting their hands on that object - or at least not without the absolute intention to do so). (remember that Python will always allow us to shoot ourselves in the foot if we try hard enough :-) )"]}, {"cell_type": "code", "execution_count": 51, "metadata": {"collapsed": true}, "outputs": [], "source": ["_sentinel = object()\n", "\n", "def validate(a=_sentinel):\n", "    if a is not _sentinel:\n", "        print('Argument was provided')\n", "    else:\n", "        print('Argument was not provided')"]}, {"cell_type": "code", "execution_count": 52, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Argument was provided\n"]}], "source": ["validate(100)"]}, {"cell_type": "code", "execution_count": 53, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Argument was provided\n"]}], "source": ["validate(None)"]}, {"cell_type": "code", "execution_count": 54, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Argument was not provided\n"]}], "source": ["validate()"]}, {"cell_type": "code", "execution_count": 55, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Argument was provided\n"]}], "source": ["validate(object())"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now, instead of using a separate variable to hold the sentinel value (`_sentinel`), we can introspect the function to find out what the default sentinel value is:"]}, {"cell_type": "code", "execution_count": 61, "metadata": {"collapsed": true}, "outputs": [], "source": ["def validate(a=object()):\n", "    default_a = validate.__defaults__[0]\n", "    if a is not default_a:\n", "        print('Argument was provided')\n", "    else:\n", "        print('Argument was not provided')\n", "    \n", "    "]}, {"cell_type": "code", "execution_count": 62, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Argument was provided\n"]}], "source": ["validate(100)"]}, {"cell_type": "code", "execution_count": 63, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Argument was provided\n"]}], "source": ["validate(None)"]}, {"cell_type": "code", "execution_count": 64, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Argument was not provided\n"]}], "source": ["validate()"]}, {"cell_type": "code", "execution_count": 65, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Argument was provided\n"]}], "source": ["validate(object())"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can expand this to several parameters as well if we need to, using either method:"]}, {"cell_type": "code", "execution_count": 66, "metadata": {"collapsed": true}, "outputs": [], "source": ["def validate(a=object(), b=object(), *, kw=object()):\n", "    default_a = validate.__defaults__[0]\n", "    default_b = validate.__defaults__[1]\n", "    default_kw = validate.__kwdefaults__['kw']\n", "    \n", "    if a is not default_a:\n", "        print('Argument a was provided')\n", "    else:\n", "        print('Argument a was not provided')\n", "        \n", "    if b is not default_b:\n", "        print('Argument b was provided')\n", "    else:\n", "        print('Argument b was not provided')\n", "        \n", "    if kw is not default_kw:\n", "        print('Argument kw was provided')\n", "    else:\n", "        print('Argument kw was not provided')"]}, {"cell_type": "code", "execution_count": 67, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Argument a was provided\n", "Argument b was provided\n", "Argument kw was provided\n"]}], "source": ["validate(100, 200, kw=None)"]}, {"cell_type": "code", "execution_count": 68, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Argument a was provided\n", "Argument b was provided\n", "Argument kw was not provided\n"]}], "source": ["validate(100, 200)"]}, {"cell_type": "code", "execution_count": 69, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Argument a was not provided\n", "Argument b was provided\n", "Argument kw was not provided\n"]}], "source": ["validate(b=100)"]}, {"cell_type": "code", "execution_count": 70, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Argument a was not provided\n", "Argument b was not provided\n", "Argument kw was not provided\n"]}], "source": ["validate()"]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": []}, {"cell_type": "markdown", "metadata": {}, "source": ["### Simulating a simple Switch in Python"]}, {"cell_type": "markdown", "metadata": {}, "source": ["This is based on a few questions I've received regarding a `switch` statement in Python.\n", "\n", "Python does not have a switch statement, but it is possible to have similar functionality in a variety of ways.\n", "\n", "Here I'm going to assume a simple `switch` statement where each `case` has a `break` (in other words, no fall through), and is based on a single value.\n", "\n", "You can see a PEP that discussed adding a `switch` statement to Python, proposed by Guido, but ultimately rejected (by Guido as well):\n", "https://www.python.org/dev/peps/pep-3103/"]}, {"cell_type": "markdown", "metadata": {}, "source": ["A simple Java example would be something like this:"]}, {"cell_type": "markdown", "metadata": {}, "source": ["```\n", "switch (dow) {\n", "    case 1: dowString = 'Monday';\n", "            break;\n", "    case 2: dowString = 'Tuesday';\n", "            break;\n", "    case 3: dowString = 'Wednesday';\n", "            break;\n", "    case 4: dowString = 'Thursday';\n", "            break;\n", "    case 5: dowString = 'Friday';\n", "            break;\n", "    case 6: dowString = 'Saturday';\n", "            break;\n", "    case 7: dowString = 'Sunday';\n", "            break;\n", "    default: dowString = 'Invalid day of week';\n", "}\n", "```"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The simplest approach here is to simply use an `if...elif...else` structure.\n", "\n", "To make it slightly more interesting, I'm not going to set a variable for each case statement, I'm going to return a function - to keep it simple I'll just call the `print()` function, but it could be anything really."]}, {"cell_type": "code", "execution_count": 1, "metadata": {"collapsed": true}, "outputs": [], "source": ["def dow_switch_fn(dow):\n", "    if dow == 1:\n", "        fn = lambda: print('Monday')\n", "    elif dow == 2:\n", "        fn = lambda: print('Tuesday')\n", "    elif dow == 3:\n", "        fn = lambda: print('Wednesday')\n", "    elif dow == 4:\n", "        fn = lambda: print('Thursday')\n", "    elif dow == 5:\n", "        fn = lambda: print('Friday')\n", "    elif dow == 6:\n", "        fn = lambda: print('Saturday')\n", "    elif dow == 7:\n", "        fn = lambda: print('Sunday')\n", "    else:\n", "        fn = lambda: print('Invalid day of week')\n", "    \n", "    return fn()"]}, {"cell_type": "code", "execution_count": 2, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Monday\n"]}], "source": ["dow_switch_fn(1)"]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Invalid day of week\n"]}], "source": ["dow_switch_fn(100)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now, dictionaries could also be used quite effectively here:"]}, {"cell_type": "code", "execution_count": 4, "metadata": {"collapsed": true}, "outputs": [], "source": ["def dow_switch_dict(dow):\n", "    dow_dict = {\n", "        1: lambda: print('Monday'),\n", "        2: lambda: print('Tuesday'),\n", "        3: lambda: print('Wednesday'),\n", "        4: lambda: print('Thursday'),\n", "        5: lambda: print('Friday'),\n", "        6: lambda: print('Saturday'),\n", "        7: lambda: print('Sunday'),\n", "        'default': lambda: print('Invalid day of week')\n", "    }\n", "    \n", "    return dow_dict.get(dow, dow_dict['default'])()"]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Monday\n"]}], "source": ["dow_switch_dict(1)"]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Invalid day of week\n"]}], "source": ["dow_switch_dict(100)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["One advantage of using a dictionary (as an associative array), is that you can add and remove elements from the dictionary at run time. Of course you cannot do that with the `if...elif...else` - you need to know at compile time how many branches your \"switch\" has (just like a regular `switch` would, that is also fixed once the code has been compiled+\n", ").\n", "\n", "But the downside of this approach compared to `if...elif...else` is that the dictionary values are relatively simple and cannot contain nested if statements or anything else. In the case of `if...elif...else` your code blocks for each of these statement can contain as many lines of code as you want.\n", "\n", "So the choice is yours, and depends on what you are trying to accomplish.\n", "\n", "Now, there is also another way to do this, and it is based on the concepts I discuss in the decorator videos on the single dispatch generic functions.\n", "\n", "We cannot use the standard library's `@singledispatch` decorator, but we can adapt the approach I showed you to create a `switch` function where we can register each `case` of the `switch`.\n", "\n", "First, let's recall our own implementation of the `@singledispatch` decorator:"]}, {"cell_type": "code", "execution_count": 7, "metadata": {"collapsed": true}, "outputs": [], "source": ["def singledispatch(fn):\n", "    registry = dict()\n", "    registry[object] = fn\n", "    \n", "    def register(type_):\n", "        def inner(fn):\n", "            registry[type_] = fn\n", "            return fn  # we do this so we can stack register decorators!\n", "        return inner\n", "   \n", "    def decorator(arg):\n", "        fn = registry.get(type(arg), registry[object])\n", "        return fn(arg)\n", "\n", "    decorator.register = register\n", "    return decorator"]}, {"cell_type": "markdown", "metadata": {}, "source": ["With this decorator, we are dispatching based on the type. But if you think of our `switch` statement, we really just want to dispatch based on a value (like the `dow` value).\n", "\n", "So let's tweak the decorator to no longer use a type, but an arbitrary value instead:"]}, {"cell_type": "code", "execution_count": 8, "metadata": {"collapsed": true}, "outputs": [], "source": ["def switcher(fn):\n", "    registry = dict()\n", "    registry['default'] = fn\n", "    \n", "    def register(case):\n", "        def inner(fn):\n", "            registry[case] = fn\n", "            return fn  # we do this so we can stack register decorators!\n", "        return inner\n", "   \n", "    def decorator(case):\n", "        fn = registry.get(case, registry['default'])\n", "        return fn()\n", "\n", "    decorator.register = register\n", "    return decorator"]}, {"cell_type": "markdown", "metadata": {}, "source": ["And that's all we need to change!"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We can now use it as follows:"]}, {"cell_type": "code", "execution_count": 9, "metadata": {}, "outputs": [{"data": {"text/plain": ["<function __main__.<lambda>>"]}, "execution_count": 9, "metadata": {}, "output_type": "execute_result"}], "source": ["@switcher\n", "def dow():\n", "    print('Invalid day of week')\n", "    \n", "@dow.register(1)\n", "def dow_1():\n", "    print('Monday')\n", "    \n", "dow.register(2)(lambda: print('Tuesday'))\n", "dow.register(3)(lambda: print('Wednesday'))\n", "dow.register(4)(lambda: print('Thursday'))\n", "dow.register(5)(lambda: print('Friday'))\n", "dow.register(6)(lambda: print('Saturday'))\n", "dow.register(7)(lambda: print('Sunday'))"]}, {"cell_type": "markdown", "metadata": {}, "source": ["And we can now use it this way:"]}, {"cell_type": "code", "execution_count": 10, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Monday\n"]}], "source": ["dow(1)"]}, {"cell_type": "code", "execution_count": 11, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Tuesday\n"]}], "source": ["dow(2)"]}, {"cell_type": "code", "execution_count": 12, "metadata": {}, "outputs": [{"name": "stdout", "output_type": "stream", "text": ["Invalid day of week\n"]}], "source": ["dow(100)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Of course you'll notice that our decorator is simply using the same dictionary / associative array approach we just looked at - except we can use decorators to do that work."]}, {"cell_type": "code", "execution_count": null, "metadata": {"collapsed": true}, "outputs": [], "source": []}], "metadata": {"kernelspec": {"display_name": "Python 3", "language": "python", "name": "python3"}, "language_info": {"codemirror_mode": {"name": "ipython", "version": 3}, "file_extension": ".py", "mimetype": "text/x-python", "name": "python", "nbconvert_exporter": "python", "pygments_lexer": "ipython3", "version": "3.6.1"}}, "nbformat": 4, "nbformat_minor": 2}